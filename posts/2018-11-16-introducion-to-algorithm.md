---
title: 算法导论
---

算法基础
--------

### 循环不变式

1. 初始化：循环的第一次迭代前为真
2. 保持：如果循环的某次迭代前为真，那么下次迭代前仍为真
3. 终止

### 渐进记号

* O表示渐进上界，Ω表示渐进下界，Θ表示渐进确界
* 求解递归式：代入法、递归树法、主方法

代入法

* 失败时可以考虑**减去**一个低阶项
* T(n)=2T(n/2)+n -\> T(n)=O(nlgn)
* T(n)=2T(n/2)+c -\> T(n)=O(n)
* T(n)=2T(sqrt(n))+lgn -\> 令m=lgn, T(n)=O(mlgm)
* T(n)=9T(n/3)+n -\> T(n)=O(n^2)
* T(n)=T(2n/3)+c -\> T(n)=O(lgn)
* T(n)=8T(n/2)+n^2 -\> T(n)=O(n^3)

### 在线雇佣

类似于选苹果的故事。在n个人中只雇佣一次，希望最大化质量，则做法为：选取一个正整数k\<n，拒绝前面k个，雇佣其后面第一个比前面所有分数都高的人。k应取n/e，雇到最好的应聘者的概率至少为1/e。

### 模拟指针和对象的实现

* 多数组表示：每个属性都用一个数组表示，则相同属性储存在一起，每个数组用相同索引访问就是同一个对象的属性；此时模拟单向链表只需要一个next数组指示下一个结点的索引和一个全局的头索引
* 分配与释放：用一个全局的free值指示下一个空闲的索引位置，所有空闲的索引用next数组联系起来；分配时返回free当前指向的索引，并把free改成指向的指向的索引，释放时类似
* 单数组表示：把一个对象的所有属性储存在一起，这样允许不同长度的对象储存于同一数组中，但是管理更困难，访问属性需要用对象的位置再手动偏移

### 随机化数组

1. 对每个元素随机产生一个1到n^3的优先级，然后按优先级排序。
2. Fisher–Yates shuffle 洗牌算法：遍历数组，每个元素与i到n的随机一个元素交换；或者从后往前操作；实际上就是随机取出一个后去掉它，只是次法原地操作了。交换时不能在所有元素中选，也不能用sort(0.5\>rand())

### 产生不重复随机数

* 1-m中取n个数，m较小时用洗牌算法；较大时用哈希表，重复了再抽一次
* 分布式可以用GUID
* 假随机可以在1到m-1中生成一个质数，每次取加自己模m的数，因为这是个循环群

分治法
------

1. 分解 (Divide) ：原问题分解为若干子问题，子问题是原问题的规模较小的实例
2. 解决 (Conquer) ：递归地求解子问题
3. 合并 (Combine) ：合并子问题

### 例子

* 矩阵乘法
* 合并排序

### 最大子数组问题

例如：[13, -3, --25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]，18到12之和即为最大子数组。此问题中部分元素必须小于0否则无意义；或者如果全是正的而要算变化值最大的，可以用后一个减去前一个，就会出负的

* 分治算法：为完全位于左边、完全位于右边、跨过中间，这三者的最大值，递归求解
* 在线处理：只需遍历一遍即可完成。从头开始加，记录下最大的时候；如果加到了小于0就之间把前面的部分全部舍弃，因为当前评估的值会抵消掉之前所有的和，直接不要了（最大的还是要记录着）

排序
----

* 插入排序、希尔排序
* 选择排序
* 冒泡排序、鸡尾酒排序
* 归并排序

### 堆排序

* Heapify：在子树已是最大堆但自己不是是调用，如果比不越界的孩子小，则交换后递归下降调用；O(log2(n))
* 建堆： 从n/2到1依次调用Heapify
* 堆排序算法：根与最后一个结点互换，堆的长度减一，直到堆的长度为1
* 优先队列：最大堆具有IncreaseKey函数而不允许减少值， 最小堆相反 ，函数体与建堆类似；Insert函数先在末尾插入一个负无穷的结点，堆长度加一，然后调用增大值的函数

### [快速排序](https://www.zhihu.com/question/39214230)

* 快速排序的平均运行时间更接近其最好情况，即使进行99:1的划分其时间复杂度仍是O(nlog2(n))
* 一般使用三数取中：从第一项、最后一项、中间一项中取中位数作为pivot
* 以下方法是算法导论的方法，仅从左向右排序；严的是从两边向中间遍历的双向分区方式
* 小数组使用选择排序，因为快排需要递归；时间太长需要转堆排

```
QuickSort(int A[], int p, int r){
    if(p<r){
        int q = Partition(A, p, r); // 会改变A
        QuickSort(A, p, q-1);
        QuickSort(A, q+1, r);
    }
}
Partition(int A[], int p, int r){
    int x = A[r]; // pivot element主元
    int i = p - 1; // 小于主元的部分的末尾
    for(int j=p;j<r-1;j++) // 大于主元的部分的末尾，同时也是当前评估的
        if(A[j]<=x) // 当前评估的大于主元则什么也不用做
            Swap(A[++i], A[j]); // 否则把大于主元的部分的第一个值与当前互换
    Swap(A[i++], A[j]); // 主元放到中间
    return i+1;
}
```

### 计数排序、基数排序

* 基数排序(radix sort)：对十进制数字来说，从低有效位到高有效位进行排序；排序算法必须稳定，故可选计数排序
* 计数排序：见下

```
CountingSort(int A[], int B[], int k){ // A为原数组，B为排序后的数组，k至少为A中的最大值+1
    int* C = calloc(k, sizeof(int));
    for(int i=0;i<A.Length;i++)
        C[A[i]]++; // 设t=A[i]，则C[t]是A里值等于t的元素的个数
    for(int i=1;i<k;i++)
        C[i]+=C[i-1]; // C[t]是A里值小于等于t的元素的个数，且C[k-1]==A.Length
    for(int i=A.Length-1;i>=0;i++) // 将原数组从后往前复制能保证稳定
        B[C[A[i]]--]=A[i]; // C[t]即为排序后的元素的索引，复制一个以后减一获得下一个同值元素的新索引
}
```

动态规划
--------

### 原理

* https://www.zhihu.com/question/23995189/answer/613096905
* 最优子结构：一个问题的最优解包含其子问题的最优解
* 重叠子问题：反复求解相同的子问题；同时也是与分治的区别
* 子问题必须无关：最长路径不具有最优子结构的性质

#### 步骤

1. 刻画一个最优解的结构特征。
2. 递归定义最优解的值。
3. 计算最优解的值，通常采用自底向上的方法。
4. 利用计算出的信息构造一个最优解。

### 例子

* 钢条切割、矩阵链乘：自底向上，f(x)=max/min{g(分割点i)}
* 0-1背包问题：价值 arr[重量]，arr[x]=max{arr[x-w(i)]+v(i)}；找钱问题：RMB可用贪心，但如面额只有11、5、1，找15时只能用DP，数量 arr[金额]
* 最长公共子序列（LCS）：对于两个序列X和Y来说，如果最后一个元素相等，则LCS去掉最后一个元素形成的序列Z-1是X-1和Y-1的LCS；如果不等，则X和Y的LCS=max{(X-1,Y), (X,Y-1)}，它有重叠子问题(X-1,Y-1)。一直到(X,0)和(0,Y)=空
* 最长递增子序列（LIS）：dp[x]表示**以第 x 元素为结尾的LIS**的长度，则=max{dp[i]+1, if arr[x]\>arr[i]}，这样复杂度为O(n^2)，还有[nlogn的做法](https://blog.csdn.net/joylnwang/article/details/6766317)；可以建树但想不清复杂度是多少

贪心算法
--------

* 无状态，不会重新选择
* 每次选择分支的时候，只要选择一个分支，这个分支的解就一定比其他选择更优。此时才能用贪心算法

树
--

* 分支无限制的有根树：左孩子右兄弟表示法

图
--

### 图的表示

* 抽象表示：G=(V, E)，V是结点，E是边；
* 邻接链表：Adj[u]包含所有指出结点u的结点，空间需求为O(V+E)
* 临界矩阵：二维数组[V, V]

### 最短路径

> https://www.zhihu.com/question/274168564/answer/372990886
>
> (1)Dijkstra不能处理负边权的问题，所以遇到负边权问题只能用BellmanFord。
> (2)Dijkstra可以用堆优化，但是代码量比较大。BellmanFord代码量很小，使用队列优化(国内称SPFA)代码量会大一点，但好像还是比Dijkstra好写。
> (3)Dijkstra效率更高。SPFA很容易被出题人卡。

```
Relax(u,v,w){ // 松弛
    if(v.d>u.d+w(u,v)){ // w为直接距离
        v.d=u.d+w(u,v); // 最短距离
        v.p=u; // 前一个结点
    }
}

BellmanFord(G,w,s){
    InitializeSingleSource(G,s); // 所有结点v.d=无穷，v.p=null
    for(int i=1;i<=G.V-1;i++) // 循环点的数量-1次
        foreach edge(u,v) from G.E // 每次松弛所有的边
            Relax(u,v,w);
    foreach edge(u,v) from G.E
        if(v.d>u.d+w(u,v)) // 存在权重为负的环路
            return false;
    return true;
}
// 动态规划的BF算法：dx(y)=min{cx(v1)+dv1(y), ...}，v为x的相邻结点

Dijkstra(G,w,s){
    InitializeSingleSource(G,s);
    S=空集;
    Q=G.V;
    whlie(Q!=空集){
        u=ExtractMin(Q);
        S=S.Add(u);
        foreach v from G.Adj[u] // 所有指出u的结点
            Relax(u,v,w);
    }
}

InitializeSingleSource(G,s){
    foreach v in G.V{
        v.d=无穷;
        v.p=null;
    }
    s.d=0;
}
```

尾递归
------

* 把尾递归改成递推：https://zhuanlan.zhihu.com/p/36587160
* 写尾递归函数有什么规律或技巧吗？：https://www.zhihu.com/question/52305783


