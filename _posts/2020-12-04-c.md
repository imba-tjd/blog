---
title: C语言
---

## 基本概念

* ASCII码：'0'是48和\x30，'A'是65和\x41，'a'是97和\x61，'\n'是10和0x0a，' '是32和\x20；[32,127)是可打印字符
* 转义：\n在文本模式IO时会转换成对应系统的换行，\unnnn可转义unicode字符且可生成多个字符
* 标识符：双下划线开头的、一个下划线加大写字母开头的、一个下划线开头的外部标识符都是保留标识符
* 未定义行为：越界、有符号整数溢出、*NULL、无顺序点表达式中多次修改变量、通过不同类型的指针访问对象（strict-aliasing，编译器假定相同的内存地址绝不会存放不同类型的数据，但char除外）、访问未初始化变量、访问被realloc过的指针、无副效应的无限循环（可能被全部优化掉而继续执行）；未指定行为：求值顺序
* 单行注释也能影响下一行：`//\`

## 变量及类型

* 实现定义：一个字节多少位，可用CHAR_BIT表示、char是否带符号、超出char范围的字符字面量如`'ab'`（不过字符字面量就是int是定义了的，即sizeof 'a'是4，又不过c++是1）
* 所有的非零值都被认为是真，但注意两个不同的非零值进行相等比较为假，不过任何非零值转换成bool都是1
* long：Linux下8字节，MinGW是4字节
* 类型提升：无函数原型或变参数函数传递参数时char和short会自动转换成int，float自动转换成double；int和unsigned运算会变为unsigned，导致`-1<0u`为假；short -> unsigned，先改变大小转换到int，再转换到unsigned
* 类型降级：目标是无符号整数且待赋的值是整数时额外的位会忽略/截断（数学上mod UINT_MAX+1），目标是有符号整数且待赋的值是整数时是实现定义（一般也是截断），目标是整数且待赋的值是浮点时忽略小数部分（无warning），如果范围还超出就未定义
* 复合字面量，用于传参时创建临时数组：`(int[]){1,2}`
* C23把非补码表示的支持删掉了？
* bool占4字节，C++是1字节
* 结构体可以赋值，但不能==
* Linux定义了ssize_t
* 十六进制浮点字面量：0xa.1fp10表示(10+1/16+15/256)*2^10

### 数组

* 定义二维数组时如果给了初值，可以省略行数，不能省略列数
* `a[b] 等于 *(a + b) 等于 b[a]`，非C会因为b不是数组类型而报错
* `int **p`和`int(*)[]`不兼容
* `int[3,4]`中的3,4其实是逗号表达式，会引起警告
* C99的designated initializer初始化指定索引的元素：`int arr[4]={[1]=123,456}`，其中456赋给arr[2]，其余都初始化为0
* VLA：必须是自动储存类别，定义时不能初始化；标准没有规定用哪个函数实现以及是否在栈上分配，实际基本是用alloca，会移动栈指针导致一些优化失效；允许typedef一次；C++没有该特性因此往往实现得不好；影响goto，不能从VLA生命周期未开始前跳到开始后，不过可以跳到结束后；sizeof能正常计算但传参过函数后还是会退化
* 作为参数时会退化为指针，可省略最高维长度，可自增改变；传二维数组时必须声明长度，如`int arr[][3]`或`int (*arr)[3]`，也可用VLA`int cols, int arr[][cols]`；结构体中的数组不会退化，但会完整复制一遍

### 指针

* 强制给指定地址赋值：`*(int *)100=25`，一般用于访问预先已知的设备控制器接口
* 整数或对象指针包括void*无法与函数指针之间转换
* 函数指针数组（转移表）：`int (*funcs[])(int)`
* 赋值时void*与其它类型指针之间不用强转且无警告，但c++要

### 字符串

* 字符串转其它：atoi(char*)前导空白自动跳过、atof(char*)返回double、strtol指定base（可为0则自动检测）和保存未转换的部分方便后续处理

## 运算符

* 优先级：算移比位逻赋：*、<<、<=、&、&&、=
* 与和或运算符都具有顺序点，`p&&*p++`可防止空引用
* `(struct S *)p->v`会报错，必须写成`((struct S *)p)->v`
* 逗号表达式优先级最低，`1?a++,b++:b++,a++`相当于`(1?(a++,b++):b++),a++`而不是`1?(a++,b++):(b++,a++)`因此a会加两次，有顺序点；声明多个变量以及初始化器中的逗号不是逗号表达式但也有顺序点，函数参数列表中的逗号不是逗号表达式且没有顺序点

### 三元

* 取三个数的最大值：`a>b ? (a>c ? a:c):(b>c ? b:c)`；比较两个数：`a>=b ? (a>b ? 1:0):-1`；此处的括号都可以不加
* 从右往左结合：`条件1 ? 结果1 : 条件2 ? 结果2 : 结果3`相当于`条件1 ? 结果1 : (条件2 ? 结果2 : 结果3)`，且相当于`if(条件1) 结果1; else if(条件2) 结果2; else 结果3`
* ?处有一个顺序点

### 位运算

* 左移一位相当于乘以2，右移k位相当于数学上除以(2^k)再向下舍入，如-3除以2等于-1.5，而-3>>2等于-2，注意C的-3/2等于-1，只有正数/2才和右移相同
* 右移且向上舍入：`(x+(1<<k)-1)>>k`
* 实现定义：有符号数右移是算术还是逻辑，一般都是算数位移保留符号
* 未定义：有符号整数移至符号位（1<<31）、左移负数、移位超过或等于该类型数值的长度（1u<<32），一般实现成位移mod该类型位数的数，如左移36变成左移4

## 输入输出

### printf和scanf

* 宽度是最小宽度，如果不够会自动使用更宽的；精度对于%f和%e是小数(默认6)，%g是有效数字(默认6自动选择小数和科学计数中更窄的)，%s是打印的最大字符数量，整数是打印的最小位数(如有必要会在前加0)，只使用`.`等于`.0`
* scanf除了%c以外的说明符会自动跳过输入项之前的空格，%c会读取空白字符，` %c`才能跳过空白字符，%nc读取n个字符到char*
* zd：size_t
* %#o：输出以0开头的8进制；%#x：以0x开头的16进制；%#X：以0X开头
* 0：对于数字格式，使用前导0填充字符宽度。`-`标志和指定精度的整数（打印整数的最小位数）会覆盖它
* 正号和空格：前者总是输出符号，后者为负时输出负号，否则输出空格。正号标志会覆盖空格标志
* hhd、hhu、hhx：signed char和unsigned char大小的数字
* t：ptrdiff_t（两个指针的差值）；p：指针的值，是个地址
* i：在scanf中自动处理0和0x前缀
* Lf：long double
* %n：把到目前为止这个scanf/printf处理了多少个字符保存到对应的int*参数里，所以会出现printf的参数也有&的现象。本身不消耗任何参数，不产生输出，也不算在scanf/printf的返回值内。MinGW不支持
* printf存在多个版本，如果没有检测出参数使用了浮点数（比如调用了未声明原型的函数，认为返回int），可能使用不处理浮点数格式码的版本
* 非标准修饰符：`"%2$d %1$d"`可以不按参数顺序输出，`"%m"`等价于`"%s",stderr(errno)`，会输出Success
* scanf返回读取了多少个变量对象，可能返回EOF；printf返回打印了多少字符
* MinGW要加`#define __USE_MINGW_ANSI_STDIO`才能支持zd、Lf、hhd

```c
// 在参数中指定宽度和精度
printf("Weight = %*.*f\n", width, precision, weight);

// 输入一个大于0的数
while(scanf("%d",&n),n<=0) ;

// 去掉缓冲区中本行剩余的内容，混用scanf和getchar、gets、%c时需注意；但还可能需要处理EOF
scanf("%d",&n); // 把\n留在了缓冲区中
gets(str); // 只会消耗一个换行符，然后把\0储存到str里
scanf("%*[^\n]%*c"); // 滞后赋值，读取后直接丢弃，不占用参数
while(getchar()!='\n') ; // 刚好把\n消耗完就结束
```

### gets和puts

* gets一直读取到`\n`之前，消耗缓冲区里的`\n`，但并不储存它，然后储存`\0`；puts会自动添加`\n`
* fgets最多读取size-1个字符或者读到`\n`，储存它们，然后储存`\0`；fputs不会自动换行
* 出错或到末尾时返回NULL
* gets_s只从stdin中读取，遇到换行符的行为与gets一样，读满时会把目标数组首字符设为`\0`

### 文件

TODO

## 函数

* 函数声明的括号中不加东西其实是没有函数原型，可用`-Wmissing-prototypes`进行检查
* 声明时可以不写参数名，定义时没有用到的参数也可以不写参数名

### 内联

* 不要去获得内联函数的地址，它没有地址，或者会导致它变得非内联
* 编译器在优化内联函数时必须要知道内容。因此内联函数的实现和调用必须在“同一文件”中，一般在头文件里**定义**函数static inline f(){}即可
* inline关键字和inline动作是不一样的，关键字只是建议，不保证进行动作，比如O0、递归时就不会动作。有人说GCC的`__attribute__((always_inline))`也不能保证总是内联，只是让内联在O0下生效
* 有人说inline不需要放在声明上，应放在实现上
* 对于extern inline和单独的inline：https://www.zhihu.com/question/270847649、http://wangcong.org/2012/03/07/-e5-85-b3-e4-ba-8e-extern-inline/
* 混合使用内联和外部定义同一个函数是未定义行为
* TODO：https://www.zhihu.com/question/45488363/answer/741627235

## 生存期、储存期、linkage、作用域、命名空间

* 处于生存期中的对象保有地址和值，超出生存期访问对象是UB。除了分配到堆上的对象外，生存期等于储存期。复合字面量拥有临时储存期
* 作用域：内层的会隐藏外层的。单独一个大括号是**嵌套作用域**；if,switch,for,while,do-while,函数体局部变量,函数定义的形参是**块作用域**；在任何块或参数列表外声明的标识符的作用域是**文件作用域**，也称作全局变量；函数内的tag且只有tag在该函数内的所有位置是**函数作用域**；（非函数定义的）函数声明的形参是(函数)原型作用域
* 块和原型作用域变量只具有空连接；块作用域变量可具有auto、register、static储存期，其中static在程序执行期间一直存在，不会进入寄存器
* 文件作用域永远具有静态储存期；默认为外部链接，会导出符号，使用static可改为内部链接，则在每个翻译单元里会产生单独的代码；如果想在别的文件中使用，别的文件中必须加extern作为声明，否则相当于重复定义(或加到头文件里)；函数和函数声明本身属于此；`int a; main(){extern int a;}`使用的就是前面的a
* 命名空间：不同的命名空间的同名标识符即使作用域相同也没关系。普通的叫通常命名空间，标号(label)在标号命名空间，struct, union, enum的标识符共享tag命名空间，struct内部的命名空间（用点和箭头访问）。`int a;goto a;a:;`是没问题的，`struct a{};union a{};`是error，`struct a{union b{};};union b{};`也是error，这也意味着`struct a{struct b{};};struct b x;`是可以的（在结构体外声明结构体内定义的对象）
* 不同于C++，C的枚举成员没有自己的作用域，且在通常命名空间中：`struct{enum{A}a;}s;s.a=A;`；struct也没有作用域，其成员与struct自己在同一作用域，但命名空间不同

## const

* 自动类别的const变量仅仅意味着只读，会分配内存空间，可以取地址，O2下能替代优化但仍保留了空间分配；不加static的全局const变量会放到常量区，static const会替代优化
* 可以`const int* = int*`，不能`const int** = int**`，可以`int* const* = int**`。若允许中间，就能`const int** pp = &(int*); *pp = &(const int)`，即把`int*`指向了`const int`
* 修改const对象是未定义行为
* typedef后再次const不报错，仅仅为了方便：`typedef const int ci; const ci i;`；普通多次使用const也没定义问题不过报warning

## 其它库

### assert.h

* 在`include<assert.h>`**前**`#define`或编译时定义(-D) NDEBUG可以消除所有的assert()调用
* 提供static_assert宏。否则用`_Static_assert`也可以

### 数学运算

* 前面的在stdlib里，exp开始的在math里。默认参数为double
* int abs(int)、fabs()
* div_t div(int x, int y)：计算y/x，返回的结构体中quot是商，rem是余数
* floor()：不大于其参数的最大整数值；ceil()：不小于其参数的最小整数值；参数类型为double是处于范围考虑
* fmod(x, y)：x整除y所产生的带小数的余数
* exp(x)：e的x次方
* log()：以e为底的自然对数；log10()
* pow(x, y)：x的y次方，x小于0时y必须是整数
* sqrt()、cbrt（立方根）
* modf(double, double* iptr)：把一个浮点数分解成整数和小数两个部分，返回小数部分且符号与原数一致，储存整数部分到iptr中
* ldexp(double fraction, int exponent)：计算fraction × 2^exponent
* frexp(double value, int* exponent)：dlexp的逆运算，把value分解成fraction和exponent，但关键是结果是正规化的
* 还有一个tgmath.h，为math和complex一些函数的泛型重载

### ctype.h

* iscntrl：任何控制字符
* isspace：空白字符，包括空格、换页\f、换行\n、回车\r、制表符\t、垂直制表符\v
* isdigit：十进制数字0-9
* isxdigit：十六进制数字，包括十进制数字、小写字母a-f、大写字母A-F
* islower：小写字母a-z
* isupper：大写字母A-Z
* isalpha：字母a-z或A-Z
* isalnum：字母或数字，0-9、a-z、A-Z
* ispunct：标点符号，任何不属于数字或字母的图形字符（可打印符号）
* isgraph：任何图形字符
* isprint：可打印符号，包括图形字符和空白字符
* int tolower(int ch)
* int toupper(int ch)

### locale.h

改变locale的效果：

* 可能向正在执行的程序所使用的字符集增加字符
* 打印的方向可能会改变
* 小数点符号可能会改变
* isalpha、islower、isspace和isupper可能包含更多的字符
* 对照序列可能会改变
* 时间和日期的格式可能会改变

### stdarg.h

* 无法判断实际存在的参数的数量，一般传参指定；无法判断每个参数的类型
* va_copy可以把va_list复制一份
* `__VA_ARGS__`可代表传进来的可变参数，一般用于进一步调用其它可变参数函数，且实参一般用`##__VA_ARGS__`，效果是如果可变参数没有传参，这个符号就把前面的`,`去掉，编译就不会出错；`puts(#__VA_ARGS__)`可显示可变参数字符串

```c
#include <stdarg.h>

double average(int num, ...) {
    double sum = 0;
    va_list var_arg;

    va_start(var_arg, num);
    for (int i = 0; i < num; i++)
        sum += va_arg(var_arg, int);
    va_end(var_arg);

    return sum / num;
}
```

### signal.h

* int raise(int sig)：引发一个信号
* signal(int sig, void (*handler)(int)):设置指定信号的回调函数，返回该信号前一个回调函数的函数指针
* SIGABRT：由abort函数引发的信号
* SIGFPE：发生一个算数错误，比如溢出或除以0。
* SIGILL：非法指令、把数据当成代码
* SIGSEGV：访问非法内存（野指针或越界）
* SIGINT：按下ctrl + c时触发
* SIGTERM：也是终止程序的请求
* SIGKILL、SIGSTOP：不能被捕捉也不会被忽略，终止程序
* SIGALRM：由alarm函数结束后产生
* SIG_DFL：函数指针，表示默认的处理函数
* SIG_IGN：函数指针，忽视信号
* 当一个已经设置了信号处理函数的信号发生时，系统首先恢复对该信号的缺省行为，这样是为了防止如果信号处理函数内部也发生这个信号可能导致的无限循环。然后调用信号处理函数。所以如果想要多次捕捉同一个信号，要在调用信号处理函数返回前再用一次signal函数
* 如果信号是异步的，也就是不是由于调用abort或raise函数引起的，信号处理函数便不应调用除signal之外的任何库函数（除了exit和非SIGABRT里的abort），否则结果未定义。而且，信号处理函数可能只能向类型为volatile sig_atomic_t的变量赋值，无法访问其他任何静态数据
* sig_atomic_t定义了一种CPU可以原子访问的数据类型
* 从信号处理函数返回会从信号发生的地点恢复执行，除了SIGFPE
* 进程收到一个信号后不会被立即处理，而是在恰当时机进行处理，比如内核态返回用户态之前

### unistd.h

* 非标准库，是posix函数库
* sleep(int seconds)

## 参考

* https://www.zhihu.com/people/huyanbing
* 《C和指针》、《C语言解惑》、《C陷阱与缺陷》、《C专家编程》

### TODO

不要写`int a=a;`
sizeof作用的对象是类型，里面的表达式理论上不会执行；https://blog.csdn.net/yangtrees/article/details/8898895
https://www.yanbinghu.com/categories/C/ 守望的个人博客
https://www.zhihu.com/question/263756540 一些未定义行为
a%b可用a-(a/b)*b来计算；a和b的最大值可用(a+b+abs(a-b))/2
gcc和clang支持尾递归优化。传参时引用了局部变量不会优化否则就变成悬挂指针了
memcpy可能会从后往前复制，毕竟标准说了重叠时是未定义的
https://github.com/miloyip/json-tutorial/blob/master/tutorial03_answer/tutorial03_answer.md#1a-windows-下的内存泄漏检测
qsort、bsearch
库函数：http://c.biancheng.net/ref/
一些嵌入式系统把argc设为-1，表示argv是以`\0`结尾的指针数组
https://github.com/zombie110year/c-cpp
合并C标准库笔记和预处理笔记
