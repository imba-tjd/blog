---
title: Python
---

## 杂项

```python
#!/usr/bin/env python3 # 这样可以避免硬编码解释器的路径
# coding=utf-8
# 末尾用\可换行（如果在括号内就无需），单行用分行可有多条语句
import numpy as np # 可不在开头import
from xxx import fun/* # 可直接fun()，无需xxx.fun()
```

## 基本输入输出

* 交互模式下直接输入变量名就可以打印，但print会进行`\n`转义而直接输不会
* pprint.pp可以格式化输出对象；pprint现在变成了一个类，需要import，还提供了一些有的复杂的控制格式的参数

```python
a = input('提示信息') # 也可用双引号；提示信息后不会换行；直接回车获得的是''
print('a=', a) # a= xxx，即逗号会变为空格，可用sep修改
print('123', end='') # 默认会换行，这样就可以不换行
```

## 值

* None表示空值，交互模式下什么也不输出
* True和False表示bool，逻辑运算用and or not；bool(0)和bool(0.0)为False，反过来转换类似
* int类型无限大，float表示小数，支持complex复数（1+2j）
* 两个整数用`/`除仍是浮点数：9/3 -> 3.0；整除或叫地板除用//
* 类型转换：int('123') -> 123，ord('A') -> 65，chr(66) -> 'B'，bool(1) -> True、bool('') -> False
* 赋值可以`a,b=b,a`，其实是元组，不过CPython有优化不产生中间变量打包解包；也可以连续赋值`a=b=1`，但不具有返回值，即不能`if a=True:`，除非用`:=`
* `**`：乘方
* 交互式中可以用下划线来查看上一次输出的结果
* 0bxxx是二进制数字，0o八进制，0x十六进制
* float('inf')、float('nan')：两个无穷大的数相等，两个不是数的东西不相等；hash前者为特殊值314159，后者为0

## 变量

* 函数中的变量是局部的，但for循环等不会产生作用域
* 全局变量可以直接在函数中获得，但如果想修改，必须在函数内用`global varname`，否则只会创建同名局部变量；其实只要出现赋值，那个变量在被预编译的时候就被认为是局部变量了，例如`x=x+1`和`print(x);x=1`即使存在全局变量x也会失败。nonlocal类似对应闭包外的局部变量
* locals()和globals()分别返回一个局部/全局空间内的字典，全局字典中还含有魔术对象
* 变量只是名字/标签，b=a后id(b)是等于id(a)的

## 字符串

* 单引号和双引号完全相同，如果单引号内要用单引号就要转义
* 是不可变对象，name[0]='a'会失败报错
* 字符串用的是UTF16；`\u`后跟UTF16编码可以转义
* 引号前加r表示string literal
* `'''`为多行字符串，注意转义仍有效；直接写在函数和类的定义下则为“文档字符串”，用对象的`__doc__``可单独查看
* 加b表示bytes，硬编码可自动转换，字符串.encode可变为此类型：`'中文'.encode('utf-8')` -> `b'\xe4\xb8\xad\xe6\x96\x87'`；反过来用decode()；byte()和str()的类型转换函数也类似，有encoding参数；bytes不可变，但bytearray(bytes)就可变了
* len对于普通字符串是计算字符数，对于bytes是计算字节数。其实都是长度。注意不是实例方法，是静态方法
* 成员函数：replace（可指定最多替换次数）、translate（传递一个字典用于替换）、strip/lstrip/rstrip(开头/结尾)、count(指定字符串出现的次数)、find/rfind(即indexof)、split、startswith、isalnum（所有字符都是字母或数字）、center/ljust/rjust(30)（居中/左对齐/右对齐）
* '-'.join([str])：使用横杠连结，直接连用''.join；这样设计是为了能让参数是任何可迭代类型
* 使用+拼接，可以与*n运算进行复制，`[]`取字符；其实都和List一样。转换成字符数组要用`list()`，不能用`[str]`
* 倒序可用`s[::-1]`反向切片；虽然有reversed()静态函数，但返回的是个迭代器且str()无效

### 格式化字符串

```python
'Age: %s. Gender: %s' % (25, True) # C的风格，%d,%f,%x,%%；特别的，%s会全自动转换
'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125) # 不需要也不能%%转义%，输出大括号用{{，如果索引按顺序可以省略，还可以命名
f'{name[0].upper()}{name[1:].lower()}' # fmt风格
a=1; print(f"{a=}") # a=1
```

## 流程控制、逻辑运算

```python
a = input() # 读取的是str，对应python2的raw_input
a = int(a)
if a >= 0: # 注意冒号
    print(a)
elif x: # 只要不是0、[]、''等就判断为True
else:
    print(-a)

for name in names: # 类似于于foreach；in后用range(n)可产生顺序序列达到类似for的效果；in后可直接跟逗号序列的元组，如`names,names`，则不会再解析里面的内容
    print(name)
for i, value in enumerate(['A', 'B', 'C'], starti):
    print(i, value) # 把一个list变成索引-元素对的可迭代对象，但感觉没什么用，也算达到类似for的效果
for a, b in zip(arr1, arr2) ... # 同时遍历两个序列，如果长度不一样会在短的遍历完就停止；zip(*lst)可以把二位数组变成列顺序
1 in (1,2,3) # True；且不知为何这时的字面量元组括号不可省

_sum = 0
n = 0
while n < 100:
    _sum = _sum + n
    n = n + 1
else: # 如果循环中没有执行break，还会进入这里；对for也有效
    ...
# break和continue不变；pass是空语句，相当于单独的分号

a = b if b is not None else c # 类似于三元运算；和数字比较时要用!=
1 < 2 < 3 # True，可以连用

空的列表[]、()、{}、set()、''、None、0、0.0在if（以及下一条）中的逻辑判断时和False一样，不为空时就和True一样。但[] is not None，[] is not False，[] != False
or和and可用在对象上：or返回第一个为真的操作对象，都为假就最后一个；and返回第一个为假的对象，都为真就最后一个
注意取不存在的属性和方法时是抛的异常而不是返回None，因此无法和这几个连用

# 异常
raise Exception(message)
try:
    ...
except ZeroDivisionError as e:
    ...
else:
    ...
finally:
    ...
一些预定义的异常：
TypeError：检查出类型不符合
ValueError：值不符合
IndexError：越界
SystemExit
```

## List

* list里的元素类型可以不同，也可以是另一个list
* 添加另一个list（或任意可迭代类型）可直接+=或用.extend，如果用append会只添加**一个**类型为list的元素。注意字符串可看作字符数组，[]+='abc'会变成三个元素的list，需要用['abc']或者用append
* 可以与*n运算，注意里面的元素是浅拷贝
* 将一个list直接赋值给另一个变量，连浅拷贝都不是，就类似于别名，修改一个里的元素会影响另一个

```python
classmates = ['Michael', 'Bob', 'Tracy']
len(classmates) # 3；获取长度只能用这个静态函数
classmates[-1] # 'Tracy'，可以被赋值，可变
L=[] # 空list
L.append(val)、insert(index, val)、pop()、pop(i)、remove(val)、reverse()、sort()、count(val)、clear()、index(val) # pop与栈的一样，返回值后删除；count是计算那个对象的出现次数
del(L[0]) --or-- del L[0] # 按index删除。这用法太诡异了
sorted(L) # 静态函数，返回一个新的List，原来的不变；而L.sort()只更改原来的，无返回值

# 如果要修改List，不能直接for迭代List本身，只能迭代长度的序列：
for i in range(len(L))
    L[i]=xxx

# 将List分隔成固定大小的List的序列
def chunks(l, n):
    return [l[i:i+n] for i in range(0, len(l), n)]
def chunks(l, n): # 生成器风格
    for i in range(0, len(l), n): # 开始，结束，步长；
        yield l[i:i+n]
```

### Slice

```python
L = [1,2,3]
L[1:2] # [start,end)，所以结果只有L1即[2]
L[-2:] # 后两个，[2,3]
L[:2] # 前两个，[1,2]
L[::5] # step，每5个取一个，仍可指定start和end
L2 = L[:] # 相当于全部复制一遍，id不同，不是赋引用；也可用.copy()或list()
L[:] = L[3:] # 修改列表“内容”，即之后L2也变了；若用L=L[3:]则只是给L自己赋了新引用
```

### 生成式/推导式

* 代替某些for、map、filter
* 可同时迭代两个列表

```python
[x * x for x in range(1, 11) if x % 2 == 0] # [4, 16, 36, 64, 100]
[m + n for m in 'ABC' for n in 'XYZ'] # AX AY AZ BX ...
[x * x if x % 2 == 0 else x for x in range(1, 11) if x != 9 and/or ...] #　[1, 4, 3, 16, 5, 36, 7, 64, 100]
{k:v for k,v in {'a':1,'b':2}.items()} # 字典推导式
{x for x in range(1, 11)} # 集合推导式
[item for sublist in a for item in sublist] # [[...],...] -> [...]，此处第二次遍历的对象依赖于第一次遍历，也就是for的顺序不变，只不过把最终结果放到最前了
```

### 生成器、迭代器、可迭代对象

* 把列表推导式最外面改成小括号就是生成器generator，是惰性的。for和list+=的时候会消费，只能消费一次，转换成list要用`list()`而不能用`[]`
* 函数中yield也是生成器。如果函数中先遇到yield，之后又遇到return，就会抛出异常，不过调用方可在e.value中获得return的值，一般这种情况是想返回序列，那再for一遍yield就好了；先遇到return函数就正常结束了
* 可迭代对象Iterable实现了`__iter__()`，可以for...in，包括两类：集合数据类型(list, tuple, dict, set, str)和生成器
* 在可迭代对象上用iter()获得的就是迭代器，实现了`__next__()`，可用next()手动消费，没有更多的元素时会抛出StopIteration；关键点：迭代器也实现了`__iter__()`，也就是也是可迭代对象，但是迭代器的iter()什么也不做，就返回它本身，这是什么设计？
* 生成器是特殊的迭代器，其中send()可以给函数内的yield设定返回值（然后继续next()的效果）
* 判断对象是否是可迭代的：isinstance([], collections.Iterable)，或用`hasattr(x, '__iter__')`
* 序列Sequence实现了getitem(切片)和len：list,tuple,str,bytes；没有dict因为那是映射类型
* 迭代器有效性：尾插入不会损坏指向当前元素的List迭代器，会损坏List尾迭代器；迭代器一旦耗尽，则将永久损坏；任何插入操作都将损坏Dict迭代器

## Tuple

```python
classmates = ('Michael', 'Bob', 'Tracy') # 不加括号也行
t=() # 空Tuple
t=(1,) # 只有一个元素的Tuple，不加逗号会被认为是数学意义的小括号，那是t就是数字1
m, b, c = classmates # 自动解构
first,*middle,end = (1,2,3,4) # middle为[2,3]

# 命名元组，既可以通过名称（点）访问，也可以用[offset]访问；仍是不可变的
from collections import namedtuple
Student = namedtuple('Student', 'name age')
stu = Student('Bob', 7) # 也可用字典构造：Student(**{'name':'Bob', 'age':7})
stu.name

t=(1,2,[3])
t[2]+=[4,5] # TypeError: 元组不可变，不支持赋值
t # (1, 2, [3, 4, 5]) 报了错居然还赋值成功了，其实是里面的List是可变的，+=不是原子操作，用.extend就不报错；总之还是不要放可变对象为好
```

## Dict

* 默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()
* 字符串转dict可用eval()，但必须是python的dict；JSON见下面JSON区域
* 将含有dict的list合并为dict：collections.ChainMap(*[dict1,dict2])->{...}
* 合并两个dict：dict(a,**b)、dict(a.items()+b.items())、c = {} c.update(a) c.update(b)、`{**d1, **d2}`、3.9后可用|和|=
* 与list一样是引用类型，复制时要用.copy()浅拷贝或用dict()
* 理论上是无序的，要保证遵循插入顺序可用collections.OrderedDict。但3.6后的实现是有序的

```python
# 生成字典
d = {'Michael': 95, 'Bob': 75, 'Tracy': 85} # key必须为不可变对象，如果是字符串必须加引号
dict(a=1, b=2) # 这样key可不加引号，但value如果是str仍要加
dict([('a', 1), ('b', 2)]) # 将双值子序列的序列转换为字典，结果为{'a': 1, 'b': 2}，其中无论里面还是外面都可以改为元组；dict(['ab'])会变成{'a':'b'}
dict(zip(['a','b'], [1,2])) # zip将两个序列变为双值子序列的迭代器，结果和上面一样。
# 无法写成dict('Michael=95')这样

d['Michael'] # 若key不存在会抛异常，改为.get()则key不存在时返回None或返回指定的default
d['Jack'] = 90 # 可以直接增加不存在的键值，但不能+=因为这样隐含了取值，可用defaultdict解决；不能用d.Jack=90，这是JS的
'Thomas' in d # False；也可用has_key()
d.setdefault(key, default) # key不存在时才set且返回default的值，如果存在就不会进行set，但仍会返回实际的值
collections.defaultdict(int) # 这种dict取任何不存在的key时都返回一个默认值，构建参数需要是一个函数，可为lambda，传int就是0，传list()就是[]
d.pop(key)、del d[key]、d.clear()
```

## Set

```python
s = set([1, 2, 3]) # 哈希表，无序。需传入list或Tuple，重复元素自动过滤，也只能放不可变对象；传Tuple时不会放一整个Tuple，而是取出其中的元素放进去
s = {1, 2, 3} # 是Set而不是字典，输出也以大括号包裹的形式；但是{}是创建空字典，set()才是空集合
1 in s # True；不在用not in
s.add()、remove() # 也可用+=和-=
可以看作数学上的集合，因此可以做交集&、并集|、差集-、异或^、子集<=、超集>=，对应intersection()、union()、difference()、symmetric_difference()、issubset()、issuperset()；还有<和>代表真子集和真超集
frozenset：集合本身不可变，不能add
{a,b} == {1,2} # 优雅地表达a==1 and b==2
```

## 函数

* 可以用Tuple返回多个值
* 可以在函数里定义函数，支持闭包引用局部变量，且在循环中定义函数闭包的是相同id的变量
* 可以接受或返回函数（本身称作高阶函数），多次调用该函数得到的返回函数为不同id的函数
* 可以把函数赋值给变量，但仍与对象绑定：`lst=[];a=lst.append;a(1);lst`
* 默认参数：`def power(x, n=2):`；命名参数：无需特别定义，调用时用=指定即可`enroll('Adam', 'M', city='Tianjin')`
* 可变参数：`def calc(*numbers):`，调用时可以传任意多的参数，如`calc(1, 2)`，函数内获取到的是Tuple；如果原本就有一个List或Tuple，可通过`calc(*nums)`调用，且传入的是值的拷贝
* 关键字参数：`def person(name, age, **kw):`，调用：`person('Bob', 35, city='Beijing')`，在函数内kw是dic，未传任何参数则为`{}`，检查传入了哪些参数用`in`；传入原本就有的字典用**dic
* 命名关键字参数：`def person(name, age, *, city, job)`，星号后的两个是命名关键字参数；调用：`person('Jack', 24, city='Beijing', job='Engineer')`，必须用k=v的形式传入指定名字的参数，除非有默认值，否则报错；如果参数列表里已经定义了可变参数就无需再用星号分隔了：(name, age, *args, city, job)
* 参数定义的顺序必须是：必选参数/位置参数、默认参数、可变参数、命名关键字参数、关键字参数
* 对于任意函数，都可以通过类似`func(*args, **kw)`的形式调用它，无论它的参数是如何定义的
* 偏函数（固定参数的函数）：int2 = functools.partial(int, base=2)
* 检查参数类型：isinstance(x, (int, float))，如果x是第二个参数的子类也能通过；用type()就没有后者的效果
* lambda x, y: x * 10 + y
* map：基本相当于Select，只能迭代一次所以组合使用可能出问题。不同在于它可以接受多个序列，例如map(pow, [1,2], [3,4])结果是[1, 16]，迭代到如果后者更长则前者就会为None

```python
# 默认参数必须指向不可变对象，否则下次调用看到的就是改变了的对象；类的成员就不用这样了；可以用以下方式避免：
def add_end(L=None): # None是不可变的；如果直接用L=[]，第二次调用会留下上一次的结果
    if L is None:
        L = []
    L.append('END')
    return L
```

### 装饰器

* 是高阶函数，一般需要返回一个函数；实际上是**执行**了一个可以有逻辑的函数
* 可以有多个装饰器，靠近函数的先执行
* 如果装饰器也想有参数，就要编写一个返回装饰器的高阶函数；但也可以不消费func，做完操作后仍返回它，则还是只有两层
* functools.lru_cache(maxsize=5)：缓存最近几次函数计算结果，有cache_info()和clear_cache()

```python
def log(func): # func即原函数
    def wrapper(*args, **kw): # 这是原参数
        print('call %s():' % func.__name__)
        return func(*args, **kw) # 消费了原函数
    return wrapper # 还是只有一层函数

@log # 相当于定义完now后再now = log(now)
def now():
    print('2015-3-25')
now() # call now(): ...

# 有参的装饰器，实际上是调用了一个函数返回装饰器
def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator

@log('execute') # 相当于now = log('execute')(now)
def now():
    print('2015-3-25')
now() # execute now(): ...

now.__name__ # 结果为wrapper，因为它本来就相当于变成另一个函数了；若要解决，用functools.wraps修饰wrapper
import functools
def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
```

### [预定义(静态)函数](https://docs.python.org/zh-cn/3/library/functions.html)

* 类型转换：int、float、str、bool；其中int()支持base参数指定输入的进制
* help：可以查看其它函数的参数和说明；不加参数会进入交互模式
* type：返回对象的类型，之后可以用is判断；不要直接`变量 is 类型`，这是C#的
* dir：获取该对象所有的属性和方法，返回数组；vars：获取属性和方法还有他们的值，返回dic；但dir可以返回元类创建的东西，而vars不行，且vars需要`__dict__`属性
* eval：把字符串解析为python**表达式**然后返回，因此字符串里面不能有赋值语句；exec：解析成python语句，没有返回值，但是里面可以有赋值语句且会影响locals()；execfile废弃了
* getattr(obj, 'attrname', default)、setattr()、hasattr()：操作对象的属性和方法
* sorted：从小到大排序，可设置reverse=True、reversed->迭代器、any/all->bool
* pow：支持第三个参数取模、round：四舍六入五平分、divmod：同时获得除数和余数、abs：支持整数和实数、max、min、hex
* sum：第二个参数为起始值且不能是字符串，sum([[1,2],[3]],[])可以解包一层列表，但每次都会浅拷贝一遍，10个以下可用
* math.sqrt、factorial、log（默认以e为底）、sin、hypot（勾股定理）、ceil、floor、degrees（弧度转角度）、.pi、fsum（对于浮点数比sum精度高）
* assert
* range
* ascii：把非ascii字符变成转义序列，如`ascii('你好')`->`'\\u4f60\\u597d'`

## 类

* 以下划线开头的成员对象是私有变量/函数：以是单下划线开头只是一种约定。以两个下划线开头，Python（按照固定的规则）会修饰它的名称，达到用原本名称访问报错的目的；注意在类外对该变量进行赋值仍会成功，但这是创建了一个新的属性
* 还有个元类metaclass的特性，太复杂了

```python
class Student(parent): # 继承，默认object，本类声明完成后即使parent被重新赋值也不会变；支持多继承，若有同名方法左边优先
    count = 0  # 类字段，类中所有实例都能访问同一个，仍要加self；也可以在类方法里用cls.count访问；类外实例可读到它，但类外实例给该名字赋值却会创建新变量

    __slots__ = ('__name', '__score') # 限制该class的实例能添加的字段
    def __init__(self, name, score): # 构造函数
        super().__init__(...) # 子类会直接覆盖父类的同名方法，即使是构造函数也不例外，因此要手动调用，没覆盖才会用父类的；self会自动传递，只要传入其它参数即可
        self.__name = name # 定义实例字段
        self.__score = score
        Student.count += 1 # 类字段；如果用=，不提前声明也可以

    # 类方法用@classmethod修饰，作用于整个类，一个参数cls是类本身，可被调用即为构造函数且继承后没硬编码为父类；类外调用时用类名.方法名()，也可用对象名，但仍是与类绑定
    # 对于不需访问类的任何字段的方法，用@staticmethod

    def print_score(self): # 实例方法，第一个参数必须为self
        print('%s: %s' % (self.__name, self.__score))

    @property # 把一个方法变成getter，调用时无需括号，里面可以进行一些计算
    def score(self):
        return self.__score
    @score.setter # 使用时仍无需括号，直接赋值即可；其中点前面的东西要和函数名匹配；可不设置，类外看起来就是只读的
    def score(self, val):
        self.__score = val

bart = Student('Bart Simpson', 59)
bart.print_score() # 相当于Student.print_score(bart)
```

### 魔术方法

* 双下划线的英文名称：double underline, dunder；以下内容全部省略开头和结尾的双下划线
* str：print对象的值，repr：交互式终端中直接输入对象的值。可用`__repr__=__str__`；如果都没有就只会输出类型和地址
* 运算符：eq、nq、lt、gt、le、ge、add、sub、mul、floordiv(//)、truediv、mod、pow(**)；也可只定义eq和lt然后用functools.total_ordering装饰类
* 支持迭代：iter和next，支持取索引：getitem，在里面要判断是int还是slice才能支持切片；支持`()`调用对象本身：call，用callable()可判断是否支持
* 调用不存在的属性时会转为调用getattr，可以任意返回内容，如函数或新对象
* 用dataclass修饰类可自动生成repr、init、eq等方法
* len、setitem、delitem
* enter、exit：支持with语句；或者对处理函数用contextlib.contextmanager装饰器，中间一个yield表示执行用户代码

## 枚举

```python
from enum import Enum, unique, IntEnum
Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
Month(1) # int -> Enum；<Month.Jan: 1>
int(Month(1)) # 失败，必须把Month定义成IntEnum才能成功，这是因为枚举可以有MultiValue

@unique # 用来检查没有重复值
class Weekday(Enum): # 使用类的继承来自定义枚举，可以增加方法
    Sun = 0; Mon = 1; Tue = 2; Wed = 3; Thu = 4; Fri = 5; Sat = 6
```

## 自带的包

### 文件和IO

* 模式(mode)默认为r，不可写；w创建且覆盖，不可读；a打开并追加，不存在则创建，不可读；x不存在则创建，存在就报错，不可读；加+变成可读写；默认为t即text模式，用b以二进制打开，一定不能指定encoding，因为读写都为bytes
* encoding默认是gbk，坑

```python
# 在with中声明的变量，在外面也有效
with open('/path/to/file', 'r', encoding='utf8') as f: # errors='ignore'
    print(f.read(size)) # 不加size就是全读
    for line in f.readlines(): # 等价于while l := readline: ... 会在ctrl+Z处结束；也可以直接for line in f因为实现了迭代器协议
        print(line.strip()) # 把末尾的'\n'删掉
# writelines接受一个[]，然而它只会循环地写，并不会换行。而readlines会把\n也读到字符串里。这是什么设计？不过倒还确实是配合起来了

from io import StringIO, BytesIO
f = StringIO() # 当作文件用，类似于stream
f.write(' world') # 返回写入的长度
print(f.getvalue())
# 也可以把字符串传递给构造函数，但那样就不能写入了，否则会覆盖掉

f.seek()、f.tell()
```

### os

```python
import os, shutil, glob
os.name # Linux/Unix/MacOS为posix，Win为nt
os.uname() # posix下才有效，nt无效
os.environ['path'] # 还可以先用dotenv.load_dotenv()，之后就能读取.env中的K=V值，但优先级低于系统的
os.linesep # Win为\r\n，Linux为\n
os.curdir, os.pardir # 分别表示字符串字面量.和..
os.system() # 运行shell命令。注意每次调用该函数都相当于创建了一个新的shell
os.popen().readlines() # 获取shell的输出
os.access('path',os.F_OK) # 文件存在，还有R_OK, W_OK, X_OK

# os.path
os.path.isabs(), os.path.isdir(), os.path.isfile(), os.path.exists()
os.path.abspath('.') # 变为绝对路径
os.path.join()
os.path.split() # 把文件路径最后一部分分开：(文件夹路径不带末尾斜杠, 文件名加扩展名)元组
os.path.splitext() # 把路径和文件扩展名分开
# TODO: 替代os.path的库，pathlib：https://zhuanlan.zhihu.com/p/87940289

# 文件
os.remove(), os.rename()
os.chmod(), os.chown() # posix下有效
shutil.copyfile() # 为什么不是os模块提供的
os.link(), os.symlink(), os.realpath() # 与链接有关的函数

# 目录
os.mkdir(), os.rmdir(), os.listdir(), os.chdir(), os.makedirs(), os.removedirs()
os.getcwd() # 等价于os.path.abspath(os.curdir)
os.walk() # 类似于tree命令，递归遍历返回(路径,目录,文件)元组
shutil.copy()、move()
glob.glob() # 以Unix shell规则匹配文件和目录
```

### sys

* sys.argv：命令行参数，[0]为文件名，在交互shell中为''
* reload(sys)、sys.setdefaultencoding('utf-8')
* sys.path：会在这些地方寻找模块（目录和zip）；空字符串代表当前目录
* sys.platform
* sys.stdout.flush() # 如果python的print和shell的输出混合使用，必须用这个

### json

* dumps/loads：字典/对象与字符串互转
* dump/load(file)：从file-like对象中写入/读取json；如果文件为空会抛异常
* 序列化的参数：indent=4格式化，sort_keys=True进行排序；默认会把中文变成\u的转义，用ensure_ascii=False可以保留中文
* echo '{"json": "obj"}' | python -m json.tool：命令行工具验证与格式化
* 不允许有注释，否则可用第三方的用json5
* 二进制序列化/反序列化可用pickle，也是内置的
* `default=lambda obj: obj.__dict__`：直接dump对象会失败，要自己写方法，用这个可以偷懒。但如果成员有没有dict属性的，还是会失败，如requests.session()用了_thread.RLock。也许你只需要dumps(vars(o))
* datetime就无法自动序列化成json
* 增强版第三方库：simplejson

### logging

* https://zhuanlan.zhihu.com/p/56968001
* https://zhuanlan.zhihu.com/p/56095714
* https://www.cnblogs.com/Nicholas0707/p/9021672.html
* 默认会显示来源，顶层是root
* 级别默认是WARNING，即不会显示INFO和DEBUG

```python
import logging
logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG) # 还有%(asctime)s
logging.debug、info、warning、error、critical、exception
```

### 日期和时间

* calendar.isleap()：是否是闰年
* datetiem模块：date用于日期，time用于时间，datetime用于时间和日期都有，timedelta用于间隔，tzinfo为时区信息；另外还有一个单独叫做time的模块
* datetime.date.today().day/.month/.year；datetime.datetime.now/构造函数/.fromtimestamp；datetime.combine(date,time)
* 字符串和datetime互转：.isoformat()、strftime()、strptime()；还可先locale.setlocale根据地区选择不同的日期名称
* timeit.Timer("代码").timeit()
* 第三方日期库：https://github.com/arrow-py/arrow pendulum

#### time

* 3.8中time.clock()已经被移除了，因为在win上它是perf_counter，在Linux上是process_time
* time.perf_counter()：返回性能计数器的值，会算sleep的时间。基本上就是一个程序开始后就自动运行的stopwatch。但其实基准未定义，因此取时间差需要两次获取相减
* time.process_time()：消耗CPU的时间，不会计算sleep的时间。使用也是相减。少量运算这个值甚至都不会变，连续运算一般是上者的一半左右
* time.time()：自1970年以来的秒数，unix时间戳
* 以上三个方法虽然单位是秒，但默认已经有很多位小数了；另外还提供了更高精度的_ns后缀对应的函数
* time.ctime()：把秒数转换为字符串，time.asctime()：把struct_time转换为字符串；time.localtime()、time.gmttime()：把秒数转换为struct_time；time.mktime()：把struct_time转换为秒数
* time.sleep()

### re正则

* re.findall(pattern, str)：返回所有匹配到的字符串的数组，但若有捕获组就只返回捕获组，无匹配返回[]；finditer()作为迭代器返回，没有find()
* re.search(patter, str)：以Match对象返回匹配到的第一个组，无匹配返回None，m.group(n=0)获取捕获到的str，m.span(n=0)返回匹配到的起始和结束位置，m.groups()获取子捕获组，等价于`(m.group(1),...)`；re.match()：从字符串开头进行匹配
* re.sub(pattern, repl, str, cnt=0)：替换，其中repl可以是str或可调用对象
* re.split(patter, str)：返回划分过后的字符数数组
* re.compile
* 标志：re.I大小写不敏感，re.X忽略字符串中的空白和井号注释

### collections

* Counter：计数器，传list或可迭代对象给它的构造函数，以字典的形式记录出现次数；有.most_common()降序排序返回[(k,c)]，可指定c的下限；两个计数器之间可以+、-，可以用&取共有元素中的较小的数，用|取共有元素中较大的数（不是把c加起来）
* deque：双端队列，pop去掉并返回最右边的，poplift去掉最左边的
* OrderedDict：可以按字典中元素的插入顺序来输出，但构造函数初始化时的仍是无序的，必须要插入才行

### itertools

* 注意这些还是返回的迭代器，只能消费一次
* chain([1,2],('3','4'))->(1,2,'3','4')，即依次迭代任意数量的可迭代对象，但只能解一层：`*[[],...]->[...]`；chain.from_iterable不需要自己用星号解开
* cycle([1,2])->(1,2,1,2,...)，在可迭代对象之间无限反复迭代；repeat无限迭代单个元素；count(start=0, step=1)无限整数迭代器
* islice(iterator, from, to)：对迭代器切片，且不支持负向
* dropwhile/takewhile：前者相当于C#的skipwhile
* zip_longest：按最长的结束，不足的填None
* product多个可迭代对象的笛卡尔积，permutations可迭代对象的元素的全排列，combinations组合
* starmap, tee, compress
* accumulate：最终结果与reduce一样，仅仅只是默认回调为加法；不过此函数会迭代返回每一次的结果
* reduce：相当于Aggregate；回调函数接受两个参数：处理过的和当前的。必须先import functools才能用
* filter：相当于Where，但不快，不如用列表生成式

### typing类型标注

* 如果不返回一定要标None否则会认为是返回动态类型
* stub的函数体一般用...
* 可以有单独的stub包，但命名必须为xxx-stubs；如果和源代码放在一起或者内联，要一个`py.typed`空文件
* https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html
* 3.9以后list, dict等类型可直接标注
* 如果类作为容器类，要继承Generic[T]？

```python
# pyright: reportMissingTypeStubs=true；会创建typings/modename/*.pyi
typing.Any,Iterable,Mapping,MutableMapping,Text,Sequence,Literal,NoReturn（抛异常）
Vector = List[float] # 之后标准时就能用Vector类型
Callable[[...]，ReturnType] # 可调用对象的参数和返回值
def f(name: str, excited: bool = False, *args: int) -> str:
Union[int, None] # 任意一种；也可用Optional[int]
list[int or str]
tuple[int, ...] # 第一个元素是int类型其余数量未知；与list不同，每个都要声明
_T = TypeVar('_T',int,str); def first(l: Sequence[_T])->_T:l[0] # 泛型，用于容器中的类型推断，可理解为表示同一种类型的Any；参数声明了，返回值有几率自动推断
from __future__ import annotations # 在定义类的工厂方法时那个类还没定义完，直接注解会报错，可用这条或返回类名Literal或用TypeVar的bound
reveal_type(xxx) # 实际运行会出错，但在IDE中有info提示xxx的类型
```

### sqlite

```python
try: ... except sqlite3.Error: ... finally: if cursor: corsor.close(); if con: con.close()
con = sqlite3.connect(':memory:')
cursor = con.cursor()
cursor.execute('select ... from ...') # 参数化用?占位，用元组传入；非查询执行完要commit
result_set = cursor.fetchall()
for row in result_set: print(row[0],row[1])
```

### 内置模块

* http.server：绑定`[::]:8000`，给当前目录index
* pydoc -p 80：在网页端显示当前安装了的所有模块的文档，绑定localhost
* pdb xxx.py：调试
* timeit "code"：测试耗时

### 其它自带包

* struct：用于与C/C++的struct交互，帮助把它们转换成Python数据类型；第三方库也有一些但star数都很少
* binascii：在二进制和多种字符串表示之间转换
* csv：csv.writer(f).writerows([[r1],[r2]])；for r in csv.reader(f)；csv.DictReader(f,fieldname=[header])，若文件中存在header就省略第二个参数；csv.DictWriter(f,[header]).writeheaader().writerows(dict)
* dbm：字典形式的文件NoSQL
* decimal
* fractions.Fraction：将有理数表示为分子除以分母的形式；gcd()：最大公约数
* types：判断一个对象是否是函数时用到
* zlib：compress(), decompress(), crc32()；更高层的gzip可以把.gz当作file-like obj读取和写入
* hashlib：md5('你好'.encode(encoding='utf8'))只接受bytes；hexdigest()变为16进制字符串
* doctest：在文档字符串中写`>>>`以及结果，用doctest.testmod()就能自动测试
* io BufferedReader TextIOWrapper
* argparse：https://github.com/HelloGitHub-Team/Article/blob/master/contents/Python/cmdline/argparse-1.md
* zipapp
* bisect
* getpass：.getuser()、.getpass()
* ipaddress.ip_network：支持CIDR，支持in
* random：randint(from,to)闭区间；.random()浮点[0.0, 1.0)；uniform(a,b)b小于a也可的闭区间浮点；.choice(seq)随机返回一个元素，.sample随机获取k个元素；.shuffle改变原有序列顺序
* copy.deepcopy()深拷贝

## 设计模式

### 事件

此方法是我自己想的故可能不完善。定义实例方法用于静态提示，实际回调函数需要在构造函数里传入，覆盖同名函数；注意回调函数不必定义self，也只能用静态函数那样用。

```python
class A:
    def __init__(self, f1):
        self.f1 = f1
    def F(self):
        f1()
    def f1(self):
        raise NotImplementedError
```

### 单例

继承Borg类。实例的唯一性并不是重要的，我们应该关注的是实例的状态，只要所有的实例共享状态，行为一致，那就达到了单例的目的。

```python
class Borg:
    _shared_ state = { }
    def init_ (self):
        self._ dict_ = self.__ shared_ state

```

另一种方式是在模块中定义方法，第一次调用时创建模块中的全局变量，之后返回它。

## 参考

* https://www.liaoxuefeng.com/wiki/1016959663602400
* https://www.zhihu.com/question/268703765
* 《Python语言及其应用》
* https://www.zhihu.com/question/28966220
* https://stackoverflow.com/questions/16867347/step-by-step-debugging-with-ipython
* https://www.zhihu.com/people/python_cat

### 未读

* 常用内建模块 https://www.liaoxuefeng.com/wiki/1016959663602400/1017642838127488
* random、Queue
* https://zhuanlan.zhihu.com/p/152343123 24招加速你的Python
* https://zhuanlan.zhihu.com/p/149210936 听说你会 Python？
* https://keelii.com/2018/09/24/socket-programming-in-python/
* https://github.com/chinesehuazhou/peps-cn
* https://github.com/chinesehuazhou/guido_blog_translation
* https://github.com/satwikkansal/wtfpython https://github.com/leisurelicht/wtfpython-cn
* https://github.com/faif/python-patterns
* sqlite：https://www.liaoxuefeng.com/wiki/1016959663602400/1017801751919456
* https://pythonguidecn.readthedocs.io/zh/latest/

### AsyncIO

* https://zhuanlan.zhihu.com/p/55783243
* https://zhuanlan.zhihu.com/p/36936574
* https://www.liaoxuefeng.com/wiki/1016959663602400/1017985577429536
* aiohttp、aiofile
* 千万不要pip装它，那装上的是2017年的不在标准库里的包
