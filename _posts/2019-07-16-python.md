---
title: Python
---

## 杂项

```python
#!/usr/bin/env python3 # 这样可以避免硬编码解释器的路径
# -*- coding: utf-8 -*-
# 末尾用\可换行（如果在括号内就无需），单行用分行可有多条语句
from bs4 import BeautifulSoup as bs # 可以import *，可以from ..xxx从父目录中引用，可以在函数内部import
```

## 基本输入输出

* 交互模式下直接输入变量名就可以打印，但print会进行`\n`转义而直接输不会
* pprint.pp可以格式化输出对象；pprint现在变成了一个类，需要import，还提供了一些有的复杂的控制格式的参数

```python
a = input('提示信息') # 也可用双引号；提示信息后不会换行；直接回车获得的是''
print('a=', a) # a= xxx，即逗号会变为空格，可用sep修改
print('123', end='') # 默认会换行，这样就可以不换行
```

## 值

* None表示空值，交互模式下什么也不输出
* True和False表示bool，逻辑运算用and or not；bool(0)和bool(0.0)为False，反过来转换类似
* int类型无限大，float表示小数，支持complex复数（1+2j）
* 两个整数用`/`除仍是浮点数：9/3 -> 3.0；整除或叫地板除用//
* 类型转换：int('123') -> 123，ord('A') -> 65，chr(66) -> 'B'，bool(1) -> True、bool('') -> False
* 赋值可以`a,b=b,a`（其实是元组）
* `**`：乘方
* 所有变量都是隐式局部的；全局变量可以直接在函数中获得，但如果想修改，必须在函数内用global关键字单独声明一次变量，否则只会创建同名局部变量；locals()和globals()返回一个局部/全局空间内的字典，全局字典中还含有以两个下划线开头和结尾的一些对象
* 交互式中可以用下划线来查看上一次输出的结果
* 变量只是名字/标签，b=a后id(b)是等于id(a)的
* 0bxxx是二进制数字，0o八进制，0x十六进制

## 字符串

* 单引号和双引号完全相同，如果单引号内要用单引号就要转义
* 是不可变对象，name[0]='a'会失败报错
* 字符串用的是UTF16；`\u`后跟UTF16编码可以转义
* 引号前加r表示string literal
* `'''`为多行字符串，注意转义仍有效；直接写在函数和类的定义下则为“文档字符串”，用对象的`__doc__``可单独查看
* 加b表示bytes，硬编码可自动转换，字符串.encode可变为此类型：`'中文'.encode('utf-8')` -> `b'\xe4\xb8\xad\xe6\x96\x87'`；反过来用decode()；byte()和str()的类型转换函数也类似，有encoding参数；bytes不可变，但bytearray(bytes)就可变了
* len对于普通字符串是计算字符数，对于bytes是计算字节数。其实都是长度。注意不是实例方法，是静态方法
* 成员函数：replace（可指定最多替换次数）、strip/lstrip/rstrip(开头/结尾)、count(指定字符串出现的次数)、find/rfind(即indexof)、split、startswith、isalnum（所有字符都是字母或数字）、center/ljust/rjust(30)（居中/左对齐/右对齐）
* '-'.join([str])：使用横杠连结，直接连用''.join；这样设计是为了能让参数是任何可迭代类型
* 使用+拼接，可以与*n运算进行复制，`[]`取字符；其实都和List一样。转换成字符数组要用`list()`，不能用`[str]`
* 倒序可用`s[::-1]`反向切片；虽然有reversed()静态函数，但返回的是个迭代器且str()无效

### 格式化字符串

```python
'Age: %s. Gender: %s' % (25, True) # C的风格，%d,%f,%x,%%；特别的，%s会全自动转换
'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125) # 不需要也不能%%转义%；需要输出大括号可用{{和}}
f'{name[0].upper()}{name[1:].lower()}' # fmt风格
```

## 流程控制、逻辑运算

```python
a = input() # 读取的是str，对应python2的raw_input
a = int(a)
if a >= 0: # 注意冒号
    print(a)
elif x: # 只要不是0、[]、''等就判断为True
else:
    print(-a)

for name in names: # 类似于于foreach；in后用range(n)可产生顺序序列达到类似for的效果；in后可直接跟逗号序列的元组，如`names,names`，则不会再解析里面的内容
    print(name)
for i, value in enumerate(['A', 'B', 'C'], starti):
    print(i, value) # 把一个list变成索引-元素对的可迭代对象，但感觉没什么用，也算达到类似for的效果
for a, b in zip(arr1, arr2) ... # 同时遍历两个序列，如果长度不一样会在短的遍历完就停止

_sum = 0
n = 0
while n < 100:
    _sum = _sum + n
    n = n + 1
else: # 如果循环中没有执行break，还会进入这里；对for也有效
    ...
# break和continue不变；pass是空语句，相当于单独的分号

a = b if b is not None else c # 类似于三元运算；和数字比较时要用!=
1 < 2 < 3 # True，可以连用

空的列表[]、()、{}、set()、''、None、0、0.0在if（以及下一条）中的逻辑判断时和False一样，不为空时就和True一样。但[] is not None，[] is not False，[] != False
or和and可用在对象上：or返回第一个为真的操作对象，都为假就最后一个；and返回第一个为假的对象，都为真就最后一个
注意取不存在的属性和方法时是抛的异常而不是返回None，因此无法和这几个连用

# 异常
raise Exception(message)
try:
    ...
except ZeroDivisionError as e:
    ...
else:
    ...
finally:
    ...
一些预定义的异常：
TypeError：检查出类型不符合
ValueError：值不符合
IndexError：越界
SystemExit
```

## List

* list里的元素类型可以不同，也可以是另一个list
* 添加另一个list（或任意可迭代类型）可直接+=或用.extend，如果用append会只添加**一个**类型为list的元素。注意字符串可看作字符数组，[]+='abc'会变成三个元素的list，需要用['abc']或者用append
* 可以与*n运算，注意里面的元素是浅拷贝

```python
classmates = ['Michael', 'Bob', 'Tracy']
len(classmates) # 3；获取长度只能用这个静态函数
classmates[-1] # 'Tracy'，可以被赋值，可变
L=[] # 空list
L.append(val)、insert(index, val)、pop()、pop(i)、remove(val)、reverse()、sort()、count(val)、clear()、index(val) # pop与栈的一样，返回值后删除；count是计算那个对象的出现次数
del(L[0]) --or-- del L[0] # 按index删除。这用法太诡异了
sorted(L) # 静态函数，返回一个新的List，原来的不变；而L.sort()只更改原来的，无返回值

# 如果要修改List，不能直接for迭代List本身，只能迭代长度的序列：
for i in range(len(L))
    L[i]=xxx

# 将数组分隔成固定大小的数组的数组
def chunks(l, n):
    return [l[i:i + n] for i in range(0, len(l), n)]
def chunks(l, n): # 生成器风格
    for i in range(0, len(l), n): # 开始，结束，步长；
        yield l[i:i + n]
```

### Slice

```python
L = [1,2,3]
L[1:2] # [start,end)，所以结果只有L1即[2]
L[-2:] # 后两个，[2,3]
L[:2] # 前两个，[1,2]
L[::5] # step，每5个取一个，仍可指定start和end
L2 = L[:] # 相当于全部复制一遍，id不同，不是赋引用；也可用.copy()或list()
L[:] = L[3:] # 修改列表“内容”，即之后L2也变了；若用L=L[3:]则只是给L自己赋了新引用
```

### 生成式/推导式

* 代替某些for和map
* 可同时迭代两个列表

```python
[x * x for x in range(1, 11) if x % 2 == 0] # [4, 16, 36, 64, 100]
[m + n for m in 'ABC' for n in 'XYZ'] # AX AY AZ BX ...
[x * x if x % 2 == 0 else x for x in range(1, 11) if x != 9 and/or ...] #　[1, 4, 3, 16, 5, 36, 7, 64, 100]
{k:v for k,v in {'a':1,'b':2}.items()} # 字典推导式
{x for x in range(1, 11)} # 集合推导式
```

### 生成器和迭代器

把列表生成式最外面改成小括号就是生成器generator，是惰性的。一般用for来消费，list+=的时候也会自动消费；但如果用`[]`，仅仅产生一个generator元素的数组，此时要用list()。只能消费一次，第二次用list()就为空了。\
自定义函数用yield来返回值获得的就是生成器。如果函数中先遇到yield，之后又遇到return，就会抛出异常，不过调用方可在e.value中获得return的值；先遇到return函数就正常结束了。
手动消费：赋给g后可以next(g)获取下一个元素，没有更多的元素时会抛出StopIteration。\

可迭代对象Iterable包括两类：集合数据类型list, tuple, dict, set, str；以及生成器。如果要在前者上用next，要用iter()把它们变成迭代器。\
判断对象是否是可迭代的：isinstance([], collections.Iterable)，后者要import；或用`hasattr(x, '__iter__')`。

## Tuple

不可变，不能用`[]`赋值，但是可以用它取；当然如果里面有List，那个List还是可变的。

```python
classmates = ('Michael', 'Bob', 'Tracy') # 不加括号也行
t=() # 空Tuple
t=(1,) # 只有一个元素的Tuple，不加逗号会被认为是数学意义的小括号，那是t就是数字1
m, b, c = classmates # 自动解构
first,*middle,end = (1,2,3,4) # middle为[2,3]

# 命名元组，既可以通过名称（点）访问，也可以用[offset]访问；仍是不可变的
from collections import namedtuple
Student = namedtuple('Student', 'name age')
stu = Student('Bob', 7) # 也可用字典构造：Student(**{'name':'Bob', 'age':7})
stu.name
```

## Dic

* 默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()
* 字符串转dict可用eval()，但必须是python的dict；JSON见下面JSON区域
* 把含有dict的list改为dict：只能用下面的方法两两合并
* 合并两个dict：dict(a,**b)、dict(a.items()+b.items())、c = {} c.update(a) c.update(b)、`{**d1, **d2}`、3.9后可用|和|=
* 直接使用=赋值再改变里面的元素会影响与之相关的，可用.copy()浅拷贝；import copy; copy.deepcopy()可以深拷贝
* 理论上是无序的，要保证遵循插入顺序可用collections.OrderedDict。但3.6后的实现是有序的

```python
# 生成字典
d = {'Michael': 95, 'Bob': 75, 'Tracy': 85} # key必须为不可变对象，如果是字符串必须加引号
dict(a=1, b=2) # 这样key可不加引号，但value如果是str仍要加
dict([('a', 1), ('b', 2)]) # 将双值子序列的序列转换为字典，结果为{'a': 1, 'b': 2}，其中无论里面还是外面都可以改为元组；dict(['ab'])会变成{'a':'b'}
dict(zip(['a','b'], [1,2])) # zip将两个序列变为双值子序列的迭代器，结果和上面一样。
# 无法写成dict('Michael=95')这样

d['Michael'] # 若key不存在会抛异常，改为.get()则key不存在时返回None或返回指定的default
d['Jack'] = 90 # 可以直接增加不存在的键值，但不能+=因为这样隐含了取值，可用defaultdict解决；不能用d.Jack=90，这是JS的
'Thomas' in d # False；也可用has_key()
d.setdefault(key, default) # key不存在时才set且返回default的值，如果存在就不会进行set，但仍会返回实际的值
collections.defaultdict(int) # 这种dict取任何不存在的key时都返回一个默认值，构建参数需要是一个函数，可为lambda，传int就是0，传list()就是[]
d.pop(key)、del d[key]、d.clear()
```

## Set

```python
s = set([1, 2, 3]) # 哈希表，无序。需传入list或Tuple，重复元素自动过滤，也只能放不可变对象；传Tuple时不会放一整个Tuple，而是取出其中的元素放进去
s = {1, 2, 3} # 是Set而不是字典，输出也以大括号包裹的形式；但是{}是创建空字典，set()才是空集合
1 in s # True；不在用not in
s.add()、remove() # 也可用+=和-=
可以看作数学上的集合，因此可以做交集&、并集|、差集-、异或^、子集<=、超集>=，对应intersection()、union()、difference()、symmetric_difference()、issubset()、issuperset()；还有<和>代表真子集和真超集
```

## 函数

* 可以用Tuple返回多个值
* 可以在函数里定义函数，支持闭包引用局部变量，且在循环中定义函数闭包的是相同id的变量
* 可以接受或返回函数（本身称作高阶函数），多次调用该函数得到的返回函数为不同id的函数
* 可以把函数赋值给变量，但仍与对象绑定：`lst=[];a=lst.append;a(1);lst`
* 默认参数：`def power(x, n=2):`；命名参数：无需特别定义，调用时指定即可`enroll('Adam', 'M', city='Tianjin')`
* 可变参数：`def calc(*numbers):`，调用时可以传任意多的参数，如`calc(1, 2)`，函数内获取到的是Tuple；如果原本就有一个List或Tuple，可通过`calc(*nums)`调用，且传入的是值的拷贝
* 关键字参数：`def person(name, age, **kw):`，调用：`person('Bob', 35, city='Beijing')`，在函数内kw是dic，未传任何参数则为`{}`，检查传入了哪些参数用`in`；传入原本就有的字典用**dic
* 命名关键字参数：`def person(name, age, *, city, job)`，星号后的两个是命名关键字参数；调用：`person('Jack', 24, city='Beijing', job='Engineer')`，必须用k=v的形式传入指定名字的参数，除非有默认值，否则报错；如果参数列表里已经定义了可变参数就无需再用星号分隔了：(name, age, *args, city, job)
* 参数定义的顺序必须是：必选参数/位置参数、默认参数、可变参数、命名关键字参数、关键字参数
* 对于任意函数，都可以通过类似`func(*args, **kw)`的形式调用它，无论它的参数是如何定义的
* 偏函数（固定参数的函数）：int2 = functools.partial(int, base=2)
* 检查参数类型：isinstance(x, (int, float))，如果x是第二个参数的子类也能通过；用type()就没有后者的效果

```python
# 默认参数必须指向不可变对象，否则下次调用看到的就是改变了的对象；类的成员就不用这样了；可以用以下方式避免：
def add_end(L=None): # None是不可变的；如果直接用L=[]，第二次调用会留下上一次的结果
    if L is None:
        L = []
    L.append('END')
    return L
```

### 装饰器

* 是高阶函数，需要返回一个函数
* 可以有多个装饰器，靠近函数的先执行
* 如果装饰器也想有参数，就要编写一个返回装饰器的高阶函数

```python
def log(func): # func即原函数
    def wrapper(*args, **kw): # 这是原参数
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper

@log # 相当于定义完now后再now = log(now)
def now():
    print('2015-3-25')
now() # call now(): ...

# 有参的装饰器
def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator

@log('execute') # 相当于now = log('execute')(now)
def now():
    print('2015-3-25')
now() # execute now(): ...

now.__name__ # 结果为wrapper，因为它本来就相当于变成另一个函数了；若要解决，用functools.wraps修饰wrapper
import functools
def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
```

### [预定义(静态)函数](https://docs.python.org/zh-cn/3/library/functions.html)

* 类型转换：int、float、str、bool；其中int()支持base参数指定输入的进制
* help：可以查看其它函数的参数和说明；不加参数会进入交互模式
* type：返回对象的类型，之后可以用is判断；不要直接`变量 is 类型`，这是C#的
* dir：获取该对象所有的属性和方法，返回数组；vars：获取属性和方法还有他们的值，返回dic；但dir可以返回元类创建的东西，而vars不行，且vars需要`__dict__`属性
* eval：把字符串解析为python**表达式**然后返回，因此不能有赋值语句；exec：解析成python语句，没有返回值。可以用`exec(open('file.py').read())`；execfile废弃了
* getattr(obj, 'attrname', default)、setattr()、hasattr()：操作对象的属性和方法
* sorted：从小到大排序，可设置reverse=True、reversed、any：可迭代对象有任意一个判定为True就返回True
* pow：支持第三个参数取模、round：四舍六入五平分、divmod：同时获得除数和余数、abs：支持整数和实数、max、min、sum、hex
* math.sqrt、factorial、log（默认以e为底）、sin、hypot（勾股定理）
* assert
* range

### 高阶函数

* lambda x, y: x * 10 + y
* 注意以下都是静态函数，均是第一个参数接受函数，第二个是序列。处理完成后一般还要用list()转换一下
* map：基本相当于Select，返回可迭代对象；但现在map的返回值只能遍历一次（带有副作用），导致组合使用可能出问题。不同在于它可以接受多个序列，例如map(pow, [1,2], [3,4])结果是[1, 16]，迭代到如果后者更长则前者就会为None
* reduce：相当于Aggregate；回调函数接受两个参数：处理过的和当前的。必须先import functools才能用
* filter：相当于Where，但不快，不如用列表生成式

## 类

* 以下划线开头的成员对象是私有变量/函数：以是单下划线开头只是一种约定。以两个下划线开头，Python（按照固定的规则）会修饰它的名称，达到用原本名称访问报错的目的；注意在类外对该变量进行赋值仍会成功，但这是创建了一个新的属性
* 还有个元类metaclass的特性，太复杂了

```python
class Student(object): # 继承，默认object
    count = 0  # 类字段，所有实例都能访问同一个，仍要加self；也可以在类方法里用cls.count访问

    __slots__ = ('__name', '__score') # 限制该class的实例能添加的字段
    def __init__(self, name, score): # 构造函数
        super().__init__(...) # 子类会直接覆盖父类的同名方法，即使是构造函数也不例外，因此要手动调用，没覆盖才会用父类的；self会自动传递，只要传入其它参数即可
        self.__name = name # 定义实例字段
        self.__score = score
        Student.count += 1 # 类字段；如果用=，不提前声明也可以

    # 类方法用@classmethod修饰，作用于整个类，一个参数cls是类本身；类外调用时用类名.方法名()，也可用对象名，但仍是与类绑定
    # 对于不需访问类的任何字段的方法，用@staticmethod

    def print_score(self): # 实例方法，第一个参数必须为self
        print('%s: %s' % (self.__name, self.__score))

    @property # 把一个方法变成getter，调用时无需括号，里面可以进行一些计算
    def score(self):
        return self.__score
    @score.setter # 使用时仍无需括号，直接赋值即可；其中点前面的东西要和函数名匹配；可不设置，类外看起来就是只读的
    def score(self, val):
        self.__score = val

bart = Student('Bart Simpson', 59)
bart.print_score() # 相当于Student.print_score(bart)
```

### 魔术方法

* 双下划线的英文名称：double underline, dunder；以下内容全部省略开头和结尾的双下划线
* str：print对象的值，repr：交互式终端中直接输入对象的值。可用`__repr__=__str__`；如果都没有就只会输出类型和地址
* 运算符：eq、nq、lt、gt、le、ge、add、sub、mul、floordiv(//)、truediv、mod、pow(**)
* 支持迭代：iter和next，支持取索引：getitem，在里面要判断是int还是slice才能支持切片；支持`()`调用对象本身：call，用callable()可判断是否支持
* 调用不存在的属性时会转为调用getattr，可以任意返回内容，如函数或新对象
* len、setitem、delitem

## 枚举

```python
from enum import Enum, unique, IntEnum
Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
Month(1) # int -> Enum；<Month.Jan: 1>
int(Month(1)) # 失败，必须把Month定义成IntEnum才能成功，这是因为枚举可以有MultiValue

@unique # 用来检查没有重复值
class Weekday(Enum): # 使用类的继承来自定义枚举，可以增加方法
    Sun = 0; Mon = 1; Tue = 2; Wed = 3; Thu = 4; Fri = 5; Sat = 6
```

## 自带的包

### 文件和IO

* 模式(mode)默认为r，不可写；w创建且覆盖，不可读；a打开并追加，不存在则创建，不可读；x不存在则创建，存在就报错，不可读；加+变成可读写；默认为t即text模式，用b以二进制打开，一定不能指定encoding，因为读写都为bytes
* encoding默认是gbk，坑

```python
# 在with中声明的变量，在外面也有效
with open('/path/to/file', 'r', encoding='utf8') as f: # errors='ignore'
    print(f.read(size)) # 不加size就是全读
    for line in f.readlines(): # 等价于while l := readline: ...
        print(line.strip()) # 把末尾的'\n'删掉
# writelines接受一个[]，然而它只会循环地写，并不会换行。而readlines会把\n也读到字符串里。这是什么设计？不过倒还确实是配合起来了

from io import StringIO, BytesIO
f = StringIO() # 当作文件用，类似于stream
f.write(' world') # 返回写入的长度
print(f.getvalue())
# 也可以把字符串传递给构造函数，但那样就不能写入了，否则会覆盖掉

f.seek()、f.tell()
```

### os

```python
import os, shutil, glob
os.name # Linux/Unix/MacOS为posix，Win为nt
os.uname() # posix下才有效，nt无效
os.environ['path']

# 文件
os.path.isabs(), os.path.isdir(), os.path.isfile(), os.path.exists()
os.path.abspath('.') # 变为绝对路径
os.path.join()
os.path.split() # 把文件路径最后一部分分开：(文件夹路径不带末尾斜杠, 文件名加扩展名)元组
os.path.splitext() # 把路径和文件扩展名分开
os.remove(), os.rename()
os.chmod(), os.chown() # posix下有效
shutil.copyfile() # 为什么不是os模块提供的
os.link(), os.symlink(), os.realpath() # 与链接有关的函数
# TODO: 替代os.path的库，pathlib：https://zhuanlan.zhihu.com/p/87940289

# 目录
os.mkdir(), os.rmdir(), os.listdir(), os.chdir(), os.getcwd(), os.makedirs()
shutil.copy()、move()
glob.glob() # 以Unix shell规则匹配文件和目录
```

### 与shell交互

```python
os.system() # 运行shell命令。注意每次调用该函数都相当于创建了一个新的shell
sys.stdout.flush() # 如果python的print和shell的输出混合使用，必须用这个
os.popen().readlines() # 获取shell的输出
```

### sys

* sys.argv：命令行参数，argv[0]为文件名
* reload(sys)、sys.setdefaultencoding('utf-8')
* sys.path：会在这些地方寻找模块（目录和zip）；空字符串代表当前目录
* sys.platform

### json

* dumps/loads：字典/对象与字符串互转
* dump/load(file)：从file-like对象中写入/读取json；如果文件为空会抛异常
* 序列化的参数：indent=4格式化，sort_keys=True进行排序；默认会把中文变成\u的转义，用ensure_ascii=False可以保留中文
* echo '{"json": "obj"}' | python -m json.tool：命令行工具验证与格式化
* 不允许有注释，否则可以用json5，但需pip安装
* 二进制序列化/反序列化可用pickle，也是内置的
* `default=lambda obj: obj.__dict__`：直接dump对象会失败，要自己写方法，用这个可以偷懒。但如果成员有没有dict属性的，还是会失败，如requests.session()用了_thread.RLock。也许你只需要dumps(vars(o))。另外搜出了一个包：
* datetime就无法自动序列化成json

### logging

* https://zhuanlan.zhihu.com/p/56968001
* https://zhuanlan.zhihu.com/p/56095714
* https://www.cnblogs.com/Nicholas0707/p/9021672.html

```python
import logging
logging.basicConfig(level=logging.INFO)
logging.info、exception
```

### 日期和时间

* calendar.isleap()：是否是闰年
* datetiem模块：date用于日期，time用于时间，datetime用于时间和日期都有，timedelta用于间隔；另外还有一个单独叫做time的模块
* datetime.date.today().day/.month/.year；datetime.datetime.now；datetime.combine(date,time)
* 字符串和datetime互转：.isoformat()、strftime()、strptime()；还可先locale.setlocale根据地区选择不同的日期名称
* timeit模块：用简单的方法来测量一小段Python代码的耗时

#### time

* 3.8中time.clock()已经被移除了，因为在win上它是perf_counter，在Linux上是process_time
* time.perf_counter()：返回性能计数器的值，会算sleep的时间。基本上就是一个程序开始后就自动运行的stopwatch。但其实基准未定义，因此取时间差需要两次获取相减
* time.process_time()：消耗CPU的时间，不会计算sleep的时间。使用也是相减。少量运算这个值甚至都不会变，连续运算一般是上者的一半左右
* time.time()：自1970年以来的秒数
* 以上三个方法虽然单位是秒，但默认已经有很多位小数了；另外还提供了更高精度的_ns后缀对应的函数
* time.ctime()：把秒数转换为字符串，time.asctime()：把struct_time转换为字符串；time.localtime()、time.gmttime()：把秒数转换为struct_time；time.mktime()：把struct_time转换为秒数
* time.sleep()

### re

* re.findall(pattern, str)：返回所有匹配到的字符串的数组，但若有捕获组就只返回捕获组；没有find方法
* re.match(patter, str)：失败返回None，否则在m.group()中获取捕获到的str；search返回第一个匹配
* re.sub(pattern, repl, str)：替换，其中repl可以是str或可调用对象
* re.split(patter, str)：返回划分过后的字符数数组

### collections

* Counter：计数器，传list或可迭代对象给它的构造函数，以字典的形式记录出现次数；有.most_common()降序排序返回[(k,c)]，可指定c的下限；两个计数器之间可以+、-，可以用&取共有元素中的较小的数，用|取共有元素中较大的数（不是把c加起来）
* deque：双端队列，pop去掉并返回最右边的，poplift去掉最左边的

### itertools

* chain([1,2],('3','4'))：(1,2,'3','4')，即依次迭代任意数量的可迭代对象
* cycle([1,2])：(1,2,1,2,...)，在参数之间无限迭代
* accumulate()：最终结果与reduce一样，仅仅只是默认回调为加法；不过此函数会迭代返回每一次的结果

### AsyncIO

* https://zhuanlan.zhihu.com/p/55783243
* https://zhuanlan.zhihu.com/p/36936574
* https://www.liaoxuefeng.com/wiki/1016959663602400/1017985577429536
* aiohttp、aiofile

### 其它自带包

* struct：用于与C/C++的struct交互，帮助把它们转换成Python数据类型；第三方库也有一些但star数都很少
* binascii：在二进制和多种字符串表示之间转换
* csv：csv.writer(f).writerows([[r1],[r2]])；for r in csv.reader(f)；csv.DictReader(f,fieldname=[header])，若文件中存在header就省略第二个参数；csv.DictWriter(f,[header]).writeheaader().writerows(dict)
* dbm：字典形式的文件NoSQL
* decimal
* fractions.Fraction：将有理数表示为分子除以分母的形式；.gcd()：最大公约数
* types：判断一个对象是否是函数时用到

## 设计模式

### 事件

此方法是我自己想的故可能不完善。定义实例方法用于静态提示，实际回调函数需要在构造函数里传入，覆盖同名函数；注意回调函数不必定义self，也只能用静态函数那样用。

```python
class A:
    def __init__(self, f1):
        self.f1 = f1
    def F(self):
        f1()
    def f1(self):
        raise NotImplementedError
```

### 单例

继承Borg类。实例的唯一性并不是重要的，我们应该关注的是实例的状态，只要所有的实例共享状态，行为一致，那就达到了单例的目的。

```python
class Borg:
    _shared_ state = { }
    def init_ (self):
        self._ dict_ = self.__ shared_ state

```

另一种方式是在模块中定义方法，第一次调用时创建模块中的全局变量，之后返回它。

## 环境

```bash
pip install flake8 ipython autopep8
```

### python内置模块

* http.server：绑定`[::]:8000`，给当前目录index
* pydoc -p 80：在网页端显示当前安装了的所有模块的文档，绑定localhost
* pdb xxx.py：调试
* timeit "code"：测试耗时

### VSC的json

```json
// launch.json:
"type":"python",
"program":"${file}", // 调试文件
"module": "hello", // 调试模块，与program不能同时使用，相当于-m
"env": {}, // 略
"args": [], // 传递给模块的参数，不是传递给python命令行或者debugpy的
```

### ipython

* `In[]`和`Out[]`记录了每一次的输入和输出，关键是可以用中括号获取它们；最后三次输出保存在`_`,`__`,`___`中，输入保存在`_i`中
* 退出用的是Ctrl+D，python在Win下用的是Ctrl+Z；支持Ctrl+r的与bash类似的历史搜索
* 传递参数给文件或模块要用`--`，否则会被认为是传给ipython自己；而python不对`--`特别对待，行为不一致；ipython#8437
* 用pipx装的时候记得加`--system-site-packages`，且不要在里面的pip更新系统包
* 交互式输出对象默认使用pprint，可以用%pprint关闭；对print无效；在语句后加上分号会不显示交互式输出结果（不显示Out）
* 如果同时安装了jedi，tab的完成功能会更好
* `from IPython import embed`，运行到`embed()`时会进入IPython环境，但只能手动交互，并不是之后的代码就由IPython自动执行了，也不会读取设置，好处是修改了全局变量等退出到原有Python环境中时能保留；start_ipython()是普通的启动IPython的方法，会读取设置
* `from IPython.display import display`，之后用display()替代print()，能输出富文本
* 自动括号和引号：`/fun 1 -> fun(1)`，`/fun 1,2 -> fun(1,2)`；`,fun a b` -> `fun('a','b')`；`;fun a b` -> `fun('a b')`
* 默认输入时自动忽略`>>>`和`...`，用于方便输入含有交互式提示符号的语句；doctest_mode可以改变这一行为但不懂怎么用

#### [魔法命令](https://ipython.readthedocs.io/en/latest/interactive/magics.html)

* 单个%是行魔法，回车就执行，默认开启了%automagic，无歧义时不加%也行；两个%%是cell魔法，会提示`...`允许多行输入，无法省略百分号
* 命令的结果可以赋值给Python变量，此时无法省略%；命令的参数支持用`$`或者大括号嵌入Python变量，用`$$`转义一个`$`
* quickref：显示所有魔法命令的简要参考；lsmagic：显示所有支持的魔法命令；?加魔法命令：显示指定命令的参考
* run test.py：运行脚本，-i可以继承当前会话的变量，-d启动调试，-t计时，-p或prun启动Profiler，-m调用模块（参数仍要--）
* debug：在刚刚出现过异常后使用，能进入ipdb检视刚才的异常栈；当然也可以一开始就用，设置断点；支持%%，接下来输入代码就可以debug
* edit：启动编辑器来输入交互式代码，关闭后会传到cli里；VSC会自动加一个\n，没啥好办法
* store：持久化储存变量，store -r恢复
* hist：查看历史命令，-n加上序号，-g pattern用grep搜索
* timeit：统计语句运行的时间，会多次运行取平均值；有%%
* xdel：删除变量并试图清除在其对象上的一切引用
* who：显示当前所有变量，可指定要显示的类型；whos信息更丰富
* pip：可以直接运行pip
* macro name n1-n2 n3：把n1到n2及n3这几行代码命名为name的宏，之后输name即可，但那时就不显示具体输入内容了，可用store储存，用edit编辑
* pastebin：自动把东西上传到GitHub的gist里并返回链接
* alias：显示预定义的shell命令，也可设置自己的，不过直接设置不能持久化；rehashx：把path里的可执行文件都导入alias中，使用时就不用加叹号了
* pycat：语法高亮地显示文件
* bookmark、pwd、pushd、popd、dhist：与路径有关的一些操作
* env：显示环境变量
* !ls执行shell命令，但Win下默认是CMD，且编码为gbk；!!：没看懂和一个的区别
* ?加命令：内省，会显示docstring但与help()的格式不同，且不会显示函数文档，只显示函数名；??两个问号：还会显示源代码
* ?加带有`*`的对象：显示匹配到的对象名；其实是psearch命令
* save：把指定的行保存到文件中、load把目标文件的内容输进终端且不自动执行、recall把上一次的输出放进输入中且不执行、reset -f清除所有定义了的变量、%%writefile将本单元格保存到文件中、paste粘贴并执行、rerun：重运行指定指定行的代码
* %%HTML、%%js、%%latex、%%markdown：将cell渲染成HTML输出；%%js运行JS
* autoreload 2：需要load_ext加载。import模块后修改源文件能自动变化

#### 配置

* ipython profile create [profilename]：创建`~/.ipython/profile_default/ipython_config.py`
* 在`profile_default/startup/`中的.py或.ipy会自动执行，命名可以`10-xxx.py`这样含有优先级
* config加不含c.的设置项可以动态读取和设置值
* 使用`import os; os.environ['comspec']='powershell.exe'`更改`!`的shell；或者创建自己的魔法命令，从`-c -`读取

```python
c.TerminalInteractiveShell.confirm_exit = False
c.TerminalInteractiveShell.editor = 'code -w'

# 未更改的设置
c.InteractiveShell.autocall = 0 # 启动自动括号，设为1时是智能模式，2是完全模式
c.InteractiveShell.logstart = False # 启用后会保存会话，下次就会恢复；但默认是overwrite模式？
c.InteractiveShell.pdb = False # 控制是否出现异常时自动进入ipdb，可用%pdb开关
c.InteractiveShellApp.exec_files/.exec_lines/.extensions = [] # IPython启动时要执行的文件/代码/IPython扩展（load_ext）
c.StoreMagics.autorestore = False # 开启后store能自动持久化
```

### pdb

* VSC调试用的并不是pdb，故先不学了
* python -m ipdb
* 输入单个问号能显示功能命令
* Debugging a broken unit test: pytest ... --pdbcls=IPython.terminal.debugger:TerminalPdb --pdb
* breakpoint()：进入pdb，是原版python就有的功能，相当于`pdb.set_trace()`？
* 命令教程：https://zhuanlan.zhihu.com/p/37218789 https://zhuanlan.zhihu.com/p/43846098
* 还有个pdb++(pdbpp)项目

### jupyter

* jupyter lab为新开发的UI，故先不学notebook了
* pip install jupyter; jupyter notebook --no-browser --allow-root
* 在反代之后需要配置`NotebookApp.allow_remote_access`或`c.NotebookApp.allow_origin`，否则会报`Blocking Cross Origin API request`或`Blocking request with non-local 'Host'`；`/api/kernels/`和`/terminals/`需要配websocket，各种配置中都设置了`Host`
* 会往`%AppData%\jupyter`里写东西，但在商店的Python里会装到沙盘里
* https://www.zhihu.com/search?type=content&q=jupyter https://www.zhihu.com/question/59392251
* Docker映像文档：https://jupyter-docker-stacks.readthedocs.io/
* 输出富文本：https://nbviewer.jupyter.org/github/ipython/ipython/blob/master/examples/IPython%20Kernel/Rich%20Output.ipynb

#### 配置

* jupyter notebook --generate-config 在 .jupyter/jupyter_notebook_config.py 下生成默认配置
* c.NotebookApp.notebook_dir：指定启动目录
* c.NotebookApp.open_browser = False
* c.NotebookApp.ip = '*'
* c.NotebookApp.port = 8888

### Conda

* conda是一款软件管理软件，相当于windows里面的应用商店。miniconda和anaconda中都包含了conda。miniconda只包含了conda、python、和一些必备的软件工具；anaconda包含了数据科学和机器学习要用到的很多软件
* pip只用来安装python的whl和源码，后者有时需要编译器，有的需要操作系统的包管理器安装依赖
* conda用来安装conda package二进制包，大部分是python的，但也支持了不少非python语言的依赖项如mkl、cuda这种c/c++写的包；有些包只能用conda，比如rdkit；但包的总数远少于PyPI
* conda自己可以用来创建虚拟环境，可以很轻松地管理多个版本的python
* conda比pip更加严格，conda会检查当前环境下所有包之间的依赖关系
* conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
* conda create -n venv python=3.8; conda info -e; conda activate venv; conda remove -n venv --all

## 参考

* https://www.liaoxuefeng.com/wiki/1016959663602400
* https://www.zhihu.com/question/268703765
* 《Python语言及其应用》
* https://www.zhihu.com/question/28966220
* https://stackoverflow.com/questions/16867347/step-by-step-debugging-with-ipython

### 未读

* 常用内建模块 https://www.liaoxuefeng.com/wiki/1016959663602400/1017642838127488
* 正则 https://www.liaoxuefeng.com/wiki/1016959663602400/1017639890281664
* sqlite https://www.liaoxuefeng.com/wiki/1016959663602400/1017801751919456
* datetime、random、Queue
* https://zhuanlan.zhihu.com/p/152343123 24招加速你的Python
* https://zhuanlan.zhihu.com/p/149210936 听说你会 Python？
* https://keelii.com/2018/09/24/socket-programming-in-python/
