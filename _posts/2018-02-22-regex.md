---
title: 正则表达式
---

## 方括号

* `[.\n]`并不能匹配任意字符，点在方括号里就只匹配点；其他的像*和{也不需要转义，但是`-`、`^`、`\`和`]`需要转义，空格和`[`为了清晰最好转义
* [^x]可以匹配到换行符，加上*可以联合前后跨行匹配
* ASCII码表中，算上空格，从32到126共95个可见字符
* [A-z]除了匹配所有大小写英文字符，还会匹配中间的几个字符：`` [\]^_` ``
* 匹配所有英文标点：`` [!-/:-@[-`{-~] ``，如果要匹配空格用\s，但PCRE好像不能用
* 匹配中文字符：`/[\u4e00-\u9fa5]/u`，PCRE好像不能用

## Lookaround

### [单词边界在与不在lookaround中](https://www.zhihu.com/question/53734029)

```
let reg = /\w+(?=sa\b)/;
reg.test('dddddsa') //true;
let reg_c = /\w+(?=sa)\b/;
reg_c.test('dddddsa') //false
```

因为`(?=xxx)`并不匹配任何字符，所以`\w+(?=sa)`只会匹配到`ddddd`。那么，如果`\b`在`(?=sa)`外部，它的意思是匹配`ddddd\b`。这样当然不能匹配成功。

### [使用正预测模拟反预测](https://www.zhihu.com/question/20154937/answer/189265675)

比如说你要找一个x，且这个x的前面是abc，可以这么写：`/(?=(abc))\1(x)/`。注意把x捕获到，这样才方便后续的处理。

### 捕获重复的部分的一半

捕获ababac中的abac：`(?<=(a.*)(?=a))\1ac`

## 与JS不同的地方

* \b在.NET中，中文对英文和数字不算边界，但是JS会对中文和他们算边界。比如用`\b123\b`匹配`啊123啊`，.NET匹配不到，JS可以；标点和换行都算

## 单行和多行

* 单行模式下，点可以匹配到换行符
* 多行模式下，^和$可以换行符为边界
* 单行模式和多行模式可以同时启用

## 例子

> http://www.jb51.net/tools/regex.htm

* IP地址：/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
* 中国大陆的身份证为15位或18位，邮政编码为6位数字
* 18位身份证号码(数字、字母x结尾)：^((\d{18})|([0-9x]{18})|([0-9X]{18}))$
* 手机号码？
* 连续两个空行时去除一个？
* 去除所有空行：^\s*[\n\r]+$
* 匹配参数，但保留引号中的空格：`[^\s"']+|"([^"]*)"|'([^']*)'`​，如果允许转义引号，则星号还要匹配（用|）`\"`和`\'`，但反斜杠仍存在并且要注意分组的情况

## 参考

* https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expression-language-quick-reference
