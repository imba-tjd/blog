---
title: 正则表达式
category: programming
---

## 字符转义

* `\w`会匹配下划线
* 如果没有raw字符串，`\d`要写成`"\\d"`
* 字面量小括号开闭都要转义，中括号和大括号可只转义开括号

## 字符组

* `[.\n]`不能匹配任意字符，中间的`.*?`、三种括号、空格、不紧跟着开头`[`的`^`、紧跟着开头`[`或`[^`的`-`都是字面量，但也可以转义，意义不变；中间的`\`和`]`需要转义
* 不在方括号字符组里的元字符不需要转义：`\[1-2]`匹配`[1-2]`
* `[\s\S]`或`[\w\W]`或`[^]`可以匹配任意字符，相当于开了单行模式的`.`；`[^x]`也可以匹配到换行符
* 匹配所有英文标点（不含空格）：``[!-/:-@[-`{-~]``，但PCRE不能用
* 匹配中文字符：`[\u4e00-\u9fa5]`
* 匹配成对的内容一般不要用`a.*a`而用`a[^a]*a`，除非内部又出现了嵌套的内容确实想贪婪匹配；前者会解析到底再回溯，懒惰模式不会回溯，但对于`a1a a2ab`若只想匹配后者，用`a.*?ab`会全部匹配，而字符组的就没问题
* 部分实现支持从字符组中减去一部分：java `[[a-z]&&[^aeiou]]`，c# `[a-z-[aeiou]]`

## 定位点

* \b在c#中，中文对英文和数字不算边界，但是js会对中文和他们算边界。比如用`\b123\b`匹配`啊123啊`，c#匹配不到，js可以；标点和换行都算

## 分支

* 当只有一个多选分支时不加括号也可以：`ab|cd`相当于`(ab|cd)`；优先级低，`^ab|cd$`相当于`(^ab|cd$)`而不是`^(ab)|(cd)$`；匹配字面量时注意转义
* 顺序会影响结果，优先处理前面的：`(abc|abcd)`在匹配abcd时只会匹配上abc
* 尽量避免多选分支中的重复匹配

## Lookaround

### [单词边界在与不在lookaround中](https://www.zhihu.com/question/53734029)

```
let reg = /\w+(?=sa\b)/;
reg.test('dddddsa') //true;
let reg_c = /\w+(?=sa)\b/;
reg_c.test('dddddsa') //false
```

因为`(?=xxx)`并不匹配任何字符，所以`\w+(?=sa)`只会匹配到`ddddd`。那么，如果`\b`在`(?=sa)`外部，它的意思是匹配`ddddd\b`。这样当然不能匹配成功。

## 分组

* 第0组是匹配到的字符串，之后按照开括号的顺序编号
* 某一分组多次匹配时只会保留最后匹配到的：`(\d){3}`只有一个数字，不同于`(\d{3})`
* 表达式中反向引用好像都是`\num`
* 替换中引用捕获组：py用`\num`，大多用`$`；py和js无法引用第0组但VSC可以
* 固化分组/原子组`(?>...)`、占有量词`[...]?+`(即在量词后加上+)：匹配完毕后即使后面匹配失败也不会回溯
* 命名：py用`(?P<name>)`
* 非捕获组：`?:`；注释：`?#`

### [使用正预测模拟反预测](https://www.zhihu.com/question/20154937/answer/189265675)

比如说你要找一个x，且这个x的前面是abc，可以这么写：`/(?=(abc))\1(x)/`。注意把x捕获到，这样才方便后续的处理。

### 捕获重复的部分的一半

捕获ababac中的abac：`(?<=(a.*)(?=a))\1ac`

## 单行和多行模式

* 单行模式下，点可以匹配到换行符
* 多行模式下，`^`可匹配换行符之后的位置，`$`可匹配换行符之前的位置，`\A`和`\Z`起到原来它俩的效果
* 其实普通模式下`$`匹配的就是最后一个换行符之前的位置，如果没有才匹配最后；JS除外，相当于`\z`
* 一些语言未实现的`\z`，如果整个字符串末尾是`\n`，`\z`匹配它后面，`\Z`匹配它前面；Py的`\Z`其实是`\z`
* 单行模式和多行模式可以同时启用
* 在表达式最前加`(?m)`即可启用模式

## VSC

* 替换时进行大小写转换：`\u\u\u$1`把前三个字符变为大写；`\l\U$1`把第一个变为小写，其余的变为大写
* `\s`、`[\s\S]`、`[^]`都不匹配`\n`，必须用`[\s\S\n]`才能匹配任意字符
* 默认启用多行模式

## PCRE

* 不支持Unicode转义

## 例子

* IP地址：/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
* 去除所有空行：^\s*[\n\r]+$
* 匹配参数，但保留引号中的空格：`[^\s"']+|"([^"]*)"|'([^']*)'`​，如果允许转义引号，则星号还要匹配（用|）`\"`和`\'`，但反斜杠仍存在并且要注意分组的情况
* https://ihateregex.io/ http://www.jb51.net/tools/regex.htm

## 测试

* https://regexr.com/

```
/pattern/.test('str') // 'str'.replace(/p/,repl)
import re; re.search(r'pattern','str')
using System.Text.RegularExpressions; Regex.Match("str",@"pattern")
'str' -match 'pattern'
```

## 参考

* https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expression-language-quick-reference
* 《正则指引》
