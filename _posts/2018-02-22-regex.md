---
title: 正则表达式
category: programming
---

## 字符转义

* `\w`会匹配下划线
* 如果没有raw字符串，`\d`要写成`"\\d"`

## 字符组

* `[.\n]`不能匹配任意字符，中间的`.*?`、三种括号、空格、不紧跟着开头`[`的`^`、紧跟着开头`[`或`[^`的`-`都是字面量，但也可以转义，意义不变；中间的`\`和`]`需要转义
* 不在方括号字符组里的元字符不需要转义：`\[1-2]`匹配`[1-2]`
* `[\s\S]`或`[\w\W]`或`[^]`可以匹配任意字符，相当于开了单行模式的`.`；`[^x]`也可以匹配到换行符
* 匹配所有英文标点（不含空格）：``[!-/:-@[-`{-~]``，但PCRE不能用
* 匹配中文字符：`[\u4e00-\u9fa5]`
* 匹配成对的内容一般不要用`a.*a`而用`a[^a]*a`，前者会匹配到顶再回溯，除非内部又出现了嵌套的内容确实想贪婪匹配；当然，懒惰模式在此处也不会回溯且效果类似
* 部分实现支持从字符组中减去一部分：java `[[a-z]&&[^aeiou]]`，c# `[a-z-[aeiou]]`

## 定位点

* \b在c#中，中文对英文和数字不算边界，但是js会对中文和他们算边界。比如用`\b123\b`匹配`啊123啊`，c#匹配不到，js可以；标点和换行都算

## 分支

* 当只有一个多选分支时不加括号也可以：`ab|cd`相当于`(ab|cd)`；优先级低，`^ab|cd$`相当于`(^ab|cd$)`而不是`^(ab)|(cd)$`
* 顺序会影响结果，优先处理前面的：`(abc|abcd)`在匹配abcd时只会匹配上abc
* 尽量避免多选分支中的重复匹配

## Lookaround

### [单词边界在与不在lookaround中](https://www.zhihu.com/question/53734029)

```
let reg = /\w+(?=sa\b)/;
reg.test('dddddsa') //true;
let reg_c = /\w+(?=sa)\b/;
reg_c.test('dddddsa') //false
```

因为`(?=xxx)`并不匹配任何字符，所以`\w+(?=sa)`只会匹配到`ddddd`。那么，如果`\b`在`(?=sa)`外部，它的意思是匹配`ddddd\b`。这样当然不能匹配成功。

## 分组

* 第0组是匹配到的字符串，之后按照开括号的顺序编号
* 某一分组多次匹配时只会保留最后匹配到的：`(\d){3}`只有一个数字，不同于`(\d{3})`
* 替换时引用捕获组：py用`\`，js和VSC和c#用`$`；py和js无法引用第0组但VSC可以
* 固化分组/原子组`(?>...)`、占有量词`[...]?+`(即在量词后加上+)：匹配完毕后即使后面匹配失败也不会回溯

### [使用正预测模拟反预测](https://www.zhihu.com/question/20154937/answer/189265675)

比如说你要找一个x，且这个x的前面是abc，可以这么写：`/(?=(abc))\1(x)/`。注意把x捕获到，这样才方便后续的处理。

### 捕获重复的部分的一半

捕获ababac中的abac：`(?<=(a.*)(?=a))\1ac`

## 单行和多行模式

* 单行模式下，点可以匹配到换行符
* 多行模式下，^和$可以以换行符为边界；`\A`和`\Z`起到原来它俩的效果
* 单行模式和多行模式可以同时启用

## VSC

* 替换时进行大小写转换：`\u\u\u$1`把前三个字符变为大写；`\l\U$1`把第一个变为小写，其余的变为大写
* `\s`、`[\s\S]`、`[^]`都不匹配`\n`，必须用`[\s\S\n]`才能匹配任意字符

## PCRE

* 不支持Unicode转义

## 例子

* IP地址：/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
* 去除所有空行：^\s*[\n\r]+$
* 匹配参数，但保留引号中的空格：`[^\s"']+|"([^"]*)"|'([^']*)'`​，如果允许转义引号，则星号还要匹配（用|）`\"`和`\'`，但反斜杠仍存在并且要注意分组的情况
* https://ihateregex.io/ http://www.jb51.net/tools/regex.htm

## 测试

* https://regexr.com/

```
/pattern/.test('str') // 'str'.replace(/p/,repl)
import re; re.match(r'pattern','str')
using System.Text.RegularExpressions; Regex.Match("str",@"pattern")
'str' -match 'pattern'
```

## 参考

* https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expression-language-quick-reference
* 《正则指引》
