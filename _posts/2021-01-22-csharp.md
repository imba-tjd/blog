---
title: C#笔记
---

## 杂项语法

* 0bxxx为二进制数字字面量；所有数字都可用下划线分隔提高可读性
* extern alias：当引用了两个相同的完全限定名称的库时使用，极少见就不记录了；`global::`全局命名空间，防止nsA.类B与类A.类B混淆，一般出现在自动生成的代码中
* 集合初始化器实质上是调用实现了IEnumerable的Add()的合适重载；字典初始化可用`[]=xxx`

## 类型

### 字符串

* 引用类型，不可变对象，修改时会创建一个新的
* string.Join静态方法
* ToLowerInvariant：不考虑语言差异，处理功能性字符串时使用；ToLower用于文本内容
* IndexOf, LastIndexOf, IndexOfAny
* Trim, TrimStart：不是删除字符串，而是删到第一个不在参数列表里的字符打止，`"three in Python".Trim(" Python".ToCharArray())`会得到`ree i`
* PadLeft：用空格或指定字符填充字符串
* 在反射中只能使用String
* 字符串+其它类型，会自动转换；可用`""`作为起始
* TODO: 转义字符串，如把`"\n"`变成`"\\n"`。Regex.Unescape()可以解转义，但不能用Escape()进行转义，因为它会把正则的元字符都转义掉，如点

### var隐式类型

* 只能用于局部变量
* 在声明时必须被初始化，不能初始化为null、方法组、匿名函数
* 普通内置类型最好不要用
* 小心连续使用，改前面的类型可能连续影响后面的推断
* 返回IQueryable时可用，避免变成IEnumerable

### 结构体（与类的区别）

* 不能对字段或自动属性静态初始化，除非是static或const成员
* 可以有静态构造函数，没有析构函数
* 构造函数必须为结构体中的所有字段赋值
* 一直存在隐式构造函数，也不能显式定义无参构造函数
* 不能继承结构体或者类，但可以实现接口；类可以继承类但不能继承结构体，也可以实现接口
* 总是隐式密封的，不能用protected、internal、abstract、virtual、sealed修饰结构体；结构体的成员不默认public，与类一样
* 预定义简单类型都实现为结构体
* 是值类型，可以直接s1=s2赋值且之后修改s1不影响s2；默认不能用==比较，可用Equals，会比较每个成员的值，但会装箱
* 创建结构体可以不使用new，作为类的成员则会自动调用无参构造函数，若是局部变量则成员无初始值且有以下限制：
  * 显式设置某个数据成员后才能使用它的值
  * 对所有数据成员赋值后，才能调用任何函数成员，包括private成员，否则报错结构体对象未赋值
  * 属性的行为类似函数：如果有set访问器又没全部初始化，给它赋值也算使用了函数，就会失败；同理自定义构造函数时要显式调用this()

### 接口

* 成员默认且强制public，不用也不能加访问修饰符
* 实现时不用也不能用override
* 自动属性：接口中只声明{get;}，子类可以实现成{get; set;}
* 设计时考虑是否可用泛型函数加委托替代
* C#8之前只能有非静态方法、属性、事件。现在可以有默认实现、可静态可private方法（必须实现）、静态可private变量，但这些只能且必须通过接口名使用
* 显式接口实现（接口名.方法名）不允许指定访问级别（其实是private），只有强转成那个接口才能使用对应的方法。可用于隐藏非泛型方法，内部as转换后调用泛型方法
* 当父类显式实现某接口后，子类无法用base.方法名调用，但可把子类自己转换成接口然后调用方法；但如果子类也继承了那个接口，调用时就会调用自己的方法，从而递归爆栈；此时正确做法是父类实现一个虚方法，子类重写
* 可以继承

### 抽象类

* 无法被实例化，所以不能用sealed否则就没用了。同理virtual和abstract成员不能是private的，至少是protected
* abstract成员只能在抽象类中声明，且必须没有默认实现；但抽象类可包含普通成员
* 只有四种类型可以声明为抽象的：方法、属性、事件、索引
* 子类必须实现所有抽象成员，否则就也是抽象类
* 抽象自动属性不能用`=>`，那相当于有实现了，可以有{get;}或{get; set;}
* 其它可以没有实现的情况：extern、partial

### 委托

* 本质是一个类，自动继承System.Delegate，使用时要先声明委托类型`deletage D();`，再创建委托实例`D d = WriteLine;`
* 与普通的函数指针不同的是可以引用实例方法和静态方法，使用Method属性可与对象脱离变成反射的MethodInfo，再用CreateDelegate可附加对象变成委托
* 委托都是多播的，直接使用只会获得调用列表中最后一个方法的返回值，且发生异常时不会继续执行，可用GetInvocationList()手动循环调用；如果存在ref参数，新值会传给下一个方法
* 委托是不可变类型
* C#10：`var/Delegate/object f = 1.ToString/(int x)=>x`，之前必须赋给Func；lambda表达式支持显式指定返回值。TODO: 能是delegate吗？支持泛型函数吗？

### 事件

* 是委托的封装，关系类似于属性和字段，不是委托实例
* 声明事件时，可以不用分号而用大括号，自己实现add和remove访问器，对应+=和-=，极少见就不记录了；默认实现利用的就是多播委托
* 只能在声明它的类中调用，不能是局部变量，不能作为返回值
* 在类外不能被`=`赋值，因为这样会影响其它订阅者
* 在类外能直接+=，类内和委托都不行，因为一开始的时候是null
* `event D e = delegate {};`这样初始化在类内就不用担心为null的问题了，或者也可用e?.Invoke()
* +=线程安全

### 可空类型

TODO

### 闭包

* 闭包是一段可以在晚些时候（延迟）执行的代码块，这段代码块维护着它被创建时环境（执行上下文）
* 匿名函数在被定义的时候可以使用(捕获)外部变量，当定义匿名函数的作用域结束时，如果匿名函数还存在引用，则捕获的变量不会消失，称作捕获变量的延长生存期，实际上创造了一个实例容纳捕获的变量
* 每执行到一次局部变量的声明时，称该局部变量被“实例化”。如果在for循环大括号中声明变量再闭包，捕获到的是不同的变量；如果是for循环开头小括号定义的，则是同一个变量，使用时都是出循环时i的值；foreach的单个元素，C#5之后会复制一份，相当于不同变量
* 匿名函数无法赋值给var，object和dynamic也不行
* 匿名函数里的this指的不是内部的类，仍是普通的定义匿名函数的类
* 本地函数、lambda表达式，与匿名函数类似。本地函数加static可强制不允许闭包捕获

### 枚举

* `enum MyEnum: uint`等可设定别的整数类型
* 可以设定对应的值，且会自动顺延；但当值不存在0时，它的default(T)仍是0且不会报错，因此最好始终从0开始，赋了不存在的值也不会报错
* Flags特性的唯一用处是枚举实例.ToString()时为友好信息而不是数字值，不能检测重复值。使用时要手动赋值0x0 0x1 0x2 0x4 0x8 0x10，之后可用与或运算
* 由string转换为枚举：`MyEnum a = (MyEnum)Enum.Parse(typeof(MyEnum), string);`
* 获取枚举内容：`string[] enums = Enum.GetNames(typeof(MyEnum));`

### ValueTuple元组

* var tup = (1, 2, 3)。用隐式名称访问第一项：tup.Item1
* 命名元组：局部变量用冒号(Sum: 123)，返回值用(int Sum)。没必要研究显式命名成Item1或ToString的行为
* 当使用变量等创建又没有显式命名时，会自动使用最后一部分的名称
* 两个元组元素数量类型相同时可以赋值和相等比较，与名称无关
* 类似于匿名类型，但是是值类型
* 一般用于返回多个值或代替out参数
* 解构，一次创建多个局部变量：(int a, int b) = (1, 2)，或var (a, b) = (1, 2)。不想要的内容用下划线弃元丢掉。解构自定义类需实现`public void Deconstruct(out ...)`，只有数量和类型都匹配时才会使用；可以是扩展方法

### 匿名类型

* 如果属性的名称、类型、数量、顺序都相同，则认为是同一类型
* 属性是只读的，所以只要属性是不易变的，匿名类型就是不易变的（VB里易变）
* 如果不指定名称，会使用表达式的最后一个部分（如果有）作为名称，比如person.Name中的Name，这叫做投影初始化
* var person = new {Name = "Tom", Age = 25}; var personcollection = new[] {new {Name = xx, Age = xx}, new {Name, Age};}

### 数组

```c#
int arr[] = {1, 2}; var arr2 = new int[] {}
IList<int> = arr; IReadOnlyList<int> = arr // 隐式转换。注意只是包裹，修改会反映在数组上，且Add抛运行时异常
Array.Empty<int>() // 替代零长数组new
Array.CreateInstance(Type, length)

Array.IndexOf()、LastIndexOf() // 未找到返回-1。FindIndex()根据Predicate委托自定义查找返回索引，Find()返回元素，FindAll()返回元素数组
Array.Resize(ref arr, 5) // 更改数组大小
Array.Reverse()
Array.Copy(srcarr, destarr, length)
Array.ConvertAll(arr, func) // 非原地
arr.GetLenth(int dimension) // 获取指定维度上元素的个数
arr.Clone() // (浅)复制数组元素，但返回object
无意义的：Array.AsReadOnly()、ForEach(arr, action)类似List的，不能修改内容，只能WriteLine、ConvertAll(arr, func)非原地

System.Buffer类：用于操作基元数组如int[]，无法操作对象数组和string[]
Buffer.ByteLength(arr) // 数组长度乘以元素大小
Buffer.GetByte(new[]{256, 255}, 1) // 1。虽然这个数组只有2个元素，但有8个字节，其中0索引的字节是0，第1索引是1，可以看出是小端序，4索引全是1即255；SetByte略
Buffer.BlockCopy：按块复制，能保持字节序，实例把short[]复制到long[]中。一般的复制速度不如Array.Copy
```

### object

* 存在一个protected的MemberwiseClone方法，效果是浅clone，即复制类非静态成员的引用和静态成员的二进制copy
* 不是所有的“东西”都继承自object类：接口（只能继承自接口）、指针、开放类型

### 异常

* finally中不能有return
* 7.0后throw变为表达式，可以使用null ?? throw new Exception()
* 作为库的作者，可以在可能失败的地方提供Exists或Try...这样的API
* 避免catch中再引发新的异常，比如记录日志的时候出现IO异常。同理还有Dispose和析构器、异常的when、多播委托和事件处理程序（异常会直接中断，后续不会调用）
* 继续上抛用`throw`而不是`throw e`，后者是重新引发异常，导致调用栈丢失
* 异常的强保证：如果某操作抛出异常，那么应用程序的状态必须和执行该操作之前相同。即要么不做，要么做完。对于值类型，可以先把数据copy一份，操作完了再替换。引用类型可能被别的地方引用了，不能直接替换引用；对于List可Clear()后再重新添加，也可用信封信纸模式，相当于二级引用
* 异常筛选器：catch后的when
  * catch本身只能判断类型，用when可以进行其他因素的判断，避免了捕获后判断再抛出的过程。例如http错误码，HResult
  * 合理利用when的副作用：因为是顺序判断的，可以写一个永远返回false的函数，里面只做log，添加到所有catch之前；或者可以改变输出文字的颜色，向控制台输出信息
  * 用!System.Diagnostics.Debugger.IsAttached指定只在非在debug时catch
* 没有一种区分“设计上不能捕获的异常”的类型，常见的预定义异常都继承自SystemException，用户自定义的不应继承它而已。catch自动无法捕获StackOverflowException

## 杂项关键字

### params参数数组

* 只能在参数列表的最后
* 调用时不用加关键字
* 调用时不传参，收到的是一个长度零的空数组，不用担心为null
* 传值类型会复制一份到堆上
* 可以传已有的数组

### const常量

* 无法接受变量的赋值，必须在定义时初始化，即使变量是readonly也不可以
* 默认为静态的，不允许显式使用static关键字来声明
* const对象没有自己的存储位置，而是在编译时被编译器替换。另一个程序集使用了本程序集中的const变量，但后来本程序集修改且重新编译了，不会改变另一个程序集中的值；利用这一特性可以把版本信息设为const

### nameof

* 是不完全限定名称：nameof(System.Collections.Generic) == "Generic"; nameof(obj) == "obj"; nameof(obj.ToString) == "ToString"; `nameof(List<int>) == "List"`

### sizeof

* 在非unsafe块下，只能用于几个基元类型编译期求值。在unsafe下可对Struct求值
* Core提供了`System.Runtime.CompilerServices.Unsafe.SizeOf<T>()`达到不开unsafe也能用的效果。但只适用于指定类型，仍然无法计算某一对象的占用大小
* 结果不同于Marshal.SizeOf，它求的是非托管类型的大小，且它作用于对象。而sizeof(long)是8

## 类

* 函数内联：`using System.Runtime.CompilerServices; [MethodImpl(MethodImplOptions.AggressiveInlining)]`

### 构造函数

* 能给readonly变量赋值
* 可用this()复用，该处参数不能使用实例字段或方法因为类还没构造完
* 构造函数可以有可选参数，但全部参数都可选的构造函数却不符合new()约束
* 不要调用虚函数，会发生奇怪的现象，且和C++行为不同
* 默认会隐式调用父类的默认构造函数，如果没有就必须手动用base(...)调用

### 直接初始化

* 优先直接初始化，除非不同构造函数用了不同方式来初始化字段
* 无需把对象初始化为0或null
* 成员字段直接初始化时无法引用其它成员字段；静态字段可以引用其它静态字段，但结果依赖声明顺序，且引用了的对象在后面才声明时就看作默认值，而const不会这样
* 自动属性{get;}和{get; set;}后都可以跟=进行初始化，且如果body为new也只会执行一次。而`=>`相当于函数，每次调用都会new

### 静态构造函数

* 不能使用任何访问修饰符，不能有参数
* 只能初始化静态字段
* 不能直接调用静态构造函数
* 只会执行一次
* 不要在里面抛异常，至少不要跑到外面，否则这个类永远无法正常初始化

### 重写(override)

* 继承时，父类的同名方法和数据都被隐藏了，用base可以调用到；非同名的能直接用this穿透访问和修改
* 父类方法用virtual关键字，必须有实现，子类及其子类都用override
* 当子类重写了父类的虚方法时，通过父类的引用调用方法，使用的是子类对象的方法和数据，否则使用的是父类的
* 不能重写static方法
* 必须有相同的名字、参数和返回值
* new修饰符：原本类里有一个函数，后来非自己控制的父类出现了同名函数，两个函数其实是无关的。转换为父类时，这样的同名函数可能会有完全不同的作用。一般改名比较好

### 扩展方法

* 必须在非嵌套、非泛型、静态类中定义
* 调用：s.func()等价于Class.func(s)。即把s的引用传给静态类中的方法
* 如果s是null，s.func()并不会抛出NullReferenceException；如果方法内没有访问它的成员，甚至直接不会抛出异常（比如string.IsNullOrEmpty）。自己定义的时候需要注意检查参数，抛ArgumentNullException
* 主要用于添加封闭泛型类的行为，目标不用做改变，否则一般继承即可；子类无法重写，这种需求要用默认接口方法
* 也可以用internal

```c#
// 这两种可以把扩展方法应用到所有实例
public static string ObjToStr(this object obj);
public static string ObjToStr<T>(this T obj);
```

### 泛型

* 可执行文件中只会出现构造了类型的泛型
* 每个封闭(具体)泛型类型都是一个不一样的类型，所以它们都有属于它自己的静态字段
* 实现泛型接口时，必须保证类型实参组合不会在类型中产生两个重复的接口，比如不能同时有int和T，因为T有可能是int
* 泛型类的内部具体类可以继承开放式构造类型：`class A<T>{} class B<T>{ class C:A<T>{} }`
* 对应的非泛型接口一般用于老代码，如果要实现，可以考虑显式实现接口，这样不会误调用
* 泛型约束
  * where T: xxx, xxx where K xxx
  * 主约束最多只能有一个且放在最前
    * ClassName：表示转换类型约束，直接或间接继承该类，不能是结构体或密封类
    * class关键字：表示引用类型，有此约束后可用==比较引用，即使该类型重写了==运算符也只比较引用
    * struct：表示值类型
  * 任意多的接口名约束：InterfaceName
  * 无参公共构造函数约束，若有则必须放在最后：new()；但实际一般用工厂方法或Func替代
* 运行期为了效率可进行一些特殊处理，如is IList/ICollection；string可以随机访问但没有继承IList，也需要单独处理
* 与template的区别：当不加IEquatable约束时，泛型只能用object.Equals，而模板就能选到重写了的。两个泛型变量不能相加减，因为不清楚那种泛型类型是否实现了+，但模板能确定
* 反射和泛型
  * IL中`1表示有一个泛型参数，方括号内的是类型
  * typeof能作用于非封闭类型，此时尖括号内不写类型，若有多个泛型参数仍留逗号
  * Type对象封闭化用MakeGenericType，泛型方法用MakeGenericMethod，之后IsGenericType仍为True，IsGenericTypeDefinition就变为False了，但此时ContainsGenericParameters仍可能为True，因为传给MakeGenericType的可能是开放类型，就不研究怎么再把它封闭了

#### 泛型方法

* 不依赖于泛型类，如果确实在泛型类中，类型参数与泛型类无关，一般选用另一个标识符来区分
* 如果确实在泛型类中，即使为静态的，也必须先具体化那个类，这点与Java不同
* 如果不需要把类型参数所表示的对象设为实例字段，则应优先考虑用泛型方法，而不是泛型类
* 一个泛型方法一般无需再创建针对父类或接口的重载版本。如果创建了，只有在刚好完全匹配时才会选择；如果参数需要转换，则会选择泛型方法而不会选择父类重载
* 方法不存在继承的概念，因此本身不存在逆变协变

#### 逆变协变

* 一般只在类外使用，如作为函数参数或变量。类内的方法能普通的自动转换
* 泛型类是不变/抗变的，只有接口和委托是可变的；值类型、ref参数、dynamic作为类型参数时不支持变体，不能`IE<int> as IE<object>`；接口继承仍要指明变体，否则就是不变
* 协变用IEnumerable/只读集合和返回值来理解，感觉和类差不多，很自然
* 逆变用IComparable来理解：父类实现了，子类实例可以直接CompareTo另一个子类，如果是不变的，参数就必须手动转成父类引用。其实也可以用只写集合理解，但C#库无此概念
* 逆变委托Action的理解：`Action<string> a = (object x)=>{}`把一个接受object的函数赋给接受string的委托，调用时`a("123")`只能传入string，实际的handler能处理object，自然能处理string，实际还是子类转换到父类。用Action时一般站在调用方思考，且一般函数本身是封闭的，导致难理解，其实应该看内部
* 协变不能用作接口方法的泛型约束，逆变可以：`void f<T>() where T : K`，其中K是类的`<in R>`
* 无论是否封闭，协变类型只能放在定义的函数的返回值中，逆变类型只能放在参数中；看起来就是协变集合变量及其内部不能set(T v)，逆变不能get。协变集合变量本身还是可以作为普通函数的参数
* 内嵌的逆变会反转之前的可变性，而协变不会如此
  * `Func<Func<T>>`：协变
  * `Action<Action<T>>`：协变，`void f(Action<string> a) => a("123"); Action<Action<object>> b = f;`，调用b要传能处理object的函数，当然能处理string
  * `Action<Func<T>>`：逆变，`void f(Func<object> a) { object o = a(); } Action<Func<string>> b = f;`，理解与上条一样
  * `Func<Action<T>>`：逆变，`Action<object> f() => (object o) => { }; Func<Action<string>> b = f;`，b()获得接受string的函数，实际handler能处理object
  * 这几项f都不能用lambda表达式，因为临时函数没必要那样做，精确匹配就行了
  * 用接口表示：`interface I1<out T> {Func<T> f1(); void f2(Action<T> a);} interface I2<in T> {void f1(Func<T> f); Action<T> f2();}`
* 引用类型数组支持协变，但这是缺陷：`object[] arr = new string[1]; arr[0] = 1;`编译期不报错，运行期报。因为arr只是对原数组的引用，往里面放其它类型，原数组再取出来的时候就会出问题。IReadOnlyList和IEnumerable支持协变

## 异步

### async/await

* 接口的函数声明不需要async修饰，只要返回Task即可
* 参数不能为out或ref参数
* 不能在lock语句块中使用
* 构造函数不能标记为async，一定要在里面调用异步函数最好只用返回void的
* 不存在async void Main，VS无法正常识别async Task Main
* IO绑定用await和普通的异步函数，不要使用并行库，不会开新线程
* CPU绑定使用await Task.Run(()=>Fun())，需要长时间运行时用TaskFactory.StartNew的一个重载
* 最好不要与LINQ结合，因为LINQ会延迟执行，可能会阻塞；可用ToList去掉lazy特性
* 不要在一个表达式中直接多次await，如`r=await F1()*await F2()`，这样无法并行，因为C#规定先对左边求值再对右边求值
* 如果需要对参数进行验证，需要编写一个同步的方法验证参数，再return调用异步方法（可以用匿名函数），这样可以非lazy处理

### Task

* 如果函数有async修饰，不管有没有await，return T就会自动包装，也无法`return Task<T>变量`
* 返回非泛型Task可以await但没有值；返回void无法await，一般用于事件
* 没有async修饰也可返回Task，return Task.FromResult/Fromxxx/CompletedTask或调用返回值为Task的函数即可。这样本身会同步执行，在函数内不能await，异常会往上走。用于把同步方法封装成异步方法，或验证参数
* Task的状态：t.Status、t.IsFault、IsCompleted(包括成功、取消和失败)、IsCompletedSuccessfully
* 同步等待/在同步方法中调用异步方法（在UI线程上会死锁）：t.Result、t.Wait()、t.GetAwaiter().GetResult()、t.WaitAll()、t.WaitAny()、Thread.Sleep()；其中GetAwaiter()不会抛AggregateException而已
* 异步等待：await、Task.WhenAll()、Task.WhenAny()、Task.Delay()、Task.Yield()离开当前的消息队列，回到队列末尾、t.WaitAsync(timeout).NET6新增
* 不要调用t.Dispose()，4.5后做了大更改
* ContinueWith：一般不用，因为有async，除非想在不改Task的函数内容后再执行代码。OnlyOnRanToCompletion枚举可以使得只有前一个方法成功完成后才执行后续操作
* Task.Run的两种特殊重载：看起来返回值不是自己，而是参数里的Task

  ```c#
  Task t = Task.Run(() => Task.Run(() => Console.WriteLine(3))); // Task Task.Run(Func<Task> fun);
  int value = await Task.Run(() => Task.Run(() => 4)); // Task<TResult> Task.Run(Func<Task<TResult>> fun);
  ```

### 异常处理

* 如果在Task中catch住了exception，则Task没有被取消**且**没有未处理的异常，所以Task的Status为RanToCompletion；没有未处理的异常，所以IsFaulted为False
* Task在后台运行时出现异常，不会直接抛出来，但此时Status为Faulted，IsFaulted为True
* 出现异常后，使用t.Wait()、t.Result、t.Exception会获得具有InnerExceptions的AggregateException；使用GetAwaiter().GetResult()、await会获得第一个内部异常，如果有多个，后面的就丢掉了
* 任务取消时，如果它只有一个线程，Status会变为Canceled，await会抛出TaskCanceledException；如果有多个线程，Status会变为Faulted，await会抛出AggregateException
* async void方法抛的异常永远也不会捕获到
* WhenAny：任意一个子任务完成、失败或取消时即返回，且此函数本身返回的Task会为完成，即await此函数总是不会抛出异常；可以很容易地做到完成一个任务后取消其他的任务，或循环处理一部分完成了的`List<Task>`
* WhenAll：当参数是`Task<TResult>[]`时，此方法的返回值是`Task<TResult[]>`；如果出现异常，await它只会抛出未包裹的第一个异常

### ValueTask

* 简单来说，当拿到Task对象后就直接await它，就适合用ValueTask。适合函数很可能直接同步完成（hot path）时使用
* 如果不能直接await，应用AsTask转换为普通的Task，此方法只能用一次，且之后就不要再与之前那个VT交互了
* 需要nuget包：System.Threading.Tasks.Extensions
* 是struct类型的Task，不在堆上分配
* Task可以多次await，可以并发消费，可以保存到List里，可以用Whenxxx。而ValueTask不行
* 在完成之前不能用GetAwaiter()
* 一种方式是函数不用写async，return时new ValueTask(result/Task.FromException)；或者像普通那样只把Task改成ValueTask，别的都不动。其实都和Task一样
* `Task<bool>`没必要用VT，因为会自动缓存这俩结果对象
* 推荐在分析过用它会有性能改善的时候才用
* 支持ConfigureAwait(false)

### SynchronizationContext

* GUI应用运行的时候有默认的SynchronizationContext（同步上下文）。在异步操作结束的时候， 后续步骤的回调被交给该上下文，以让窗口处理完当前所有消息后执行该回调。这样你会看到异步操作前后都是在该窗口所在的（主）线程上。与STAThread无关，这个东西只和COM有关，完全没用
* Console和ASP.NET Core没有默认的SC。异步操作结束后回调被交给默认的TaskScheduler处理，而默认的TS就是调用线程池，于是前后都是在不同的线程上
* 可以在类里面保存一下SynchronizationContext.Current，之后用Send和Post在UI线程上执行代码，区别是前者是同步的，会阻塞子线程，但会立即执行，而后者只是把回调加到消息循环里，且不会阻塞子线程。async内部就是这样做的
* WPF可用Application.Current.Dispatcher.Invoke/InvokeAsync在UI线程上执行代码，实际继承了SC
* 如果不需要修改UI，可用`await t.ConfigureAwait(false)`，这样异步方法结束后不返回原来的上下文，后面的代码会另开一个线程运行，能提高性能。但一般来说每一层都要用，写库的时候用。无SC时效果与false相同。对于`GetAwaiter().GetResult()`，在前面用它不会产生任何影响

### 死锁与异步转同步

* 在UI线程中用了t.Wait()或t.Result会死锁，因为在另一个线程的异步方法要到回到UI线程，但UI线程阻塞了无法处理消息

  ```c#
  // 最简单的死锁代码，Task.Run会创建线程
  async Task f() {await Task.Run(()=>{});}
  f().Wait();

  // 以下代码，WPF点击按钮后，文本不会改变，按钮不会禁用，直接无响应。Winform处理前两条语句然后无响应
  void btnDoStuff_Click() {
      btnDoStuff.IsEnabled = false;
      lblStatus.Content = "Doing Stuff";
      Thread.Sleep(4000); // 同步等待的方式
      lblStatus.Content = "Not Doing Anything";
      btnDoStuff.IsEnabled = true;
  }
  ```

* 读写文件，访问网络等IO阻塞操作不会产生死锁，因为没有产生线程：`hc.GetStringAsync().Result`，但不能依赖因为可能实现有BUG
* 一种解决方式是直接在UI中Task.Run：`Task.Run(()=>xxxAsync()).Result`
* 一种解决方式是异步函数中`await t.ConfigureAwait(false)`，则同步调用者什么也不用做t.Result不会死锁，但必须整个异步调用链都用
* 还一种方式是用TaskCompletionSource：`var tcs=new TaskCompletionSource<int>(); Task.Run(async()=>{int r = await 异步方法; tcs.SetResult(r)}); return tcs.Task.Result`

### 同步转异步

* 只要函数return Task即可，函数本身可以没有async修饰
* Task.FromResult
* Task.Run
* 类实现GetAwaiter()
* 委托的BeginInvoke加上TaskFactory.FromAsync

### CancellationToken

* 包含一个任务是否应该被取消的信息
* 拥有CancellationToken对象的任务需要主动定期检查其token状态，如果token.IsCancellationRequested为true，任务需停止其操作：进行清理然后用token.ThrowIfCancellationRequested()或Task.FromCancellation(token)；直接返回会把任务设置为RunToComplete
* 如果任务取消，Task对象的Status将会为Canceled而不是Faulted，await/Wait或获取Result时会抛出异常：
  * 如果有多个ContinueWith的后续任务，会都取消
  * 已经完成或出现其他异常的任务，进行取消不会变成Canceled；在任务开始前（状态为Created）进行取消能成功
  * 在任务开始（Started）后但未分配时间片时进行取消，此时无需委托检查仍会抛出TaskCanceledException
  * 对已取消的任务调用Start会抛InvalidOperationException
* CancelAfter可以指定超时时间

```c#
CancellationTokenSource cts = new();
CancellationToken token = cts.Token;
void f() { ...; token.ThrowIfCancellationRequested(); ...}
Task.Run(()=>{...;token.ThrowIfCancellationRequested()}, token)
// 另一种方式：token.Register(action)
cts.Cancel(); // 设置其创建的token的IsCancellationRequested为True
```

### Parallel

* 返回值不是用来获取实际结果的，只有一个IsCompleted能用，使用时必须要闭包局部变量
* 出现异常时抛AggregateException

```c#
Parallel.For(0, arr.Length, ndx => { Interlocked.Add(ref sum, arr[ndx]); });
Parallel.For(from, to, () => 0【线程局部变量初始化】, (i, loopstate, subtotal) => arr[i]+subtotoal【在一个线程中进行一定范围的计算，返回值作为下一次的subtotal】, x => Interlocked...【最终访问共享资源】);
Parallel.ForEach(arr, item => Interlocked.Add(ref sum, item));
Parallel.Invoke( // 并发调用多个函数
    () => WriteLine(),
    () => WriteLine()
)
Parallel.ForEachAsync(arr, async (item, cts) => ...); // 其它的方法都无法await等待完成，简直反人类。此为.NET6新增的
```

## 多线程

* Thread th = new(oFbj=>WriteLine(oFbj)); th.Start("123"); th.Join();
* ThreadPool.QueueUserWorkItem(action, para);
* Abort()废弃了

## 析构函数和Dispose方法

### using语句

* 凡是继承了IDisposable接口的类，都可以使用using语句。在超出作用域后会自动调用Dispose方法
* using语句可保证一定会调用Dispose方法，即使发生异常。因为其实就相当于try finally
* 如果不清楚某个对象是否实现了IDisposable，可以用as，using(null)是没有问题的，不会产生效果也不会报错；但如果有两个using就不要这样用了，第二个构造函数抛异常时第一个不会Dispose
* 一次用多个using，可以只在最后一个加大括号，前面的直接叠起来；或者用C#8的using语法

### 析构函数

* 析构函数既没有修饰符，也没有参数
* 一个类只能有一个析构函数
* 不能在结构中定义析构函数，只能对类使用析构函数
* 无法继承或重载析构函数
* 无法显式调用析构函数，它们是被自动调用的
* 对于子类，析构函数的调用次序与他们对应的构造函数的调用次序刚好相反
* 不要在不需要的时候实现析构函数，会影响性能
* 析构函数不应该访问其他对象，因为无法认定这些对象是否已经被销毁
* 不能在析构函数中释放托管资源，因为析构函数是由垃圾回收器调用的，可能在析构函数调用之前，类包含的托管资源已经被回收了
* 析构函数在编译后自动变成Finalize方法，避免自己定义同名方法
* 唯一的用处：在类的使用者没有调用Dispose的时候，由GC释放非托管资源，算是保险

### 标准dispose模式

* 如果需要主动释放资源，应实现IDisposable接口，在代码中调用Dispose方法；应实现virtual的Dispose(bool)重载，以便子类重写和调用
* 析构函数只释放非托管资源，Dispose方法释放托管和非托管资源。标准模式下由析构函数调用`Dispose(false)`即可
* 如果子类有自己的资源要释放，就重写虚方法，否则不用重写；先清理自己，之后调用父类的同名函数
* 重复调用Dispose是没有问题的，此方法在首次调用后应该什么也不做
* 如果没有显式调用Dispose方法，垃圾回收器也可以通过析构函数（来调用Dispose）来释放非托管资源；垃圾回收器本身又具有回收托管资源的功能，所以能保证资源的正常释放。只不过这样会导致非托管资源释放不及时
* 资源释放后，再引用实例方法会引发ObjectDisposedException
* 如果只在类的内部使用实现了Dispose方法的对象，则不用实现析构函数，只在释放托管资源的部分调用对应对象的Dispose就行，如sql连接
* 应只进行清理工作，不要把this又添加到别的地方去，否则会“复活”
* C#8引入了IAsyncDisposable，实现时调用`await DisposeAsyncCore();`和`Dispose(false);`，在前者中继续异步Dispose具体的对象且用`ConfigureAwait(false)`，调用者用await using
* 按照我的理解，正确实现了IDisposable的类就变成托管对象了
* 语义上，Dispose后就不能再使用对象了。如果是close，也许还可以设计成能重新open

```c#
using System;
class BaseClass : IDisposable {
    // Flag: Has Dispose already been called?
    bool disposed = false;

    // Public implementation of Dispose pattern callable by consumers.
    public void Dispose() {
        Dispose(true);
        GC.SuppressFinalize(this); // 阻止调用析构函数；GC.ReRegisterForFinalize可恢复析构请求，GC.WaitForPendingFinalizers
    }

    // Protected implementation of Dispose pattern.
    protected virtual void Dispose(bool disposing) {
        if (disposed)
            return;

        if (disposing) {
            // 释放由该类自己创建的的托管对象，调用?.Dispose()，用于及时释放内存
        }

        // 释放非托管对象
        CloseHandle(handle); // 需PInvoke，见代码段末尾
        handle = IntPtr.Zero;

        // 把占用大量内存或使用短缺资源的托管对象设为null，如MemoryStream，这使得它们更容易变得不可达

        disposed = true;
    }

    ~BaseClass() => Dispose(false); // 只释放非托管资源
}

class DerivedClass : BaseClass { // 子类不应主动实现IDisposable接口
    bool disposed = false;

    protected override void Dispose(bool disposing) {
        if (disposed)
            return;

        if (disposing) {
            // ...
        }

        // ...

        disposed = true;

        // Call the base class implementation.
        base.Dispose(disposing);
    }

    ~DerivedClass() { Dispose(false); }
}

[System.Runtime.InteropServices.DllImport("Kernel32")]
private extern static Boolean CloseHandle(IntPtr handle);
```

### 常见的非托管资源

这些类已经实现了析构函数和Dispose方法，我们在自己的类中使用时只要实现Dispose即可，不需要实现析构函数

* ApplicationContext、Component、ComponentDesigner、Tooltip、Container、Cursor
* FileStream、文件句柄、Socket
* Font、Icon、Image、Brush、Pen
* Matrix
* Timer
* GDI资源
* 数据库连接、DataReader

### 避免频繁创建相同的对象

* 避免循环内使用using，可以改成readonly成员变量，再在类里实现Dispose
* static 成员惰性求值：Brush类。属性先检查后备字段是否为null，如果是则new，否则返回之前创建好的。这样如果没有用到就不会创建
* 对于不可变类型，可以创建builder类

## 反射

* obj.GetType()、typeof(MyClass)、Type.GetType("System.Object")。这些都无法直接作用于方法
* tp.GetTypeInfo()是Type的子类，较新，一些UWP的API会用到。用AsType()能转回去；本来Core1中Type只留了一些属性，TypeInfo才有方法，但2中又加回来了
* tp.Name/FullName、GetField()返回指定名字的字段、GetFields()返回所有公共字段/GetProperties()
* 获取函数：typeof(int).GetMethod("Parse", new[]{typeof(string)})，因为有重载，只靠名字无法唯一确定；调用函数：m.Invoke(obj/null, null/...)，无法调用非封闭类型泛型函数
* GetMembers()获取所有成员包括属性方法字段事件等。GetMember()仍返回数组，则可以只指定函数名字。使用要tp.InvokeMember()指定一些BindingFlags，很麻烦
* BindingFlags默认是Instance|Static|Public，但没有提供引用它的方式，要获取私有成员除了指定NonPublic还必须再写是否是实例的。IgnoreCase忽略大小写
* typeinfo.DeclaredFields：仅由当前类定义了的字段

### 特性Attributes

* 以Attribute结尾，且使用时可不加整个后缀
* 默认应用于跟随其后的对象，但用于返回值(return)时必须使用完整格式：`[<目标>: <特性列表>]`
* 使用多个特性：`[xxx]\n[xxx]`或`[xxx, xxx]`
* tp.GetCustomAttributes()、tp.IsDefined()
* 自定义特性：创建继承System.Attribute的类，一般为sealed，构造函数定义一些可选参数，不要实现公共方法，可以有属性，对自己使用AttributeUsage来指定适用目标
* 预定义特性
  * Obsolete：`[Obsolete("Message")]; [Obsolete("Message"), true]`，第二种报编译期错误
  * Conditional：`[Conditional("DEBUG")]`，如果没有Define那个符号，就忽略对方法的调用，代码仍存在程序集中
  * CallerMemberName、CallerFilePath：用于函数参数
  * System.Diagnostics.DebuggerStepThrough：调试器在执行目标代码时不会进入内部调试
  * 友元程序集：`[assembly:InternalVisibleTo("...")]`

### dynamic和DLR(System.Dynamic)

* 属于Archived的技术，不要深入学
* 在CLR级别，dynamic就是应用了DynamicAttribute的object
* 对重载决策有影响
* 不能直接把委托和lambda表达式赋给dynamic，但可强制转换后赋。构造函数无法返回动态类型的对象，但是可以用工厂方法。不能用于实现泛型接口的类型参数(`IEnumerable<dynamic>`)，但可以是`List<dynamic>`
* 泛型相加函数：`T AddChecked<T>(T left, T right) => Dynamic.OpAddChecked(left, right);`
* ExpandoObject：可以直接对不存在的属性赋值，可以转换成IDict用索引器取出，反过来也可以`dynamic eo = new ExpandoObject(); eo.Name="Tom"; IDictionary<string, object> idict = eo; WriteLine(idict["Name"]);`
* DynamicObject需要继承使用，构造函数私有，有工厂方法；重写Try..系列方法后能实现动态行为，一部分在C#中没有等价操作如移除属性

## Console

* Read()
  * 返回字符的ASCII码（int）
  * 没有可读的字符（Ctrl+Z）返回-1
* ReadKey()
  * 返回ConsoleKeyInfo结构的实例
  * 不受缓冲区影响
* ConsoleKeyInfo结构
  * KeyChar属性：获得按键所表示的Unicode字符
  * Key属性：返回一个ConsoleKey枚举
  * Modifiers属性：返回一个ConsoleModifiers枚举(Flags)，表示用户是否按下了Contro、Alt或者Shift键
* Environment.GetCommandLineArgs()
  * 返回一个string数组，包含了传递给程序的命令行参数
  * 与Main方法的args参数不同，此方法返回的数组的第一个元素储存了当前可执行文件的路径
  * 当编写的代码不在Main方法中时，使用此方法
* 设置控制台的外观
  * BackgroundColor属性：用Clear方法可以把它变成控制台的背景色
  * BufferWidth和BufferHeight属性：大于窗口区域大小时，窗口会出现滚动条

## 预处理指令

* #define identifier、#undef identifier
* #if、#elif、#else、#endif
* #region name、#endregion
* #warning message、#error message
* #pragma warning disable、#pragma warning restore
* #line 数字：改变由编译器警告和错误消息报告的出现行数
* #line "filename"：改变被编译源文件的文件名，双引号是必须的
* #line default：重新保存实际的行号和文件名
* #line hidden：对交互调试器的断点调试功能隐藏代码段。大多用于在ASP.NET和WPF中隐藏编译器生成的代码
* #line：停止在调试器中隐藏代码

## System.Diagnostics的杂项类

* Trace实际上是logging。现在有Microsoft.Extensions.Logging了，第三方有NLog，故不深入学。EventLog仅限Win，System.Diagnostics.Tracing命名空间是底层API
* 必须定义/d:TRACE或DEBUG=True才能生效，VS的模板默认DEBUG模式下定义了DEBUG，两种模式下都定义了TRACE
* Trace.Listeners是一个静态列表，与Debug类共享，成员是DefaultTraceListener，程序运行后会自动产生一个，但默认行为并不是输出到终端而是什么都不做，设定LogFileName后才能写入文件；不要用TraceListener这个类，它是抽象的
* Trace.WriteLine/TraceError/Warning/Information()、Debug.Print()、AutoFlash=True
* Debug.Assert/Fail不是一般意义上的断言，不会导致程序结束，会产生超丑的WinForm样式提示框，可直接点ignore或abort，设定DefaultTraceListener.AssertUiEnabled=false后可关闭但也没啥意义
* Debugger.Break()相当于调试模式下在此处加断点
* System.Diagnostics.Contracts.Contract.Assert()能提供稍微漂亮一些的错误窗口，仍需定义DEBUG

## 参考

* 《Learning Hard C#》
* 《Illustrated C# 2012 (4th Edition)》
* 《C# in Depth》
* 《C# 7.0 in a Nutshell》
* https://docs.microsoft.com
* https://devblogs.microsoft.com/dotnet
