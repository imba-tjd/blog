---
title: C#笔记
---

## 杂项语法

* 0bxxx为二进制数字字面量；所有数字都可用下划线分隔提高可读性
* extern alias：当引用了两个相同的完全限定名称的库时使用，极少见就不记录了；`global::`全局命名空间，防止nsA.类B与类A.类B混淆，一般出现在自动生成的代码中
* 集合初始化器实质上是调用实现了IEnumerable的Add()的合适重载；字典初始化可用`[]=xxx`

## 类型

### 字符串

* 引用类型，不可变对象，修改时会创建一个新的
* string.Join静态方法
* ToLowerInvariant：不考虑语言差异，处理功能性字符串时使用；ToLower用于文本内容
* IndexOf, LastIndexOf, IndexOfAny
* Trim, TrimStart：不是删除字符串，而是删到第一个不在参数列表里的字符打止，`"three in Python".Trim(" Python".ToCharArray())`会得到`ree i`
* PadLeft：用空格或指定字符填充字符串
* 在反射中只能使用String
* 字符串+其它类型，会自动转换；可用`""`作为起始

### var隐式类型

* 只能用于局部变量
* 在声明时必须被初始化，不能初始化为null、方法组、匿名函数
* 普通内置类型最好不要用
* 小心连续使用，改前面的类型可能连续影响后面的推断
* 返回IQueryable时可用，避免变成IEnumerable

### 结构体（与类的区别）

* 不能对字段或自动属性静态初始化，除非是static或const成员
* 可以有静态构造函数，没有析构函数
* 构造函数必须为结构体中的所有字段赋值
* 一直存在隐式构造函数，也不能显式定义无参构造函数
* 不能继承结构体或者类，但可以实现接口；类可以继承类但不能继承结构体，也可以实现接口
* 总是隐式密封的，不能用protected、internal、abstract、virtual、sealed修饰结构体；结构体的成员不默认public，与类一样
* 预定义简单类型都实现为结构体
* 是值类型，可以直接s1=s2赋值且之后修改s1不影响s2；默认不能用==比较，可用Equals，会比较每个成员的值，但会装箱
* 创建结构体可以不使用new，作为类的成员则会自动调用无参构造函数，若是局部变量则成员无初始值且有以下限制：
  * 显式设置某个数据成员后才能使用它的值
  * 对所有数据成员赋值后，才能调用任何函数成员，包括private成员，否则报错结构体对象未赋值
  * 属性的行为类似函数：如果有set访问器又没全部初始化，给它赋值也算使用了函数，就会失败；同理自定义构造函数时要显式调用this()

### 接口

* 成员默认且强制public，不用也不能加访问修饰符
* 实现时不用也不能用override
* 自动属性：接口中只声明{get;}，子类可以实现成{get; set;}
* 设计时考虑是否可用泛型函数加委托替代
* C#8之前只能有非静态方法、属性、事件。现在可以有默认实现、可静态可private方法（必须实现）、静态可private变量，但这些只能且必须通过接口名使用
* 显式接口实现（接口名.方法名）不允许指定访问级别（其实是private），只有强转成那个接口才能使用对应的方法。可用于隐藏非泛型方法，内部as转换后调用泛型方法
* 当父类显式实现某接口后，子类无法用base.方法名调用，但可把子类自己转换成接口然后调用方法；但如果子类也继承了那个接口，调用时就会调用自己的方法，从而递归爆栈；此时正确做法是父类实现一个虚方法，子类重写
* 可以继承

### 抽象类

* 无法被实例化，所以不能用sealed否则就没用了。同理virtual和abstract成员不能是private的，至少是protected
* abstract成员只能在抽象类中声明，且必须没有默认实现；但抽象类可包含普通成员
* 只有四种类型可以声明为抽象的：方法、属性、事件、索引
* 子类必须实现所有抽象成员，否则就也是抽象类
* 抽象自动属性不能用`=>`，那相当于有实现了，可以有{get;}或{get; set;}
* 其它可以没有实现的情况：extern、partial

### 委托

* 本质是一个类，自动继承System.Delegate，使用时要先声明委托类型，再创建委托实例
* 与普通的函数指针不同的是可以引用实例方法和静态方法，使用Method属性可与对象脱离变成反射的MethodInfo，再用CreateDelegate可附加对象变成委托
* lambda表达式不支持委托参数的逆变和协变：`Action<object> a = (int i) => { };`报错
* 委托都是多播的，直接使用只会获得调用列表中最后一个方法的返回值，且发生异常时不会继续执行，可用GetInvocationList()手动循环调用；如果存在ref参数，新值会传给下一个方法
* C#10：`var/Delegate/object f = 1.ToString/(int x)=>x`，lambda表达式支持显式指定返回值

### 事件

* 是委托的封装，关系类似于属性和字段，不是委托实例
* 声明事件时，可以不用分号而用大括号，自己实现add和remove访问器，对应+=和-=，极少见就不记录了；默认实现利用的就是多播委托
* 只能在声明它的类中调用，不能是局部变量，不能作为返回值
* 在类外不能被`=`赋值，因为这样会影响其它订阅者
* 在类外能直接`+=`，类内和委托都不行，因为一开始的时候是null
* `event D e = delegate {};`这样初始化在类内就不用担心为null的问题了，或者也可用e?.Invoke()

### 可空类型

TODO

### 闭包

* 闭包是一段可以在晚些时候（延迟）执行的代码块，这段代码块维护着它被创建时环境（执行上下文）
* 匿名函数在被定义的时候可以使用(捕获)外部变量，当定义匿名函数的作用域结束时，如果匿名函数还存在引用，则捕获的变量不会消失，称作捕获变量的延长生存期，实际上创造了一个实例容纳捕获的变量
* 每执行到一次局部变量的声明时，称该局部变量被“实例化”。如果在for循环大括号中声明变量再闭包，捕获到的是不同的变量；如果是for循环开头小括号定义的，则是同一个变量，使用时都是出循环时i的值；foreach的单个元素，C#5之后会复制一份，相当于不同变量
* 匿名函数无法赋值给var，object和dynamic也不行
* 匿名函数里的this指的不是内部的类，仍是普通的定义匿名函数的类
* 本地函数、lambda表达式，与匿名函数类似。本地函数加static可强制不允许闭包捕获

### 枚举

* `enum MyEnum: uint`等可设定别的整数类型
* 可以设定对应的值，且会自动顺延；但当值不存在0时，它的default(T)仍是0且不会报错，因此最好始终从0开始，赋了不存在的值也不会报错
* Flags特性的唯一用处是枚举实例.ToString()时为友好信息而不是数字值，不能检测重复值。使用时要手动赋值0x0 0x1 0x2 0x4 0x8 0x10，之后可用与或运算
* 由string转换为枚举：`MyEnum a = (MyEnum)Enum.Parse(typeof(MyEnum), string);`
* 获取枚举内容：`string[] enums = Enum.GetNames(typeof(MyEnum));`

### ValueTuple元组

* var tup = (1, 2, 3)。用隐式名称访问第一项：tup.Item1
* 命名元组：局部变量用冒号(Sum: 123)，返回值用(int Sum)。没必要研究显式命名成Item1或ToString的行为
* 当使用变量等创建又没有显式命名时，会自动使用最后一部分的名称
* 两个元组元素数量类型相同时可以赋值和相等比较，与名称无关
* 类似于匿名类型，但是是值类型
* 一般用于返回多个值或代替out参数
* 解构，一次创建多个局部变量：(int a, int b) = (1, 2)，或var (a, b) = (1, 2)。不想要的内容用下划线弃元丢掉。解构自定义类需实现`public void Deconstruct(out ...)`，只有数量和类型都匹配时才会使用；可以是扩展方法

### 匿名类型

* 如果属性的名称、类型、数量、顺序都相同，则认为是同一类型
* 属性是只读的，所以只要属性是不易变的，匿名类型就是不易变的（VB里易变）
* 如果不指定名称，会使用表达式的最后一个部分（如果有）作为名称，比如person.Name中的Name，这叫做投影初始化
* var person = new {Name = "Tom", Age = 25}; var personcollection = new[] {new {Name = xx, Age = xx}, new {Name, Age};}

## 杂项关键字

### 参数数组params

* 只能在参数列表的最后
* 调用时不用加关键字
* 调用时不传参，收到的是一个长度零的空数组，不用担心为null
* 传值类型会复制一份到堆上
* 可以传已有的数组

## 类

* 函数内联：`using System.Runtime.CompilerServices; [MethodImpl(MethodImplOptions.AggressiveInlining)]`

### 构造函数

* 能给readonly变量赋值
* 可用this()复用，该处参数不能使用实例字段或方法因为类还没构造完
* 构造函数可以有可选参数，但全部参数都可选的构造函数却不符合new()约束
* 不要调用虚函数，会发生奇怪的现象，且和C++行为不同
* 默认会隐式调用父类的默认构造函数，如果没有就必须手动用base(...)调用

### 直接初始化

* 优先直接初始化，除非不同构造函数用了不同方式来初始化字段
* 无需把对象初始化为0或null
* 成员字段直接初始化时无法引用其它成员字段；静态字段可以引用其它静态字段，但结果依赖声明顺序，且引用了的对象在后面才声明时就看作默认值，而const不会这样
* 自动属性{get;}和{get; set;}后都可以跟=进行初始化，且如果body为new也只会执行一次。而`=>`相当于函数，每次调用都会new

### 静态构造函数

* 不能使用任何访问修饰符，不能有参数
* 只能初始化静态字段
* 不能直接调用静态构造函数
* 只会执行一次
* 不要在里面抛异常，至少不要跑到外面，否则这个类永远无法正常初始化

### 重写(override)

* 继承时，父类的同名方法和数据都被隐藏了，用base可以调用到；非同名的能直接用this穿透访问和修改
* 父类方法用virtual关键字，必须有实现，子类及其子类都用override
* 当子类重写了父类的虚方法时，通过父类的引用调用方法，使用的是子类对象的方法和数据，否则使用的是父类的
* 不能重写static方法
* 必须有相同的名字、参数和返回值
* new修饰符：原本类里有一个函数，后来非自己控制的父类出现了同名函数，两个函数其实是无关的。转换为父类时，这样的同名函数可能会有完全不同的作用。一般改名比较好

### 扩展方法

* 必须在非嵌套、非泛型、静态类中定义
* 调用：s.func()等价于Class.func(s)。即把s的引用传给静态类中的方法
* 如果s是null，s.func()并不会抛出NullReferenceException；如果方法内没有访问它的成员，甚至直接不会抛出异常（比如string.IsNullOrEmpty）。自己定义的时候需要注意检查参数，抛ArgumentNullException
* 主要用于添加封闭泛型类的行为，否则一般继承即可
* 也可以用internal

```c#
// 这两种可以把扩展方法应用到所有实例
public static string ObjToStr(this object obj);
public static string ObjToStr<T>(this T obj);
```

### 泛型

* 可执行文件中只会出现构造了类型的泛型
* 每个封闭(具体)泛型类型都是一个不一样的类型，所以它们都有属于它自己的静态字段
* 实现泛型接口时，必须保证类型实参组合不会在类型中产生两个重复的接口，比如不能同时有int和T，因为T有可能是int
* 泛型类的内部具体类可以继承开放式构造类型：`class A<T>{} class B<T>{ class C:A<T>{} }`
* 对应的非泛型接口一般用于老代码，如果要实现，可以考虑显式实现接口，这样不会误调用
* 泛型约束
  * where T: xxx, xxx where K xxx
  * 主约束最多只能有一个且放在最前
    * ClassName：表示转换类型约束，直接或间接继承该类，不能是结构体或密封类
    * class关键字：表示引用类型，有此约束后可用==比较引用，即使该类型重写了==运算符也只比较引用
    * struct：表示值类型
  * 任意多的接口名约束：InterfaceName
  * 无参公共构造函数约束，若有则必须放在最后：new()；但实际一般用工厂方法或Func替代
* 运行期为了效率可进行一些特殊处理，如is IList/ICollection；string可以随机访问但没有继承IList，也需要单独处理
* 与template的区别：当不加IEquatable约束时，泛型只能用object.Equals，而模板就能选到重写了的
* 反射和泛型
  * IL中`1表示有一个泛型参数，方括号内的是类型
  * typeof能作用于非封闭类型，此时尖括号内不写类型
  * Type对象封闭化用MakeGenericType，泛型方法用MakeGenericMethod

#### 泛型方法

* 不依赖于泛型类，如果确实在泛型类中，类型参数与泛型类无关，一般选用另一个标识符来区分
* 如果确实在泛型类中，即使为静态的，也必须先具体化那个类，这点与Java不同
* 如果不需要把类型参数所表示的对象设为实例字段，则应优先考虑用泛型方法，而不是泛型类
* 一个泛型方法一般无需再创建针对父类或接口的重载版本。如果创建了，只有在刚好完全匹配时才会选择；如果参数需要转换，则会选择泛型方法而不会选择父类重载
* 方法不存在继承的概念，因此本身不存在逆变协变

#### 逆变协变

* 一般只在类外使用，如作为函数参数或变量。类内的方法能普通的自动转换
* 泛型类是不变/抗变的，只有接口和委托是可变的；值类型、ref参数、dynamic作为类型参数时不支持变体，不能`IE<int> as IE<object>`；接口继承仍要指明变体，否则就是不变
* 协变用IEnumerable/只读集合和返回值来理解，感觉和类差不多，很自然
* 逆变用IComparable来理解：父类实现了，子类实例可以直接CompareTo另一个子类，如果是不变的，参数就必须手动转成父类引用。其实也可以用只写集合理解，但C#库无此概念
* 逆变委托Action的理解：`Action<string> a = (object x)=>{}`把一个接受object的函数赋给接受string的委托，调用时`a("123")`只能传入string，实际的handler能处理object，自然能处理string，实际还是子类转换到父类。用Action时一般站在调用方思考，且一般函数本身是封闭的，导致难理解，其实应该看内部
* 协变不能用作接口方法的泛型约束，逆变可以：`void f<T>() where T : K`，其中K是类的`<in R>`
* 无论是否封闭，协变类型只能放在定义的函数的返回值中，逆变类型只能放在参数中；看起来就是协变集合变量及其内部不能set(T v)，逆变不能get。协变集合变量本身还是可以作为普通函数的参数
* 内嵌的逆变会反转之前的可变性，而协变不会如此
  * `Func<Func<T>>`：协变
  * `Action<Action<T>>`：协变，`void f(Action<string> a) => a("123"); Action<Action<object>> b = f;`，调用b要传能处理object的函数，当然能处理string
  * `Action<Func<T>>`：逆变，`void f(Func<object> a) { object o = a(); } Action<Func<string>> b = f;`，理解与上条一样
  * `Func<Action<T>>`：逆变，`Action<object> f() => (object o) => { }; Func<Action<string>> b = f;`，b()获得接受string的函数，实际handler能处理object
  * 这几项f都不能用lambda表达式，因为临时函数没必要那样做，精确匹配就行了
  * 用接口表示：`interface I1<out T> {Func<T> f1(); void f2(Action<T> a);} interface I2<in T> {void f1(Func<T> f); Action<T> f2();}`
* 引用类型数组支持协变，但这是缺陷：`object[] arr = new string[1]; arr[0] = 1;`编译期不报错，运行期报。因为arr只是对原数组的引用，往里面放其它类型，原数组再取出来的时候就会出问题。IReadOnlyList和IEnumerable支持协变

## 预处理指令

* #define identifier、#undef identifier
* #if、#elif、#else、#endif
* #region name、#endregion
* #warning message、#error message
* #pragma warning disable、#pragma warning restore
* #line 数字：改变由编译器警告和错误消息报告的出现行数
* #line "filename"：改变被编译源文件的文件名，双引号是必须的
* #line default：重新保存实际的行号和文件名
* #line hidden：对交互调试器的断点调试功能隐藏代码段。大多用于在ASP.NET和WPF中隐藏编译器生成的代码
* #line：停止在调试器中隐藏代码

## 参考

* 《Learning Hard C#》
* 《Illustrated C# 2012 (4th Edition)》
* 《C# in Depth》
* 《C# 7.0 in a Nutshell》
* https://docs.microsoft.com
