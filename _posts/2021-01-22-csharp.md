---
title: C#笔记
---

## 杂项语法

* 0bxxx为二进制数字字面量；所有数字都可用下划线分隔提高可读性
* extern alias：当引用了两个相同的完全限定名称的库时使用，极少见就不记录了；`global::`全局命名空间，防止nsA.类B与类A.类B混淆，一般出现在自动生成的代码中
* 集合初始化器实质上是调用实现了IEnumerable的Add()的合适重载；字典初始化可用`[]=xxx`

## 类型

### 字符串

* 引用类型，不可变对象，修改时会创建一个新的
* string.Join静态方法
* ToLowerInvariant：不考虑语言差异，处理功能性字符串时使用；ToLower用于文本内容
* IndexOf, LastIndexOf, IndexOfAny
* Trim, TrimStart：不是删除字符串，而是删到第一个不在参数列表里的字符打止，`"three in Python".Trim(" Python".ToCharArray())`会得到`ree i`
* PadLeft：用空格或指定字符填充字符串
* 在反射中只能使用String
* 字符串+其它类型，会自动转换；可用`""`作为起始

### var隐式类型

* 只能用于局部变量
* 在声明时必须被初始化，不能初始化为null、方法组、匿名函数
* 普通内置类型最好不要用
* 小心连续使用，改前面的类型可能连续影响后面的推断
* 返回IQueryable时可用，避免变成IEnumerable

### 结构体（与类的区别）

* 不能对字段或自动属性静态初始化，除非是static或const成员
* 可以有静态构造函数，没有析构函数
* 构造函数必须为结构体中的所有字段赋值
* 一直存在隐式构造函数，也不能显式定义无参构造函数
* 不能继承结构体或者类，但可以实现接口；类可以继承类但不能继承结构体，也可以实现接口
* 总是隐式密封的，不能用protected、internal、abstract、virtual、sealed修饰结构体；结构体的成员不默认public，与类一样
* 预定义简单类型都实现为结构体
* 是值类型，可以直接s1=s2赋值且之后修改s1不影响s2；默认不能用==比较，可用Equals，会比较每个成员的值，但会装箱
* 创建结构体可以不使用new，作为类的成员则会自动调用无参构造函数，若是局部变量则成员无初始值且有以下限制：
  * 显式设置某个数据成员后才能使用它的值
  * 对所有数据成员赋值后，才能调用任何函数成员，包括private成员，否则报错结构体对象未赋值
  * 属性的行为类似函数：如果有set访问器又没全部初始化，给它赋值也算使用了函数，就会失败；同理自定义构造函数时要显式调用this()

### 接口

* 成员默认且强制public，不用也不能加访问修饰符
* 实现时不用也不能用override
* 自动属性：接口中只声明{get;}，子类可以实现成{get; set;}
* 设计时考虑是否可用泛型函数加委托替代
* C#8之前只能有非静态方法、属性、事件。现在可以有默认实现、可静态可private方法（必须实现）、静态可private变量，但这些只能且必须通过接口名使用
* 显式接口实现（接口名.方法名）不允许指定访问级别（其实是private），只有强转成那个接口才能使用对应的方法。可用于隐藏非泛型方法，内部as转换后调用泛型方法
* 当父类显式实现某接口后，子类无法用base.方法名调用，但可把子类自己转换成接口然后调用方法；但如果子类也继承了那个接口，调用时就会调用自己的方法，从而递归爆栈；此时正确做法是父类实现一个虚方法，子类重写
* 可以继承

### 抽象类

* 无法被实例化，所以不能用sealed否则就没用了。同理virtual和abstract成员不能是private的，至少是protected
* abstract成员只能在抽象类中声明，且必须没有默认实现；但抽象类可包含普通成员
* 只有四种类型可以声明为抽象的：方法、属性、事件、索引
* 子类必须实现所有抽象成员，否则就也是抽象类
* 抽象自动属性不能用`=>`，那相当于有实现了，可以有{get;}或{get; set;}
* 其它可以没有实现的情况：extern、partial

### 委托

* 本质是一个类，自动继承System.Delegate，使用时要先声明委托类型`deletage D();`，再创建委托实例`D d = WriteLine;`
* 与普通的函数指针不同的是可以引用实例方法和静态方法，使用Method属性可与对象脱离变成反射的MethodInfo，再用CreateDelegate可附加对象变成委托
* 委托都是多播的，直接使用只会获得调用列表中最后一个方法的返回值，且发生异常时不会继续执行，可用GetInvocationList()手动循环调用；如果存在ref参数，新值会传给下一个方法
* 委托是不可变类型
* C#10：`var/Delegate/object f = 1.ToString/(int x)=>x`，lambda表达式支持显式指定返回值

### 事件

* 是委托的封装，关系类似于属性和字段，不是委托实例
* 声明事件时，可以不用分号而用大括号，自己实现add和remove访问器，对应+=和-=，极少见就不记录了；默认实现利用的就是多播委托
* 只能在声明它的类中调用，不能是局部变量，不能作为返回值
* 在类外不能被`=`赋值，因为这样会影响其它订阅者
* 在类外能直接+=，类内和委托都不行，因为一开始的时候是null
* `event D e = delegate {};`这样初始化在类内就不用担心为null的问题了，或者也可用e?.Invoke()
* +=线程安全

### 可空类型

TODO

### 闭包

* 闭包是一段可以在晚些时候（延迟）执行的代码块，这段代码块维护着它被创建时环境（执行上下文）
* 匿名函数在被定义的时候可以使用(捕获)外部变量，当定义匿名函数的作用域结束时，如果匿名函数还存在引用，则捕获的变量不会消失，称作捕获变量的延长生存期，实际上创造了一个实例容纳捕获的变量
* 每执行到一次局部变量的声明时，称该局部变量被“实例化”。如果在for循环大括号中声明变量再闭包，捕获到的是不同的变量；如果是for循环开头小括号定义的，则是同一个变量，使用时都是出循环时i的值；foreach的单个元素，C#5之后会复制一份，相当于不同变量
* 匿名函数无法赋值给var，object和dynamic也不行
* 匿名函数里的this指的不是内部的类，仍是普通的定义匿名函数的类
* 本地函数、lambda表达式，与匿名函数类似。本地函数加static可强制不允许闭包捕获

### 枚举

* `enum MyEnum: uint`等可设定别的整数类型
* 可以设定对应的值，且会自动顺延；但当值不存在0时，它的default(T)仍是0且不会报错，因此最好始终从0开始，赋了不存在的值也不会报错
* Flags特性的唯一用处是枚举实例.ToString()时为友好信息而不是数字值，不能检测重复值。使用时要手动赋值0x0 0x1 0x2 0x4 0x8 0x10，之后可用与或运算
* 由string转换为枚举：`MyEnum a = (MyEnum)Enum.Parse(typeof(MyEnum), string);`
* 获取枚举内容：`string[] enums = Enum.GetNames(typeof(MyEnum));`

### ValueTuple元组

* var tup = (1, 2, 3)。用隐式名称访问第一项：tup.Item1
* 命名元组：局部变量用冒号(Sum: 123)，返回值用(int Sum)。没必要研究显式命名成Item1或ToString的行为
* 当使用变量等创建又没有显式命名时，会自动使用最后一部分的名称
* 两个元组元素数量类型相同时可以赋值和相等比较，与名称无关
* 类似于匿名类型，但是是值类型
* 一般用于返回多个值或代替out参数
* 解构，一次创建多个局部变量：(int a, int b) = (1, 2)，或var (a, b) = (1, 2)。不想要的内容用下划线弃元丢掉。解构自定义类需实现`public void Deconstruct(out ...)`，只有数量和类型都匹配时才会使用；可以是扩展方法

### 匿名类型

* 如果属性的名称、类型、数量、顺序都相同，则认为是同一类型
* 属性是只读的，所以只要属性是不易变的，匿名类型就是不易变的（VB里易变）
* 如果不指定名称，会使用表达式的最后一个部分（如果有）作为名称，比如person.Name中的Name，这叫做投影初始化
* var person = new {Name = "Tom", Age = 25}; var personcollection = new[] {new {Name = xx, Age = xx}, new {Name, Age};}

## 杂项关键字

### 参数数组params

* 只能在参数列表的最后
* 调用时不用加关键字
* 调用时不传参，收到的是一个长度零的空数组，不用担心为null
* 传值类型会复制一份到堆上
* 可以传已有的数组

## 类

* 函数内联：`using System.Runtime.CompilerServices; [MethodImpl(MethodImplOptions.AggressiveInlining)]`

### 构造函数

* 能给readonly变量赋值
* 可用this()复用，该处参数不能使用实例字段或方法因为类还没构造完
* 构造函数可以有可选参数，但全部参数都可选的构造函数却不符合new()约束
* 不要调用虚函数，会发生奇怪的现象，且和C++行为不同
* 默认会隐式调用父类的默认构造函数，如果没有就必须手动用base(...)调用

### 直接初始化

* 优先直接初始化，除非不同构造函数用了不同方式来初始化字段
* 无需把对象初始化为0或null
* 成员字段直接初始化时无法引用其它成员字段；静态字段可以引用其它静态字段，但结果依赖声明顺序，且引用了的对象在后面才声明时就看作默认值，而const不会这样
* 自动属性{get;}和{get; set;}后都可以跟=进行初始化，且如果body为new也只会执行一次。而`=>`相当于函数，每次调用都会new

### 静态构造函数

* 不能使用任何访问修饰符，不能有参数
* 只能初始化静态字段
* 不能直接调用静态构造函数
* 只会执行一次
* 不要在里面抛异常，至少不要跑到外面，否则这个类永远无法正常初始化

### 重写(override)

* 继承时，父类的同名方法和数据都被隐藏了，用base可以调用到；非同名的能直接用this穿透访问和修改
* 父类方法用virtual关键字，必须有实现，子类及其子类都用override
* 当子类重写了父类的虚方法时，通过父类的引用调用方法，使用的是子类对象的方法和数据，否则使用的是父类的
* 不能重写static方法
* 必须有相同的名字、参数和返回值
* new修饰符：原本类里有一个函数，后来非自己控制的父类出现了同名函数，两个函数其实是无关的。转换为父类时，这样的同名函数可能会有完全不同的作用。一般改名比较好

### 扩展方法

* 必须在非嵌套、非泛型、静态类中定义
* 调用：s.func()等价于Class.func(s)。即把s的引用传给静态类中的方法
* 如果s是null，s.func()并不会抛出NullReferenceException；如果方法内没有访问它的成员，甚至直接不会抛出异常（比如string.IsNullOrEmpty）。自己定义的时候需要注意检查参数，抛ArgumentNullException
* 主要用于添加封闭泛型类的行为，目标不用做改变，否则一般继承即可；子类无法重写，这种需求要用默认接口方法
* 也可以用internal

```c#
// 这两种可以把扩展方法应用到所有实例
public static string ObjToStr(this object obj);
public static string ObjToStr<T>(this T obj);
```

### 泛型

* 可执行文件中只会出现构造了类型的泛型
* 每个封闭(具体)泛型类型都是一个不一样的类型，所以它们都有属于它自己的静态字段
* 实现泛型接口时，必须保证类型实参组合不会在类型中产生两个重复的接口，比如不能同时有int和T，因为T有可能是int
* 泛型类的内部具体类可以继承开放式构造类型：`class A<T>{} class B<T>{ class C:A<T>{} }`
* 对应的非泛型接口一般用于老代码，如果要实现，可以考虑显式实现接口，这样不会误调用
* 泛型约束
  * where T: xxx, xxx where K xxx
  * 主约束最多只能有一个且放在最前
    * ClassName：表示转换类型约束，直接或间接继承该类，不能是结构体或密封类
    * class关键字：表示引用类型，有此约束后可用==比较引用，即使该类型重写了==运算符也只比较引用
    * struct：表示值类型
  * 任意多的接口名约束：InterfaceName
  * 无参公共构造函数约束，若有则必须放在最后：new()；但实际一般用工厂方法或Func替代
* 运行期为了效率可进行一些特殊处理，如is IList/ICollection；string可以随机访问但没有继承IList，也需要单独处理
* 与template的区别：当不加IEquatable约束时，泛型只能用object.Equals，而模板就能选到重写了的
* 反射和泛型
  * IL中`1表示有一个泛型参数，方括号内的是类型
  * typeof能作用于非封闭类型，此时尖括号内不写类型
  * Type对象封闭化用MakeGenericType，泛型方法用MakeGenericMethod

#### 泛型方法

* 不依赖于泛型类，如果确实在泛型类中，类型参数与泛型类无关，一般选用另一个标识符来区分
* 如果确实在泛型类中，即使为静态的，也必须先具体化那个类，这点与Java不同
* 如果不需要把类型参数所表示的对象设为实例字段，则应优先考虑用泛型方法，而不是泛型类
* 一个泛型方法一般无需再创建针对父类或接口的重载版本。如果创建了，只有在刚好完全匹配时才会选择；如果参数需要转换，则会选择泛型方法而不会选择父类重载
* 方法不存在继承的概念，因此本身不存在逆变协变

#### 逆变协变

* 一般只在类外使用，如作为函数参数或变量。类内的方法能普通的自动转换
* 泛型类是不变/抗变的，只有接口和委托是可变的；值类型、ref参数、dynamic作为类型参数时不支持变体，不能`IE<int> as IE<object>`；接口继承仍要指明变体，否则就是不变
* 协变用IEnumerable/只读集合和返回值来理解，感觉和类差不多，很自然
* 逆变用IComparable来理解：父类实现了，子类实例可以直接CompareTo另一个子类，如果是不变的，参数就必须手动转成父类引用。其实也可以用只写集合理解，但C#库无此概念
* 逆变委托Action的理解：`Action<string> a = (object x)=>{}`把一个接受object的函数赋给接受string的委托，调用时`a("123")`只能传入string，实际的handler能处理object，自然能处理string，实际还是子类转换到父类。用Action时一般站在调用方思考，且一般函数本身是封闭的，导致难理解，其实应该看内部
* 协变不能用作接口方法的泛型约束，逆变可以：`void f<T>() where T : K`，其中K是类的`<in R>`
* 无论是否封闭，协变类型只能放在定义的函数的返回值中，逆变类型只能放在参数中；看起来就是协变集合变量及其内部不能set(T v)，逆变不能get。协变集合变量本身还是可以作为普通函数的参数
* 内嵌的逆变会反转之前的可变性，而协变不会如此
  * `Func<Func<T>>`：协变
  * `Action<Action<T>>`：协变，`void f(Action<string> a) => a("123"); Action<Action<object>> b = f;`，调用b要传能处理object的函数，当然能处理string
  * `Action<Func<T>>`：逆变，`void f(Func<object> a) { object o = a(); } Action<Func<string>> b = f;`，理解与上条一样
  * `Func<Action<T>>`：逆变，`Action<object> f() => (object o) => { }; Func<Action<string>> b = f;`，b()获得接受string的函数，实际handler能处理object
  * 这几项f都不能用lambda表达式，因为临时函数没必要那样做，精确匹配就行了
  * 用接口表示：`interface I1<out T> {Func<T> f1(); void f2(Action<T> a);} interface I2<in T> {void f1(Func<T> f); Action<T> f2();}`
* 引用类型数组支持协变，但这是缺陷：`object[] arr = new string[1]; arr[0] = 1;`编译期不报错，运行期报。因为arr只是对原数组的引用，往里面放其它类型，原数组再取出来的时候就会出问题。IReadOnlyList和IEnumerable支持协变

## 异步

### async/await

* 接口的函数声明不需要async修饰，只要返回Task即可
* 参数不能为out或ref参数
* 不能在lock语句块中使用
* 构造函数不能标记为async，一定要在里面调用异步函数最好只用返回void的
* 不存在async void Main，VS无法正常识别async Task Main
* IO绑定用await和普通的异步函数，不要使用并行库，不会开新线程
* CPU绑定使用await Task.Run(()=>Fun())，需要长时间运行时用TaskFactory.StartNew的一个重载
* 最好不要与LINQ结合，因为LINQ会延迟执行，可能会阻塞；可用ToList去掉lazy特性
* 不要在一个表达式中直接多次await，如`r=await F1()*await F2()`，这样无法并行，因为C#规定先对左边求值再对右边求值
* 如果需要对参数进行验证，需要编写一个同步的方法验证参数，再return调用异步方法（可以用匿名函数），这样可以非lazy处理

### Task

* 如果函数有async修饰，不管有没有await，return T就会自动包装，也无法`return Task<T>变量`
* 返回非泛型Task可以await但没有值；返回void无法await，一般用于事件
* 没有async修饰也可返回Task，return Task.FromResult/Fromxxx/CompletedTask或调用返回值为Task的函数即可。这样本身会同步执行，在函数内不能await，异常会往上走。用于把同步方法封装成异步方法，或验证参数
* Task的状态：t.Status、t.IsFault、IsCompleted(包括成功、取消和失败)、IsCompletedSuccessfully
* 同步等待/在同步方法中调用异步方法（在UI线程上会死锁）：t.Result、t.Wait()、t.GetAwaiter().GetResult()、t.WaitAll()、t.WaitAny()、Thread.Sleep()；其中GetAwaiter()不会抛AggregateException而已
* 异步等待：await、await Task.WhenAll()、await Task.WhenAny()、await Task.Delay()、await Task.Yield()离开当前的消息队列，回到队列末尾
* 不要调用t.Dispose()，4.5后做了大更改
* Task.Run的两种特殊重载：看起来返回值不是自己，而是参数里的Task

  ```c#
  Task t = Task.Run(() => Task.Run(() => Console.WriteLine(3))); // Task Task.Run(Func<Task> fun);
  int value = await Task.Run(() => Task.Run(() => 4)); // Task<TResult> Task.Run(Func<Task<TResult>> fun);
  ```

### 异常处理

* 如果在Task中catch住了exception，则Task没有被取消**且**没有未处理的异常，所以Task的Status为RanToCompletion；没有未处理的异常，所以IsFaulted为False
* Task在后台运行时出现异常，不会直接抛出来，但此时Status为Faulted，IsFaulted为True
* 出现异常后，使用t.Wait()、t.Result、t.Exception会获得具有InnerExceptions的AggregateException；使用GetAwaiter().GetResult()、await会获得第一个内部异常，如果有多个，后面的就丢掉了
* 任务取消时，如果它只有一个线程，Status会变为Canceled，await会抛出TaskCanceledException；如果有多个线程，Status会变为Faulted，await会抛出AggregateException
* async void方法抛的异常永远也不会捕获到
* WhenAny：任意一个子任务完成、失败或取消时即返回，且此函数本身返回的Task会为完成，即await此函数总是不会抛出异常；可以很容易地做到完成一个任务后取消其他的任务，或循环处理一部分完成了的`List<Task>`
* WhenAll：当参数是`Task<TResult>[]`时，此方法的返回值是`Task<TResult[]>`；如果出现异常，await它只会抛出未包裹的第一个异常

### ValueTask

* 简单来说，当拿到Task对象后就直接await它，就适合用ValueTask。适合函数很可能直接同步完成（hot path）时使用
* 如果不能直接await，应用AsTask转换为普通的Task，此方法只能用一次，且之后就不要再与之前那个VT交互了
* 需要nuget包：System.Threading.Tasks.Extensions
* 是struct类型的Task，不在堆上分配
* Task可以多次await，可以并发消费，可以保存到List里，可以用Whenxxx。而ValueTask不行
* 在完成之前不能用GetAwaiter()
* 一种方式是函数不用写async，return时new ValueTask(result/Task.FromException)；或者像普通那样只把Task改成ValueTask，别的都不动。其实都和Task一样
* `Task<bool>`没必要用VT，因为会自动缓存这俩结果对象
* 推荐在分析过用它会有性能改善的时候才用
* 支持ConfigureAwait(false)

### SynchronizationContext

* GUI应用运行的时候有默认的SynchronizationContext（同步上下文）。在异步操作结束的时候， 后续步骤的回调被交给该上下文，以让窗口处理完当前所有消息后执行该回调。这样你会看到异步操作前后都是在该窗口所在的（主）线程上。与STAThread无关，这个东西只和COM有关，完全没用
* Console和ASP.NET Core没有默认的SC。异步操作结束后回调被交给默认的TaskScheduler处理，而默认的TS就是调用线程池，于是前后都是在不同的线程上
* 可以在类里面保存一下SynchronizationContext.Current，之后用Send和Post在UI线程上执行代码，区别是前者是同步的，会阻塞子线程，但会立即执行，而后者只是把回调加到消息循环里，且不会阻塞子线程。async内部就是这样做的
* WPF可用Application.Current.Dispatcher.Invoke/InvokeAsync在UI线程上执行代码，实际继承了SC
* 如果不需要修改UI，可用`await t.ConfigureAwait(false)`，这样异步方法结束后不返回原来的上下文，后面的代码会另开一个线程运行，能提高性能。但一般来说每一层都要用，写库的时候用。无SC时效果与false相同。对于`GetAwaiter().GetResult()`，在前面用它不会产生任何影响

### 死锁与异步转同步

* 在UI线程中用了t.Wait()或t.Result会死锁，因为在另一个线程的异步方法要到回到UI线程，但UI线程阻塞了无法处理消息

  ```c#
  // 最简单的死锁代码，Task.Run会创建线程
  async Task f() {await Task.Run(()=>{});}
  f().Wait();

  // 以下代码，WPF点击按钮后，文本不会改变，按钮不会禁用，直接无响应。Winform处理前两条语句然后无响应
  void btnDoStuff_Click() {
      btnDoStuff.IsEnabled = false;
      lblStatus.Content = "Doing Stuff";
      Thread.Sleep(4000); // 同步等待的方式
      lblStatus.Content = "Not Doing Anything";
      btnDoStuff.IsEnabled = true;
  }
  ```

* 读写文件，访问网络等IO阻塞操作不会产生死锁，因为没有产生线程：`hc.GetStringAsync().Result`，但不能依赖因为可能实现有BUG
* 一种解决方式是直接在UI中Task.Run：`Task.Run(()=>xxxAsync()).Result`
* 一种解决方式是异步函数中`await t.ConfigureAwait(false)`，则同步调用者什么也不用做t.Result不会死锁，但必须整个异步调用链都用
* 还一种方式是用TaskCompletionSource

### 同步转异步

* 只要函数return Task即可，函数本身可以没有async修饰
* Task.FromResult
* Task.Run
* 类实现GetAwaiter()
* 委托的BeginInvoke加上TaskFactory.FromAsync

## 预处理指令

* #define identifier、#undef identifier
* #if、#elif、#else、#endif
* #region name、#endregion
* #warning message、#error message
* #pragma warning disable、#pragma warning restore
* #line 数字：改变由编译器警告和错误消息报告的出现行数
* #line "filename"：改变被编译源文件的文件名，双引号是必须的
* #line default：重新保存实际的行号和文件名
* #line hidden：对交互调试器的断点调试功能隐藏代码段。大多用于在ASP.NET和WPF中隐藏编译器生成的代码
* #line：停止在调试器中隐藏代码

## 参考

* 《Learning Hard C#》
* 《Illustrated C# 2012 (4th Edition)》
* 《C# in Depth》
* 《C# 7.0 in a Nutshell》
* https://docs.microsoft.com
