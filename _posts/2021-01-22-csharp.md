---
title: C#笔记
---

## 杂项语法

* 0bxxx为二进制数字字面量；所有数字都可用下划线分隔提高可读性
* extern alias：当引用了两个相同的完全限定名称的库时使用，极少见就不记录了；`global::`全局命名空间，防止nsA.类B与类A.类B混淆，一般出现在自动生成的代码中
* 集合初始化器实质上是调用实现了IEnumerable的Add()的合适重载；字典初始化可用`[]=xxx`

## 类型

### 字符串

* string.Join静态方法
* ToLowerInvariant：不考虑语言差异，处理功能性字符串时使用；ToLower用于文本内容
* IndexOf, LastIndexOf, IndexOfAny
* Trim, TrimStart：不是删除字符串，而是删到第一个不在参数列表里的字符打止，`"three in Python".Trim(" Python".ToCharArray())`会得到`ree i`
* PadLeft：使用空格或指定字符填充字符串
* 在反射中只能使用String

### var隐式类型

* 只能用于局部变量
* 在声明时必须被初始化，不能初始化为null、方法组、匿名函数
* 普通内置类型最好不要用
* 小心连续使用，改前面的类型可能连续影响后面的推断
* 返回IQueryable时可用，避免变成IEnumerable

### 结构体（与类的区别）

* 不能对字段或自动属性静态初始化，除非是static或const成员
* 可以有静态构造函数，没有析构函数
* 构造函数必须为结构体中的所有字段赋值
* 一直存在隐式构造函数，也不能显式定义无参构造函数
* 不能继承结构体或者类，但可以实现接口；类可以继承类但不能继承结构体，也可以实现接口
* 总是隐式密封的，不能用protected、internal、abstract、virtual、sealed修饰结构体；结构体的成员不默认public，与类一样
* 预定义简单类型在.NET中都实现为结构体
* 创建结构体可以不使用new，作为类的成员则会自动调用无参构造函数，若是局部变量则成员无初始值且有以下限制：
  * 显式设置某个数据成员后才能使用它的值
  * 对所有数据成员赋值后，才能调用任何函数成员，包括private成员，否则报错结构体对象未赋值
  * 属性的行为类似函数：如果有set访问器又没全部初始化，给它赋值也算使用了函数，就会失败；同理自定义构造函数时要显式调用this()

### 接口

* 成员默认且强制public，不用也不能加访问修饰符
* 实现时不用也不能用override
* 自动属性：接口中只声明{get;}，子类可以实现成{get; set;}
* 设计时考虑是否可用泛型函数加委托替代
* C#8之前只能有非静态方法、属性、事件。现在可以有默认实现、可静态可private方法（必须实现）、静态可private变量，但这些只能且必须通过接口名使用
* 显式接口实现（接口名.方法名）不允许指定访问级别（其实是private），只有强转成那个接口才能使用对应的方法。可用于隐藏非泛型方法，内部as转换后调用泛型方法
* 当父类显式实现某接口后，子类无法用base.方法名调用，但可把子类自己转换成接口然后调用方法；但如果子类也继承了那个接口，调用时就会调用自己的方法，从而递归爆栈；此时正确的方法是父类实现一个虚方法，子类覆写

### 抽象类

* 无法被实例化，所以不能用sealed否则就没用了。同理virtual和abstract成员不能是private的，至少是protected
* abstract成员只能在抽象类中声明，且必须没有默认实现；但抽象类可包含普通成员
* 只有四种类型可以声明为抽象的：方法、属性、事件、索引
* 子类必须实现所有抽象成员，否则就也是抽象类
* 抽象自动属性不能用`=>`，那相当于有实现了，可以有{get;}或{get; set;}

### 委托

* 本质是一个类，自动继承System.Delegate，使用时要先声明委托类型，再创建委托实例
* 与普通的函数指针不同的是可以引用实例方法和静态方法，使用Method属性可与对象脱离变成反射的MethodInfo，再用CreateDelegate可附加对象变成委托
* lambda表达式不支持委托参数的逆变和协变：`Action<object> a = (int i) => { };`报错
* 委托都是多播的，直接使用只会获得调用列表中最后一个方法的返回值，且发生异常时不会继续执行，可用GetInvocationList()手动循环调用；如果存在ref参数，新值会传给下一个方法

### 事件

* 是委托的封装，关系类似于属性和字段，不是委托实例
* 声明事件时，可以不用分号而用大括号，自己实现add和remove访问器，对应+=和-=，极少见就不记录了；默认实现利用的就是多播委托
* 只能在声明它的类中调用，不能是局部变量，不能作为返回值
* 在类外不能被`=`赋值，因为这样会影响其它订阅者
* 在类外能直接`+=`，类内和委托都不行，因为一开始的时候是null
* `event D e = delegate {};`这样初始化在类内就不用担心为null的问题了，或者也可用e?.Invoke()

### 可空类型

TODO

### 闭包

* 闭包是一段可以在晚些时候（延迟）执行的代码块，这段代码块维护着它被创建时环境（执行上下文）
* 匿名函数在被定义的时候可以使用(捕获)外部变量，当定义匿名函数的作用域结束时，如果匿名函数还存在引用，则捕获的变量不会消失，称作捕获变量的延长生存期，实际上创造了一个实例容纳捕获的变量
* 每执行到一次局部变量的声明时，称该局部变量被“实例化”。如果在for循环大括号中声明变量再闭包，捕获到的是不同的变量；如果是for循环开头小括号定义的，则是同一个变量，使用时都是出循环时i的值；foreach的单个元素，C#5之后会复制一份，相当于不同变量
* 匿名函数无法赋值给var，object和dynamic也不行
* 匿名函数里的this指的不是内部的类，仍是普通的定义匿名函数的类
* 本地函数、lambda表达式，与匿名函数类似

### 枚举

* `enum MyEnum: uint`等可设定别的整数类型
* 可以设定对应的值，且会自动顺延；但当值不存在0时，它的default(T)仍是0且不会报错，因此最好始终从0开始，赋了不存在的值也不会报错
* Flags特性的唯一用处是枚举实例.ToString()时为友好信息而不是数字值，不能检测重复值。使用时要手动赋值0x0 0x1 0x2 0x4 0x8 0x10，之后可用与或运算
* 由string转换为枚举：`MyEnum a = (MyEnum)Enum.Parse(typeof(MyEnum), string);`
* 获取枚举内容：`string[] enums = Enum.GetNames(typeof(MyEnum));`

## 类

### 构造函数

* 能给readonly变量赋值
* 可用this()复用，该处参数不能使用实例字段或方法因为类还没构造完
* 构造函数可以有可选参数，但全部参数都可选的构造函数却不符合new()约束
* 不要调用虚函数，会发生奇怪的现象，且和C++行为不同

### 直接初始化

* 优先直接初始化，除非不同构造函数用了不同方式来初始化字段
* 无需把对象初始化为0或null
* 成员字段直接初始化时无法引用其它成员字段；静态字段可以引用其它静态字段，但结果依赖声明顺序，且引用了的对象在后面才声明时就看作默认值，而const不会这样

### 静态构造函数

* 不能使用任何访问修饰符，不能有参数
* 只能初始化静态字段
* 不能直接调用静态构造函数
* 只会执行一次
* 不要在里面抛异常，至少不要跑到外面，否则这个类永远无法正常初始化

### 重写(override)

* 继承时，父类的同名方法和数据都被隐藏了，用base可以调用到；非同名的能直接用this穿透访问和修改
* 当子类重写了父类的虚方法时，通过父类的引用调用方法，使用的是子类对象的方法和数据，否则使用的是父类的
* 不能重写static方法
* 必须有相同的参数和返回值
* new修饰符：原本类里有一个函数，后来非自己控制的父类出现了同名函数，两个函数其实是无关的。转换为基类时，这样的同名函数可能会有完全不同的作用。一般改名比较好

### 扩展方法

* 必须在非嵌套、非泛型、静态类中定义
* 调用：s.func()等价于Class.func(s)。即把s的引用传给静态类中的方法
* 如果s是null，s.func()并不会抛出NullReferenceException；如果方法内没有访问它的成员，甚至直接不会抛出异常（比如string.IsNullOrEmpty）。自己定义的时候需要注意检查参数，抛ArgumentNullException
* 主要用于添加封闭泛型类的行为，否则一般继承即可

```c#
// 这两种可以把扩展方法应用到所有实例
public static string ObjToStr(this object obj);
public static string ObjToStr<T>(this T obj);
```

## 参考

* 《Learning Hard C#》
* 《Illustrated C# 2012 (4th Edition)》
* 《C# in Depth》
* 《C# 7.0 in a Nutshell》
* https://docs.microsoft.com
