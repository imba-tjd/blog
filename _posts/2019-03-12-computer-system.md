---
title: "《深入理解计算机系统》"
---

进程的虚拟地址空间：

![]({{%20site.baseurl%20}}/assets/v2-1bbda4e5bdc297b5d4a9e88fc0e43c14_hd.jpg)

* * * * *

文件是IO设备的抽象、虚拟内存是对程序储存器的抽象、进程是对一个正在运行的程序的抽象。

* * * * *

信息的表示和处理
----------------

原码：最高位为符号位，1为负数；反码：正数的反码等于原码，负数等于最高位为1，其余位按位取反；补码：正数的补码等于原码，负数等于反码+1

对于非负数x，-x的表示：补码(Two's complement)：2^w -x；反码(One's complement)：[1111...1] -x

数学上，补码其实只是最高位的权重为-2^(w-1)，所以把补码负数转换为**相同二进制**的无符号数只需要加2^w即可。

移码：补码最高位取反，或原码所有位按位取反，原码为负数就再+1。其实移码只是把10000000作为0，所以与补码相差2^(k-1)

对于整数来说，补码的乘法结果相当于把补码含符号位解释为无符号整数，用原码乘法后截断为正常长度，并解释为补码。如果不截断是不等的

### 浮点数

float是1位符号位，8位阶码位，23位尾数位；double是1+11+52；阶码第一位也为符号位

规格化：通过移位变成1.xxxx(2)乘2^n，其中尾数用原码表示定点小数并隐藏最高位的1，而阶码的二进制为n+2^(k-1)-1即移码-1，如2^1的阶码为10000000；float的阶码范围就是-126~127（移码全为1和0不能算，见下）

阶码全为1时：如果尾数全为0，表示无穷大，位数符号位仍表正负；如果尾数不为0，表示NAN，比如根号-1

所以最大的规格化数是`0 1110 111`这样的，最小的正规格化数是`0 0001 000`==2^-6。可准确表示的数越靠近原点越稠密。

阶码全为0时，是非规格化的值。但此时实际阶码值规定为1+1-2^(k-1)，k=8时就是-126。例如`0 0000 111`等于0.111(2)\*2^(-6) == 7/8/64 == 7/512 == -1/512+2^-6，即非规格化到规格化的平滑过渡

||
|描述|exp|frac|float(2)|float(10)|double(2)|double(10)|
|0|00...00|0...00|0|0.0|0|0.0|
|最小非规格|00...00|0...01|2^-23\*2^-126|1.4E-45|2^-52\*2^-1022|4.9E-324|
|最大非规格|00...00|1...11|(1-ε)\*2^-126|1.2E-38|(1-ε)\*2^-1022|2.2E-308|
|最小规格|00..01|0...00|1\*2^-126|1.2E-38|1\*2^-1022|2.2E-308|
|1|01...11|0...00|1\*2^0|1.0|1\*2^0|1.0|
|最大规格|11...10|1...11|(2-ε)\*2^127|3.4E38|(2-ε)\*2^1023|1.8E308|

#### 浮点数的计算

如果一个大数字加上一些很小的数字，小的有可能被截断导致根本没变化，因此需要先把小的加起来。但是仍然无法解决(1.0+1E10)-1E10这样的情况

尾数的舍入使用“向偶数舍入”：以十进制为例，1.4仍舍入到1，1.6仍舍入到2，但1.5和2.5都舍入到2；对于二进制，只有XXXX100...这样的处于中间，因此最后一个X是0，就舍，是1，就进位。

浮点的加法满足单调性：a\>b =\> a+c\>b+c，而整数可能溢出。

进程和线程
----------

* 线程是CPU调度的最小单位，进程是资源分配的最小单位
* 用户线程和内核线程有三种模型：一对一，多对一，多对多。一对一效率高，但切换线程时消耗大，数量也有限制

ELF
---

句柄可以理解为指针的指针；如果只是一层指针，比如malloc返回的，那对于托管堆来说就不能随意移动了；所以就是二重指针；作用可以理解为数据库的主键


