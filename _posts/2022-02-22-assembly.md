---
title: 汇编
---

* gcc -S默认是AT&T风格，Intel风格加-masm=intel，加-fverbose-asm可生成与源代码对应的注释

## 数据格式

```
C类型      Intel类型   AT&T后缀   大小(字节)
char       字节BYTE       b        1
short      字WORD         w        2
int        双字DWORD      l        4
long       四字QWORD      q        8
float      单精度         s        4
double     双精度         l        8
void*      32位下4字节，64位下8字节，当作整数
```

## 寄存器

* 运算int（包括返回值）用exx
* 运算指针用?bp和?sp，64位是rxx，32位是exx
* 指令寄存器：rip/eip
* AT&T风格需在前面加%
* x64传递参数依次用：?di ?si ?dx ?cx r8? r9?。其中赋值要明确位数，但取值可能直接按rxx取

```
63    31    15    7      作用
rax   eax   ax    al     存放(函数的)返回值，因为最后ret指令是无参的，无返回值时也能当作临时变量的通用寄存器。本意是accumulator
rbx   ...   ...   ...    基址寄存器，不知道有什么用，我见到的都用的是rbp
rcx   ...   ...   ...    本意是counter
rdx   ...   ...   ...    本意是data
rsi   esi   si    sil    源变址寄存器
rdi   ...   ...   ...    目标变址寄存器
rbp   ebp   ...   bpl    基址指针寄存器Base Pointer，指向栈底
rsp   esp   ...   ...    栈顶指针寄存器Stack Pointer
r8    r8d   r8w   r8b    通用寄存器
```

## 寻址

* R[] 和 M[]表示从寄存器和内存中按C语言风格取值，实际不存在这种写法
* 基址寻址的基础是寄存器，Imm很小。变址寻址的基础是Imm，范围可以表示整个内存。其中基础是不变的，变址寻址一般用于数组运算

```
格式            操作数值                 名称
$Imm            Imm                     立即数寻址
%ra             R[%ra]                  寄存器寻址
Imm             M[Imm]                  绝对寻址
(%ra)           M[R[%ra]]               间接寻址
Imm(%rb)        M[Imm+R[%rb]]           基址(+偏移量)寻址，如4(%rax)表示某个4字节指针+1再解引用
Imm(%rb,%ri)    M[Imm+R[%rb]+R[%ri]]    变址寻址。Imm可不存在
Imm(%rb,%ri,s)  M[Imm+R[%rb]+R[%ri]*s]  比例变指寻址/索引寻址。Imm和rb可不存在但逗号必须有
```

Intel风格

```
格式                含义
Imm                 立即数字面量，如1
eax                 可理解为操作eax这个变量，作为右值是是取寄存器的值，作为左值时是写入寄存器
类型 PTR [rbp-4]    可理解为内存中的某个局部变量
类型 PTR [rdi]      可表示指针指向的对象，寄存器的值是指针的值
类型 PTR [rdi+4]    可表示arr[1]
[rbp-4]             对于lea，将rbp-4视为立即数，里面的东西不重要所以不用写类型
```

## 指令

* Intel风格的S和D与AT&T风格相反，D在前面，S在后面，与C一致，如mov D S是D=S，add D S是D+=S
* Intel风格不在指令后加类型后缀
* 以#开头的是注释，以.开头的是伪指令
* 当读写内存时，几乎所有指令的操作数都应理解为地址

## 数据传输指令

* movb S, D：`D <- S` 传送字节
* movl：传送int。movw、movq：略
* movabsq I, R：传送绝对的四字
* x86-64传送指令的两个操作数不能都指向内存
* x86-64的movl的D为寄存器时会把高四位设成0；其它都是只更改指定位数，不在范围内的不做处理

### 零扩展、符号扩展

* movzbw：字节零扩展到字；movzbl、movzwl、movzbq、movzwq同理
* movsbw：字节符号扩展到字；movsbl、movswl、movsbq、movswq、movslq同理
* cltq：不接受参数，直接把%eax符号扩展到%rax
* 没有movzlq，可用以寄存器为目的movl实现

### 加载有效地址

* lea S, D：`D <- &S`
* 也可理解为将S视为立即数而非取它的值
* 能用来优化计算：int c = a+b -> `leal (%rdi,%rsi), %eax`

## 压栈和出栈和函数调用

* 习惯上把栈倒过来画，可以想象一个倒过来的杯子，上面高地址是栈底，下面低地址是栈顶，地址是从下往上变大，栈的增长方向是从上到下，即压栈后栈指针的地址会变小
* pushq S：将四字（指针）压入栈，相当于`R[%rsp] <- R[%rsp]-8; M[R[%rsp]] <- S`
* popq D：将四字弹出栈，相当于`D <- M[R[%rsp]]; R[%rsp] <- R[%rsp]+8`
* 调用函数时，实参参数算好，可以放到寄存器里，然后一次性从后往前push那些参数（x86用栈传参，除非在函数声明前加` __attribute__((fastcall))`），再CALL函数
* Linux下X86用int 0x80做系统调用，X64用syscall？
* CALL：压栈当前IP寄存器指示的下一条指令（称为返回地址，64位占8字节），并修改IP为CALL的程序段的地址。RET：弹出栈顶的地址给IP，等价于pop rip
* LEAVE：等价于mov rsp,rbp; pop rbp。退出函数时若rsp改变过，不等于当初push rbp的值，则用到此指令

## 算数和逻辑操作

* INC D：自增1
* DEC D：自减1
* NEG D：取负
* NOT D：取补
* ADD S, D：加，D <- D+S
* SUB S, D：减，D <- D-S；可以理解成从D中减去S
* IMUL S, D：乘。有两种格式，第二种有三个操作数。乘除的结果需要用rax和rdx共同存放
* OR、AND、XOR：或、与、异或
* SAL/SHL k, D：左移；k可以是立即数或%cl中的数
* SAR k, D：算数右移；只有右移需要区分有无符号数
* SHR k, D：逻辑右移

### 比较和分支

* cmp a, b：类似于减法，但结果是临时的，且会设置机器状态字
* je jne：将上一句cmp的结果和0比较，如果 相等/不等 则跳转到指定段
* jl jle jg jge：分别表示< <= > >=

## 示例

```c
// 进函数，push rbp 保存原栈底，mov rbp, rsp 把原栈顶作为新栈底。此时[rbp,rbp+8)保存了原rbp的内容且属于本函数的栈帧，[rbp+8,rbp+16)保存了返回地址
void f() {    // 内存地址为rbp
    int a;    // 未使用，不分配地址
    int b=1;  // mov DWORD PTR [rbp-4], 1：把立即数1赋给rbp-4的位置上，b占用[rbp-4,rpb)的位置
    int c=2;  // 内存地址为rbp-8(到rbp-4)
} // 返回：pop rbp; ret 因为没有更改rsp，此时栈顶的就是之前push的rbp，能直接pop回去

int f1(int a) {
    return a;
    // 32位下生成 mov eax, DWORD PTR [ebp+8]。其中[ebp+8]表示获取调用者压栈的第一个变量，[ebp,ebp+4)为原ebp，[ebp+4,ebp+8)为返回地址。本函数分配的变量相对于现在的ebp是负的
    // 开优化后没有push rbp等了，整个函数编译为mov eax, DWORD PTR [esp+4]; ret 因为没有压栈原ebp，只有调用者压栈了参数和返回地址
}

int caller() {
    // sub esp, 16 移出局部变量的位置。TODO:为什么是16
    int a = 0;

    // 32位下push 1，64位下mov edi, 1
    return f1(1); // call f1。没有对%eax进行处理，因为直接用f1设置过的就行了
    // add esp, 4 32位下清除压栈的参数
    // leave; ret
}

void fp(int* p) {
    *p = 1;  // 开优化后为 mov DWORD PTR [rdi], 1。不开优化会无意义赋值几次（值传递）。32位下会先将参数取到寄存器中
}

void cond(int a) {
    if (a == 0)    // cmp DWORD PTR [rbp-4], 0; jne .L2  若用!=0就是je .L2
        return 1;  // mov eax, 1; jmp .L3
    else           // .L2:
        return 0;  // mov eax, 0
    // .L3: pop rbp; ret
}

void loop(int n) {
    // i视为局部变量，初始化后先跳到后面的判断段
    for(int i=0;i<n;i++)  // i<n的判断在后一段，如果比较通过则跳入循环体，否则继续执行就出循环了
        f1(i);            // 循环体，完成后i+=1也属于此部分
    // 开启优化后，判断段不再单独出现了，而是直接放在循环体后，不满足则继续跳到循环体段开头。还会先把不满足初始条件（一次也不进入循环）的逻辑分离开
}
```

## Cheat Engine

* 扫描浮点数的时候考虑关闭快速扫描
* 汇编风格是Intel的
* 寻找指针
  1. 先找某个值添加进观察列表
  2. 右键选“是什么改写了这个地址”，双击一项，看是不是`mov [xxx],xxx`，会给一个自动猜测的地址，右键复制；此项也可能和1的地址相同，但如果有偏移就必须这样做了。注意每个观察条目的调试器只能开一个，多了会不显示，小心是不是藏到主窗体后面了
  3. 重新扫描，勾上十六进制，填2中的值。如果搜出来多个结果，一般选地址小的，但不要选以文件名开头的。它的值（加上偏移）就是1的地址，即它是指针
  4. 双击监视栏里3添加的条目的“地址”，勾上“指针”，去掉十六进制。此时它的地址显示的就是P->xxx，其中xxx是1的地址，它的值变为和1一样
  5. 右键它，选锁定
  6. 多级指针可以用“是什么访问了这个地址”且选“是什么访问了该指针”，因为该指针本身不会被修改无法用2的方法。看`mov xxx,[xxx]`，后者就是自己，前者就是2要找的，但如果两者一样就看其他条，再按3搜索
  7. 最高一级勾上指针后“添加偏移”可以自动依次解引用，最后锁定最高级即可
  7. 多级指针也可以用“生成指针映射集”，更改指针，再“对这个地址指针扫描”，勾上“与其他保存的指针映射集比对”，修改数据，找到变化了的且以文件名开头的，就是需要的
* 代码注入(Hook)
  1. 打开“是什么改写了这个地址”，选“显示反汇编程序”。也可以直接右键选“浏览相关内存区域”和“反汇编此内存区域”
  2. 工具 - 自动汇编，模板 - 代码注入，确定
  3. 自由写汇编代码
* 替换为空指令：“是什么改写了这个地址”面板中直接点“替换”就行了，输入框是注释，之后要恢复可在左下角“高级选项”中
* 中文：修改languages\languages.ini

## IDA Free

* 按F5能反编译成伪代码，但免费版必须在云端处理，速度慢
* https://hex-rays.com/products/ida/support/idadoc/index.shtml https://hex-rays.com/tutorials/

## [x64dbg](https://x64dbg.com/)

* 主窗口是反汇编，F7单步进入，F9一直运行。右边是寄存器，RIP是下一条指令。右下角是栈
* 刚运行的时候不是主模块，点“断点”，删掉两个TLS回调函数断点，F9即可
* 右键-搜索-当前模块或所有模块-字符串，右键-在所有命令上切换断点（即给搜出来的都加断点）
* “符号”含有模块导入了的API，双击如MessageBox，下断点，停住后此时是系统代码无意义，用Ctrl+F9运行到返回或Alt+F9运行到用户代码
* 按空格修改当前行的汇编或右键-二进制-用nop填充。修改完后右键-补丁-修改文件，生成修改后的程序
* [MapoAnalyzer](https://www.52pojie.cn/thread-1477955-1-1.html)反编译

## WinDbg

* 能反汇编，能看到局部变量、栈、寄存器。但不适合用作普通的反汇编工具，无法修改汇编，找不到字符串。一般用法是附加到出问题的进程上观察内存使用状况，以及处理异常
* 能处理蓝屏dmp，一般用!analyze -v看最后一段，但结果可能和BlueScreenView不一样
* 会下载一大堆系统dll的pdb到%PROGRAMDATA%\Dbg中，不过占用不大，多的大概200MB
* 直接把文件拖进去默认视为dmp
* 命令总结：https://bbs.pediy.com/thread-271490.htm
  * 清屏 .cls
  * 查看托管堆中的对象 !dumpheap -stat
  * 检查异常：!analyze -v、.exr -1、!pe(sos提供)
  * 寄存器r 进程信息| 反汇编u 反汇编整段函数uf 显示内存d 修改内存e 搜索内存s 内存信息!address
  * 列出所有线程：~ 切换到主线程~0s 调用栈k
  * 断点：继续运行g 单步跳过p 单步进入并打印寄存器t 单步跳过到下一个函数调用pc 单步进入到下一个函数调用tc 单步跳过到下一个函数返回pt 单步进入到下一个函数返回tt 跳出gu 设断点bp 列出现有断点bl
  * 结束调试但不结束进程qd 结束调试和进程q
  * 帮助 .hh。调试c#的插件的帮助 !sos.help
  * 搜索函数（实际是符号）：x 模块名!函数名，支持*通配
  * 解析指定地址的值：四字节dd 双精度浮点dD 指针dp 结构体dt .NET对象do ASCII字符串da
  * 列出所有模块：lm
  * 修改寄存器的值：r rax=0。写入四字节数据：ed addr val
  * 列出句柄：!HANDLE
  * 添加自己程序的pdb：.sympath+c:/xxx/Debug .reload。不需要设置srcpath因为pdb里包含源代码路径信息
* 扩展插件
  * 列出当前加载了的插件.chain。加载插件.load xxx.dll
  * sos：好像默认就会加载，如果没有加载，可能是在用64位windbg调试32位程序。手动加载用.loadby sos clr
  * http://www.stevestechspot.com/SOSEXV40NowAvailable.aspx !sosex.help，!dlk检查死锁，!strings列出字符串
  * https://github.com/rodneyviana/netext 对堆用类LINQ方式提取，能显示字典，能显示一些HTTP相关内容
* 时间旅行调试：需管理员权限，Launch Executable (Advanced)，勾右下角的选项。记录完成后调试时可以回退

## TODO

* https://www.zhihu.com/question/364558697 https://zhuanlan.zhihu.com/p/66372379
* https://mp.weixin.qq.com/s/Od9X-qnQ3WWyZiLIS4uPFg
* https://www.zhihu.com/question/22299883
* https://zhuanlan.zhihu.com/p/56929325
* https://blog.csdn.net/lqt641/article/details/73002566
* 程序员的自我修养
* 逆向工程权威指南 https://beginners.re/RE4B-CN-partial/html/RE4B-CN-partial.html
* https://www.kanxue.com/chm.htm
* https://www.aliyundrive.com/s/6nQiTGUdDk5/folder/60ea7ad34fb7f14e1a6c466ead23a321f9a4cccd Win逆向教程试看
* https://www.52hb.com/thread-16898-1-1.html Shark恒零基础破解教程之图文版
* https://www.52pojie.cn/thread-1358649-1-1.html

### 其它反汇编软件

* https://github.com/NationalSecurityAgency/ghidra
* https://github.com/radareorg/radare2 https://github.com/rizinorg/rizin 好像前者无GUI
* https://www.relyze.com/overview.html
* https://cutter.re/ 开源
* https://github.com/WerWolv/ImHex
* Detect-It-Easy：检测加壳信息，开源
* https://binary.ninja/demo/ 收费，网页版免费
* https://angr.io/
* https://github.com/uxmal/reko
* https://github.com/avast/retdec
* https://github.com/yegord/snowman
* https://godbolt.org/ Compiler Explorer，在线，按Ctrl+s能下载当前代码
* https://zydis.re/
* https://hyperdbg.org/ 调试器
* https://github.com/WerWolv/ImHex 十六进制编辑器
