---
title: 汇编
---

## 数据格式

```
C类型        Intel类型 汇编代码后缀 大小(字节)
char         字节           b        1
short        字             w        2
int          双字           l        4
long/char*   四字           q        8
float        单精度         s        4
double       双精度         l        8
```

## 寄存器

```
63     31    15     7       作用
%rax   %eax  %ax    %al    (函数的)返回值
%rbx   ...   ...    ...    被调用者保存
%rcx   ...   ...    ...    第4个参数
%rdx   ...   ...    ...    第3个参数
%rsi   %esi  %si    %sil   第2个参数
%rdi   ...   ...    ...    第1个参数
%rbp   %ebp  ...    %bpl   基址寄存器，被调用者保存
%rsp   %esp  ...    ...    栈指针
%r8    %r8d  %r8w   %r8d   第5个参数
```

* 运算int，包括返回值，用的是exx；bp和sp，64位用的是rxx，32位是exx
* int参数大于6个才会用到栈，否则用寄存器；但浮点和指针不能用

## 寻址

* ra实际要写%rax等，Intel风格不用写%
* R[] 和 M[]表示从寄存器和内存中按C语言风格取值，实际不存在这种写法
* 间接寻址在Intel风格中用的是中括号

```
格式           操作数值               名称
$Imm           Imm                   立即数寻址
ra             R[ra]                 寄存器寻址
Imm            M[Imm]                绝对寻址
(ra)           M[R[ra]]              间接寻址
Imm(rb)        M[Imm+R[rb]]          基址(+偏移量)寻址
Imm(rb,ri)     M[Imm+R[rb]+R[ri]]    变址寻址。Imm可不存在
Imm(rb,ri,s)   M[Imm+R[rb]+R[ri]*s]  比例变指寻址。Imm和rb可不存在但逗号必须要有
```


## 数据传输指令

* x86-64传送指令的两个操作数不能都指向内存
* x86-64的movl的D为寄存器时会把高四位设成0；其它都是只更改指定位数，超出的位数保留不变
* movb S, D：`D <- S` 传送字节。Intel风格刚好相反，第一个参数是D，第二个是S
* movw、movl、movq：略
* movabsq I, R：`R <- I` 传送绝对的四字

### 零扩展和符号扩展

* movzbw：字节零扩展到字；movzbl、movzwl、movzbq、movzwq同理
* movsbw：字节符号扩展到字；movsbl、movswl、movsbq、movswq、movslq同理
* cltq：不接受参数，直接把%eax符号扩展到%rax
* 没有movzlq，可以用以寄存器为目的movl实现

## 压栈和出栈

* 习惯上把栈倒过来画，地址仍是从下到上增大但是栈的增长方向是同上到下，也就是压栈后栈指针的地址会变小
* pushq S：将四字（指针）压入栈，相当于`R[%rsp] <- R[%rsp]-8; M[R[%rsp]] <- S`
* popq D：将四字弹出栈，相当于`D <- M[R[%rsp]]; R[%rsp] <- R[%rsp]+8`

## 算数和逻辑操作

* INC D：自增1
* DEC D：自减1
* NEG D：取负
* NOT D：取补
* ADD S, D：加，D <- D+S
* SUB S, D：减，D <- D-S；可以理解成从D中减去S
* IMUL S, D：乘
* OR、AND、XOR：或、与、异或
* SAL/SHL k, D：左移；k可以是立即数或%cl中的数
* SAR k, D：算数右移；只有右移需要区分有无符号数
* SHR k, D：逻辑右移

## 加载有效地址

* `leaq S, D` 效果：`D <- &S`，即把S的地址赋值给D
* 但有时可以用于与地址完全无关的计算，比如：`leaq (%rdi, %rsi, 4) %rax`相当于x+4*y

## 示例

```c
void f() {    // 内存地址为rbp
    int a;    // 未使用，不分配地址
    int b=1;  // movl $1, -4(%rbp)：把立即数1赋给rbp-4的位置上
    int c=2;  // 内存地址为rbp-8，即地址比b更小，因为栈从高内存往低内存增长，先分配b占用[rbp-4,rpb]的位置，再分配c占用[rbp-8,rbp-4]的位置
}
```

## 参考

* rbp rsp https://blog.csdn.net/weixin_43905243/article/details/104397024
* https://www.zhihu.com/question/22299883
* https://zhuanlan.zhihu.com/p/56929325
* https://blog.csdn.net/lqt641/article/details/73002566
* 《CS:APP》
* 待读：程序员的自我修养
* 逆向工程权威指南 https://beginners.re/RE4B-CN-partial/html/RE4B-CN-partial.html
