---
title: WPF
category: dotnet
---

## XAML

* 一些字符需要用XML的实体转义，但在cs中写就不用了
* VS中有一些Snippet，如`Tag`
* .NET项目会自动导入xaml和xaml.cs，MSBuild项目必须手动导入`<Page Include="xxx.xaml"/>`和`Compile`
* TypeConverter：使得在XAML中创建自定义类对象时能根据`属性=字符串`的字符串创建其属性对象。定义一个类继承它，重写ConvertFrom()，value就是字符串值，返回的对象就是属性对象，作为特性应用到自定义类上
* 如果一个属性需要集合，子元素可以直接写集合元素，不必先创建集合对象本身

### Application/App.xaml

* StartupUri：相对路径
* Startup事件
* Deactivated事件：焦点切换到别的程序
* 全局设置字体：`typeof(SystemFonts).GetField("_messageFontFamily", BindingFlags.Static | BindingFlags.NonPublic).SetValue(null, new System.Windows.Media.FontFamily("微软雅黑"));`
* cs文件没用到时可以删除

### xmlns

* xml:space="preserve"：默认情况下，XAML中写的空格会忽略或者合并成一个，方便设置Text时缩进换行。设置此项后就会保留
* xmlns:local="clr-namespace:WpfApp1"
* xmlns:sys="clr-namespace:System;assembly=netstandard" # FX为mscorelib
* d:Content设置仅在设计时的占位文字
* x:Name用于设置对应的.cs中的对象名
* {x:Static xxx}含有一些预定义的静态对象
* x:Class设定与Window关联的code-behind的类，或看作XAML编译后生成的类。x:ClassModifier、x:FieldModifier：默认public，可设为private等

## Window

* 窗体加载事件：Loaded，发生在构造函数之后
* 无边框：WindowStyle="None" ResizeMode="NoResize"，可选WindowState="Maximized"。但窗口就无法直接拖动了。一般最外层用Border，再用Grid
* 透明：AllowsTransparency="True" Background="Transparent"。
* 持续置顶：`void Window_Deactivated(object sender, EventArgs e) => ((Window)sender).Topmost = true;`
* 在屏幕中间出现：WindowStartupLocation="CenterScreen"
* 第一次显示时根据内容调整大小：SizeToContent="WidthAndHeight"
* Show()。ShowDialog()模态打开
* ActualWidth是渲染后的Width，如果Width大于MaxWidth，ActualWidth就和Width不等
* WindowStyle：ToolWindow非常丑，ThreeDBorderWindow与默认的SingleBorderWindow无明显区别
* w.Owner=this：两者一起最大化最小化，Owner关闭时w关闭
* NavigationWindow：继承了Window，会形成一个具有Win7前进后退按钮的窗口，注意也要修改cs中的继承。初始页为其Source属性的Page的xaml

## 布局

### Grid

* 划分成多行列
* 控件代码所在层级与Grid.ColumnDefinition相同
* 控件用Grid.Row、Grid.Column、Grid.RowSpan属性设置自身所在Grid中的位置
* 控件默认会填充整个空间(VerticalAlignment=Strech)，设置控件横向/纵向居中、最大宽度/高度且有空，则又会对应收缩到内容的大小

```xml
<Grid Margin="10"> # 等于new Grid()
    <Grid.ColumnDefinition> # 属性语法
        <ColumnDefinition Width="20"/> # 集合语法
        <ColumnDefinition Width="auto"/> # 适应内容大小，可设定MaxWidth和MinWidth
        <ColumnDefinition Width="*"/> # 取剩下的所有空间，优先级低于设定好的；如果有两个就平分，还有一个2*那个就占2/3；不设置就等于*
        <ColumnDefinition Width="20"/>
    </Grid.ColumnDefinition>

   <Grid.Background>
       <ImageBrush ImageSource="watermark.png" />
   </Grid.Background>
</Grid>
```

### 其它布局控件

* StackPanel：堆叠排列，默认竖排靠上，通过Orientation和HorizontalAlignment分别设置，控件默认横向填充满但竖排收缩。空间不够时内容会超过而不显示，可以把它放到ScrollViewer里面显示滚动条
* WrapPanel：默认横向排列，横向空间不够时自动换到第二行
* DockPanel：内部控件可以选择停靠位置，默认为Left，最后一个默认填充剩余空间，可用LastChildFill="False"取消
* UniformGrid：无需定义行列，自动根据内容排列
* Canvas：使用固定坐标
* VirtualizingStackPanel：没看懂

## 样式Style

* 如果不写x:Key，会自动应用到本Window的TargetType对应的元素上，若是Application就应用所有。但TargetType是父类如Control无效，且好像Window的不会跨越ControlTemplate
* 控件无边框：BorderBrush="{x:Null}"
* 控件范围内也可以设置Resources属性，再在里面设置Style

```xml
<Window.Resources>
<Style x:Key="MyStyle" TargetType="{x:Type Button}"> # 也可以直接写Button
    <Setter Property="Background" Value="Red" BasedOn="{StaticResource xxx(继承)}" /> # Value若是集合就用<Setter.Value>

    <Style.Triggers> # 满足条件时使用的样式
    <Trigger Property="IsMouseOver" Value="True">
        <Setter...>
    </Trigger>
    <MultiTrigger>
        <MultiTrigger.Conditions> <Condition ...></MultiTrigger.Conditions>
        <MultiTrigger.Setters> <Setter...> </MultiTrigger.Setters>
    </MultiTrigger>
    <EventTrigger RoutedEvent="Mouse.MouseEnter">
        <EventTrigger.Actions>
            <BeginStoryboard>
                动画
    <DataTrigger Binding="{Binding xxx}" Value=""> # 值满足条件
    </Style.Triggers>
</Style>
</Window.Resources>

<Button Style="{StaticResource MyStyle}">
```

## 绑定Binding

* Prop={Binding ..., 选项=...}，实际上是创建了Binding对象并给它设置属性
* Path或不写：要使用的属性，默认从DataContext(VM)里取
* 取另一个控件的内容：ElementName=另一个控件的xName
* 取资源中的内容：Source={StaticResource xxx}
* Mode
  * 默认是若两者都可编辑就是TwoWay双向绑定，自己只读就OneWay仅当源更改时更新
  * OneTime仅当Window创建或VM更改时更新，OneWayToSource是OneWay反向
* 更新VM时，默认自身丢失焦点才会更新，可设置UpdateSourceTrigger=PropertyChanged即时更新
* ComboBox的ItemsSource属性要绑定列表。一般还要把ItemTemplate属性下的DataTemplate绑定为元素的想要显示的属性
* FallbackValue：指定绑定失败时的值
* StringFormat：简单的VM和View之间的转换，一般还可用在MultiBinding中
* 控件只有依赖项属性DependencyProperty才能被绑定？反正VM的普通属性可以
* Converter：创建一个实现IValueConverter的类，绑定时指定Converter={StaticResource xxx}。Convert()指示VM变化时怎么设置V，ConvertBack()反过来

## 资源

* 注意是x:Key不是x:Name
* 动态静态
  * StaticResource只会读取一次，DynamicResource每次使用都会读取，用于会变化的资源
  * 某些地方只能用Static，如样式的继承
  * Dynamic在读取失败时可能没有任何提示，Static在目标不存在时VS能检查出来，但没有编译错误，会在运行时抛XamlParseException
* cs文件中能用Resources["Key"] as xxx使用；在App.xaml中设置的用Application.Current.Resources；或用this.[Try]FindResource仅使用，它也会找App.xaml的
* 可在一个xaml中声明单独的ResourceDictionary，当使用时在本文件的Resources下的MergedDictionaries属性声明ResourceDictionary Source=那个xaml。一般所有的Style会放到Theme文件夹下，用这种方式再加载到App中
* 字体文件添加进项目后自动作为资源，使用时FontFamily="Fonts/#字体名"

```xml
<Window.Resources>
    <SolidColorBrush x:Key="defaultBackground" Color="Red" />
    <sys:String x:Key="s">hello world</sys:String> # 无需双引号
</Window.Resources>
<Button Background="{StaticResource defaultBackground}">One Button</Button>
```

## 控件模板

* 修改控件本身的样式，可以组合多个控件，感觉上就是创建了一个新的控件，只是允许把老控件的属性绑定到新控件上
* 在资源里创建
* TemplateBinding：绑定到TargetType指定的控件中的对应属性
* 可设置Triggers属性，Trigger的Setter的TargetName属性可指定控件模板中命了名的控件
* 使用者：Template={StaticResource xxx} TODO: 注意可作为Style

```xml
<ControlTemplate TargetType="RadioButton">
    <Grid Background="{TemplateBinding Background}">
        <TextBlock Text="{TemplateBinding Content}" VerticalAlignment="Center"/>
    </Grid>
</ControlTemplate>
```

## 数据模板

* 属于使用控件，是控件给使用者提供的功能
* 决定Content如何显示
* Binding为数据源元素的属性
* DataGrid->CellTemplate；ListBox/ComboBox/TreeView->ItemTemplate属性；UserControl->ContentTemplate；ItemsControl->ItemsPanel->ItemsPanelTemplate,ItemTemplate

```xml
# 手动MVVM示例：主窗体使用时绑定自己的VM，里面创建子窗体的VM；主窗体的V创建ContentControl，绑定子窗体VM
<DataTemplate DataType="viewModel:MyViewModel">
    <view:MyView> # 这个View是个UserControl而不是xaml
</DataTemplate>
```

## Command

* 使用时在VM中把自己的函数赋给RelayCommand引用上，再在V中绑定
* Command="{Binding xxxCommand}"
* CommandParameter：不指定时为null
* CommandTarget：要执行命令的对象，就是sender。必须为RoutedCommand才有效，不设置时默认为焦点
* 控件实现ICommandSource和以上三个属性，就支持命令

```c#
// 自定义一个为了满足接口要求的包装类，用于MVVM
class RelayCommand<T>: System.Windows.Input.ICommand {
    Action<T> _execute;
    Predicate<T> _canExecute;
    public event EventHandler CanExecuteChanged {
        add {CommandManager.RequerySuggested += value;}
        remove {CommandManager.RequerySuggested -= value;}
    }
    public RelayCommand<T>(Action<T> execute, Predicate<T> canExecute=null) {
        _execute = execute; _canExecute = canExecute;
    }
    public bool CanExecute(object param) => _canExecute==null ? true : _canExecute((T)param);
    public void Execute(object param) => _execute((T)param);
}
public ICommand LoginCommand {get;set} = new RelayCommand(act); // VM里
<Button Command="{Binding LoginCommand}">

// 原本的用途，如给预定义的Window实例的ApplicationCommands.Open命令设置handler
<Window.CommandBindings>
  <CommandBinding Command="ApplicationCommands.Open" Executed="OpenCmdExecuted"/>
</Window.CommandBindings>
void OpenCmdExecuted(object target, ExecutedRoutedEventArgs e) {(RoutedCommand)e.Command； (FrameworkElement)target}
```

## ViewModel

* 每个窗体和控件有一个object类型的DataContext，即VM。Binding的东西默认从这里取
* 在V中写`<Window.DataContext><local:MainWindowViewModel /></Window.DataContext>`
* 只在界面上存在的属性就属于VM而不是M，比如用户是否勾选本条数据

```c#
public class MainWindowViewModel:INotifyPropertyChanged {
    public event PropertyChangedEventHandler PropertyChanged;
    int myProp;
    public int MyProp {
        get => myProp;
        set {
            myProp = value;
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(MyProperty))); // 或用 OnPropertyChanged();
        }
    }
    void OnPropertyChanged([CallerMemberName]string propName = null) => PropertyChanged?.Invoke(this, new(propName));
}
```

## 控件

* Text属性只能是string。Content属性只要具有ContentPresenter的对象都可以，通过ItemTemplate属性里DataTemplate指定
* Button
  * 子元素为Content属性，可以是TextBlock，默认自动居中
  * IsDefault="True"为按回车时执行，IsCancel为按Esc时执行，只有用ShowDialog打开的窗口有效
  * RepeatButton：可以一直按下一直生效，如滚动条的上下
* TextBox：不能换行，用于单个字段的输入和显示，内容文字居中用VerticalContentAlignment。用作别的控件的Content时有白色背景。RichTextBox、PasswordBox
* TextBlock：与Label相似，支持多行内容。子元素为Text属性，可用Run和LineBreak标签
* Border：边框，BorderBrush设置颜色，BorderThickness宽度，CornerRadius圆角，Background填充内部颜色，Clip按自定义方式裁剪
* Image：Source为BitmapImage对象，XAML中可为路径字符串。不能直接是Bitmap TODO:
* ComboBox：下拉框。子元素为列表，如果是对象一般简单的要设置DisplayMemberPath
* ListBox：竖向显示内容的列表
* CheckBox
* RadioButton
* 对话框：OpenFileDialog、SaveFileDialog
* DataGrid：类似于表格。一般指定CanUserAddRows=False否则最后会多出一个空行。指定AutoGenerateColumns=False后可手动定义行，否则默认显示数据源的所有属性；给Columns属性下写`<DataGridTextColumn Binding Header>`或DataGridTemplateColumn.CellTemplate
* 数据显示：ListView、TreeView
* Rectangle：Stroke笔触为边框，Fill为填充颜色，RadiusX/Y圆角。Fill写字符串只能是SolidBrush单一颜色，用属性语法可设置LinearGradientBrush渐变色

## 异常

* 默认什么提示也没有直接闪退
* UI线程上发生的未处理异常会触发Application.DispatcherUnhandledException，可在App的Application_Startup中添加handler
* 另一种方式是Window的Window_Loaded中添加处理Dispatcher.UnhandledException
* 两者都可添加处理Application.Current.DispatcherUnhandledException
* 可设置e.Handled=true不终止程序
* AppDomain.CurrentDomain.UnhandledException全能捕获，包括非UI线程的，但这些是不可恢复的异常，程序会终止

## [DPI感知](https://github.com/microsoft/WPF-Samples/blob/main/PerMonitorDPI/readme.md)

* 默认是System级别的，只要修改清单就能支持PM。在其它UI框架中的WPF也自动支持，但WPF中嵌入其它UI框架（HwndHost和WindowsFormsHost）不支持自动缩放
* 单独渲染不在主VisualTree的控件时要用VisualTreeHelper.SetRootDpi
* 屏幕大小，125%缩放下已经是物理大小除以倍数：SystemParameters.PrimaryScreenHeight/Width、WorkArea
* 在100%缩放下，屏幕大小会变为物理的，窗口大小会变小，但Width值不变
* 不依赖控件渲染获取DPI Ratio：(int)typeof(SystemParameters).GetProperty("Dpi", BindingFlags.NonPublic | BindingFlags.Static).GetValue(null) / 96
* 一些Win10下winuser.h(User32.dll)中的函数：GetSystemMetricsForDpi AdjustWindowRectExForDpi SystemParametersInfoForDpi GetDpiForWindow

```xml
<dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
<dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware> # WPF自动启用，为系统级别
```

```c#
// 使用了FormattedText时响应变化
using System.Windows.Media;
void MainWindow_Loaded() { // 初始化时根据主屏幕DPI处理
    DrawFormattedText(VisualTreeHelper.GetDpi(this));
}
protected override void OnDpiChanged(DpiScale oldDpiScaleInfo, DpiScale newDpiScaleInfo) { // 主窗口DPI变化时
    DrawFormattedText(newDpiScaleInfo);
}
void DrawFormattedText(DpiScale dpiInfo){ // 根据不同的DPI绘图
    new FormattedText(...,dpiInfo.PixelsPerDip); // 此属性已经是ratio
}
// Image的推荐做法是根据不同DPI读取不同的图片，它具有DpiChanged事件，选好后设置Source属性
```

## HWND消息

```c#
using System.Windows.Interop;
IntPtr hWnd = new WindowInteropHelper(this).EnsureHandle();
HwndSource.FromHwnd(hWnd).AddHook(WndProc);
IntPtr WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled){...; return IntPtr.Zero;}
```

## VS插件

* Debugger Image Visualizer
* XAML Studio：https://www.microsoft.com/zh-cn/p/xaml-studio/9ntls214tkmq

## UI框架

* https://github.com/windows-toolkit/WindowsCommunityToolkit 有CommunityToolkit.Mvvm
* https://github.com/canton7/Stylet 受到了Caliburn.Micro的启发，不过各种数据都很少
* https://github.com/PrismLibrary/Prism 好像比较复杂，支持Xamarin
* https://github.com/MvvmCross/MvvmCross 跨平台，支持Xamarin，所以也许比较重
* https://github.com/reactiveui/ReactiveUI 对cs代码有非常侵入式影响
* https://github.com/AvaloniaUI/Avalonia Commit非常多，跨平台，但改了XAML语法，不是WPF能用的了
* WinUI要装UWP开发，10G；MAUI基于WinUI；mvvmlight不维护；Catel需要WinSDK

### Caliburn.Micro

* 安装过程
  * 删掉MainWindow，去掉StartupUri
  * 创建Bootstrapper.cs，继承BootstrapperBase
  * App.Resources.MergedDict创建`<local:Bootstraper x:Key="Bootstrapper">`
  * 建立文件夹Views,Models,ViewModels，里面的文件也需要有对应的后缀
  * 重写Bootstrapper的OnStartup，`DisplayRootViewFor<ShellViewModel>()`
* VM一般继承Screen，public。M列表对应`BindableCollection<MyModel>`
* 绑定
  * View中控件的x:Name与VM中想绑定的属性一致，再加下划线可取属性
  * 对于Button，x:Name为自定义函数，参数若声明为VM属性的首字母小写，会传入对应的值。支持定义bool CanF属性或函数设定按钮是否启用，其中属性要通知，函数要声明对应的参数
  * 也可以用Binding，上下文自动设为VM
* 通知：set中`NotifyOfPropertyChanged(()=>MyProp)`
* 主窗体中显示子窗体：主VM继承`Conductor<object>`，V创建(最多)一个ControlContent控件，x:Name="ActivateItem"不能改。子V要是UserControl。主VM中调用ActivateItem(new 子)

## 控件库

* https://github.com/MaterialDesignInXAML/MaterialDesignInXamlToolkit MD风格，活跃
* https://github.com/MahApps/MahApps.Metro Win8风格，活跃
* https://github.com/Kinnara/ModernWpf Win10风格，较不活跃
* https://github.com/benruehl/adonis-ui 漂亮程度还行，较不活跃
* https://github.com/sourcechord/FluentWPF 仅一个毛玻璃窗口和一点点按钮样式
* https://github.com/PanuonGroup/Panuon.WPF.UI 国产。教程：https://space.bilibili.com/319290241
* https://github.com/xceedsoftware/wpftoolkit 比较老，偏功能
* https://github.com/PropertyTools/PropertyTools 偏功能，非美化
* https://github.com/Dirkster99/AvalonDock 专注于一个布局控件
* 图标：https://github.com/awesome-inc/FontAwesome.Sharp https://github.com/MartinTopfstedt/FontAwesome5
* https://github.com/beto-rodriguez/LiveCharts2
* https://github.com/lepoco/wpfui Win11风格，才出的，贡献者少

### HandyControl（国产）

* 装好后需要添加资源和命名空间：https://handyorg.github.io/handycontrol/quick_start。另有文档更详细的Fork：https://hosseini.ninja
* SkinDefault改成另外两种可换颜色，BackgroundColor默认是灰色
* BlurWindow是毛玻璃背景，需加`Style="{StaticResource WindowBlur}"`或`Background="Transparent"`，前者有不懂为什么会出现的警告但其实能生效，后者导致设计界面变空不方便。在App中重写一个资源可自定义模糊颜色
* 装好后就已经重写了许多自带控件的样式

## 参考

* https://www.youtube.com/channel/UC-ptWR16ITQyYOglXyQmpzw
* https://docs.microsoft.com/zh-cn/dotnet/desktop/wpf
* https://github.com/microsoft/WPF-Samples
* https://space.bilibili.com/12074309
* https://space.bilibili.com/32497462
* 刘铁猛的视频和书

### TODO

* 了解循环类型的控件，例如ItemControl控件
* 创建一个典型的控件，探索DependencyProperties（依赖属性）和AttachedProperties（附加属性）
* 学习Observable Collection。该类型的集合广泛使用于数据集合绑定方面，同时也提供了数据改变通知的机制
* 使网格上的列可编辑。用文本控件（用户项目模板）替换列。为每个捕获文本更改事件的列创建一个属性。在文本控件上使用绑定类型。尝试捕获您在后端在网格上所做的更改
* Page
* https://github.com/Squirrel/Squirrel.Windows 打包
* The MVVM Pattern https://docs.microsoft.com/zh-cn/previous-versions/msp-n-p/hh848246(v=pandp.10)
* https://docs.microsoft.com/zh-cn/dotnet/desktop/wpf/controls/styles-templates-overview?view=netdesktop-5.0
* https://docs.microsoft.com/zh-cn/dotnet/desktop/wpf/introduction-to-wpf?view=netframeworkdesktop-4.8 应用程序开发-应用程序管理概述
* WebView2、EdgeSharp

### 教程

* https://wpf-tutorial.com/zh/5/xaml/什么是xaml/
* https://www.wpftutorial.net/Home.html
* https://www.codeproject.com/Articles/140611/WPF-Tutorial-Beginning
* https://www.cnblogs.com/JustRun1983/tag/WPF/
* https://docs.microsoft.com/zh-cn/visualstudio/xaml-tools/designing-xaml-in-visual-studio
* https://www.cnblogs.com/chillsrc/p/4464023.html
* https://www.zhihu.com/people/lyh56/posts
* https://www.youtube.com/playlist?list=PLrW43fNmjaQVYF4zgsD0oL9Iv6u23PI6M
* https://www.cnblogs.com/chillsrc/p/4464023.html


https://docs.microsoft.com/zh-cn/visualstudio/get-started/csharp/tutorial-wpf?view=vs-2022
https://www.bilibili.com/video/BV19K411M72o?p=9
https://www.youtube.com/watch?v=gSfMNjWNoX0&list=PLLWMQd6PeGY3QEHCmCWaUKNhmFFdIDxE8
https://www.bilibili.com/video/BV1nY411a7T8
https://www.bilibili.com/video/BV1S5411c7Bo
https://www.bilibili.com/video/BV1mT4y177BM
https://www.bilibili.com/video/BV1qW4y1t72x
https://www.youtube.com/watch?v=dLR_D2IJE1M https://www.youtube.com/watch?v=70Dj9cnyu2g https://www.youtube.com/watch?v=Fe1sCEqGHFc
https://space.bilibili.com/385802797/video?tid=0&page=2&keyword=&order=pubdate
