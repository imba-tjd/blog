# Java

## 环境

* JDK
  * https://jdk.java.net
  * https://www.microsoft.com/openjdk 基于Adoptium的，有一些未被合并到上游的修改，但目前都是ARM64的
  * Eclipse build：https://adoptium.net/ 提供Win下x86版本，还提供EA版
  * Liberica：https://bell-sw.com/pages/downloads/#/java-18-current 提供Lite版（通过jlink创建的）和带FX的Full版，x86的在下面
  * 镜像：https://www.injdk.cn 收录了不少版本的build，还有Graal
  * OpenJ9：https://developer.ibm.com/languages/java/semeru-runtimes/downloads/ 不基于OpenJDK，内存占用更小，启动时间可能更长，但开启AOT后再次运行有缓存
* mvn：https://maven.apache.org/download.cgi 的Binary zip archive
* VSC
  * Language Support for Java
  * Debugger for Java：不调试可以不用
  * Project Manager for Java
  * SonarLint
  * 裸依赖的jar放在lib文件夹里，或者调java.project.referencedLibraries
  * java.server.launchMode: Standard
  * 出现is not on the classpath of project, only syntax errors are reported，用F1 Java: Clean the Java language server workspace
* servlet容器：tomcat、jetty、WildFly

### 命令行

* 编译：javac -Xlint -g -cp lib.jar:pkg/* -d bin src/com/xxx.java，编译成bin/com/xxx.class（实际是因为package语句）；若CWD为src，就-d ../bin com/xxx.java；linux可用`src/**/*.java`，为老JRE编译--release 11，Win的分隔符为分号
* 运行class：java -cp a.jar:pkg/*:bin com.Main，即指定main()所在的完整类名，而非指定.class文件；选项必须在运行目标前，-ea启用assert语句，-XX:+ShowCodeDetailsInExceptionMessages空指针异常时显示更详细的信息，JDK18后可加--finalization=disabled，其他选项看GC调优
* java命令行现在也能直接运行xxx.java，但好像无法导入模块化的依赖，且main()所在的类必须是第一个
* 打包jar -cvef com.Main out.jar -C bin . 其中e指定入口点，f指定输出的文件，C更改工作目录，还可加--module-version 1.0；运行含有入口点的包：java -jar out.jar args。列出jar中的文件：jar -tf out.jar。显示模块化jar的依赖：jar -d -f
* 模块化
  * 创建和com平级的module-info.java：`module 模块名{requires pkg名; exports pkg名;}`，隐式导入了java.base，其余的import了的库必须在这里声明，别的库想访问本模块的类（如反射）则必须在这里声明导出
  * 一个模块可以包括多个package，一个jar只能有一个模块，自己的.java不能和module-info平行
  * 编译：普通地把module-info编译过去即可，依赖的库可用-p pkg直接指定文件夹了。另一种方式是用-m 模块名 --module-source-path src。生成jar没区别
  * 运行：java -p pkg;out.jar -m 模块名，或-p bin -m 模块名/完整类名（此处的斜杠为字面量）
  * 生成jmod：jmod create --class-path out.jar或bin out.jmod。无法简写成cp，当out.jmod已存在时不会自动覆盖，生成的out.jmod无法运行，仅用于生成jre，感觉没啥用，不如jlink时直接指定.jar或pkg
  * 生成jre：jlink -p out.jmod --add-modules java.base,模块名 --output jre --strip-debug/-G --compress=2/-c=2 --no-man-pages --no-header-files。之后可用jre/bin/java -m 模块名，或先用--launcher创建启动脚本。其中add-modules的内容用jdeps分析。另外不清楚怎么加依赖，需不需要把依赖的jar转换成jmod
  * 分析依赖：jdeps xxx.class或jdeps --module-path out.jar;pkg -m 模块名
* jshell JAVASE：REPL，且自动导入所有标准库
* jcmd：JFR工具，用于Profile。-l列出正在运行的Java程序。其它命令暂不学习
* jpackage -n 项目名
  * 模块化项目：-p 模块路径 -m 模块名/完整类名
  * 非模块化项目：-i bin --main-jar out.jar
  * 创建含有jre和本项目exe的文件夹：-t app-image
  * 创建带有图形界面的安装程序，Win下还要装Wix：--win-dir-chooser --win-console --win-shortcut --icon i.ico
* jdeprscan dir/jar/class：扫描是否使用了废弃的API

### 编码

* 源代码不支持UTF8-with-BOM
* javac -encoding utf8 -d bin Main.java：源文件用u8编码
* java -Dfile.encoding=gbk -cp bin Main：设定运行时编码
* JDK17及之前file.encoding和javac默认为代码页；JDK18默认为U8。改回原行为用=COMPAT，取得代码页编码用System.getProperty("native.encoding")或System.console().charset()
* 如果直接用java命令行运行.java，file.encoding就也影响硬编码字符串的编码了，Win下就一定存在问题
* 用PS时file.encoding要加引号

## 语法

* import导入类，可以用*，默认导入了java.lang.*
* package类似命名空间，顺序要与文件夹匹配；一般一个文件只有一个public类，且要与文件名匹配
* 函数参数不能有默认值；可变参数数组用`类型...`定义
* 异常：Error是严重错误，除RuntimeException以外的异常是Checked Exception，一定要捕获，或在方法参数签名后加throws xxx，可加在main上；catch时可用`|`同时处理多个异常类型
* break和continue支持跳转到label处以跳出多层循环，但label必须紧贴循环语句前边
* byte是有符号的，而C#是无符号的
* main()所在的类不必为public的
* 所有的包装类都是Number抽象类的子类，用intValue()解包成int

### switch

```java
// 只记录java14的，不需要写break
String fruit = "apple";
int opt = switch (fruit) { // 表达式，有返回值
    case "apple" -> 1;
    case "pear", "mango" -> 2;
    case String s && !s.isEmpty() -> ... // 类型匹配，且null不会匹配进去
    default -> {
        int code = fruit.hashCode();
        yield code;
    }
};
```

## 字符串

* 多行字符串为三个双引号，开始时必须要换行且此换行不算内容，以结束时的引号为对齐基准去掉前面的缩进，转义仍有效，不支持raw string
* 其它类型转换为字符串：String.valueOf，字符串转为其它基本类型：Integer.parseInt，可设定基数；Integer.toHexString把整数转换为十六进制字符串；Integer.getInteger与System.getProperty一样，是获得系统属性的值，垃圾命名
* 判断相等用equals；推荐用Objects.equals()，不用判断是否为null
* 取字符必须用charAt()，不支持索引器
* contains、[last]indexOf、startsWith、substring、strip[Leading/Trailing] 如果只有ASCII字符也可用trim、isEmpty、isBlank、replace、replaceAll 正则、split 正则、String.join、formatted/String.format C风格，也可都用%s、toCharArray、getBytes 转换回来用构造函数，第二个参数指定编码、lines 按换行符分隔返回Stream、chars 变为Stream
* StringBuilder：和C#一样，不线程安全，但delete方法第二个参数是index而不是length；完全不要使用StringBuffer，没有使用场景，先有它再有前者
* java.text.MessageFormat.format()：类似C#
* String.valueOf(nullobj)为"null"，C#为""
* StringJoiner：支持设定开头、结尾、分隔符

## 类

* 复用构造函数在函数体内用this()；调用父类成员用super
* 类和接口的继承：extends关键字。实现接口：implements关键字。接口的函数可以在声明前面用default关键字实现默认方法，但不能访问字段。abstract class可以有字段。接口可以有字段，会隐式public static final
* 重写：@Override。默认public函数都是虚函数，这个注解只是帮助检查
* final关键字：用在字段上相当于const，用在参数上类似于C，用在函数上会阻止重写（private函数都隐式final），用在类上阻止继承
* 没有访问修饰符的类为包作用域，能被同包的普通类和public类使用，无需import，不会被其它包import，等价于C#的internal；protected等价于C#的protected internal
* 内部类：普通类不能用private，内部类才可以。如果内部类没有private，就也为包作用域，但在外部使用必须从外部类的对象实例化：`Outer.Inner inner = outer.new Inner()`，内部类对象内部能直接访问外部类对象：`Outer.this.xxx`，能修改外部类的private成员；用static修饰内部类就不再依附外部类对象了，仍可实例化
* 匿名类：`var obj = new 接口名(){类成员}`，省去定义内部类再实例化
* 静态代码块：`static {...}`，类似于静态构造函数
* record Point(int x, int y) {}：定位是命名元组。自动生成构造函数、不可变成员、toString、equals、hashCode；如果要检查范围可写省略参数和括号的构造函数且不用自己给字段赋值
* 枚举：可用==比较两个对象，可定义方法
* 静态函数可通过对象调用，且对象为null也可以，不过会有Lint警告
* Finalize()废弃了，用Cleaner机制替换
* Objects.requireNonNull(obj)
* 让类支持try-with-resources：实现AutoCloseable接口的close()
* JavaBean：boolean字段的getter的命名为isXxx

## 泛型

* 泛型方法与C#相比`<T>`需放在返回值前；静态泛型方法可声明于泛型类中，但调用时无需也不能具体化泛型类，实际与泛型类的泛型无关系
* 类型擦除
  * 不能放基本类型
  * 泛型方法自动推断时会转换成对应的包装类型
  * `C<A>.class == C<B>.class == c.getClass() == C<Object>.class`
  * 不能new T()因为相当于new Object()。变通手段是创建带有Class参数的函数，反射创建实例
  * public boolean equals(T t)会变成equals(Object t)导致与继承自Object的冲突，不过编译器会自动阻止
  * 不能判断带泛型的类型：`o instanceof C<Object>`编译错误，只能用`C`
  * 不能普通地new泛型类型数组，要用`@SuppressWarnings("unchecked") Pair<String>[] ps = (Pair<String>[]) new Pair[2];`
* 可变性
  * 协变用`类型名<? extends T>`，称为上界通配符；逆变用super
  * 声明在函数参数或变量的类型后，一般直接具体化，可直接用于类，不是声明在类和接口的定义上，之后编译器会限制此变量所使用的方法中T在哪种位置
  * 定义泛型类的时候也可以加`类型名<? extends T>`，但这类似于C#的泛型约束
  * 比C#更灵活，因为可以不用类作者更改代码。
  * 例子
    * `List<? extends String>`表示只读集合，但仍能调用set(null)；逆变可表示只写集合，仍能用get()但只能赋给Object
    * `static <T> void copy(List<? extends T> src， List<? super T> dest)`：不修改src，不读取dest
  * `<?>`既不能读也不能写，只能做一些null判断，是所有`<T>`的超类。一般用泛型方法代替
* 泛型约束：类的泛型定义中`<T extends R>`

## 数组和容器

```java
import java.util.*;

String[] arr = asArray("one", "two", "three");
Arrays.toString(arr); // 数组转字符串，结果类似Py；二维数组int[][]用Arrays.deepToString()
Arrays.sort() // 升序排序，需要元素类型实现Comparable<T>
Arrays.copyOf() // 浅拷贝
System.arraycopy() // 相当于memcpy的高效方法
int[]转Integer[]好像只能用stream
for(final int item: arr) // foreach，也可用var

List<Integer> lst = new ArrayList<>(); // 不接受数组作为参数，只接受其它容器，会浅拷贝
lst = List.of(1, 2, 3); // 只读，set运行时报UnsupportedOperationException，想写可再传给ArrayList的构造函数；也能传Integer[]对象转List，不是包装，仍只读，但不能是int[]；copyOf接受其它容器；不要用Arrays.asList，是包装且非只读且不是普通的ArrayList
Integer[] arr = lst.toArray(Integer[]::new); // 或new Integer[0]，实际是复制到实参数组中，长度短了会自动扩展，长了的会设为null；无参使用只返回Object[]
lst.add()/remove()/get()/set()/removeIf() // 不能用[]获取元素
Collections.sort(lst)

Map<String,Integer> map = new HashMap<>(); // 还有Map.of(k1,v1,k2,v2)或Map.ofEntries(...)。不要用双大括号来初始化
map.put(...)/get()/containsKey()/keySet()
for (Map.Entry<String,Integer> entry: map.entrySet())
Map<DayOfWeek, String> map = new EnumMap<>(DayOfWeek.class); // Key是枚举时用此类效率最高
// SortedMap = TreeMap：红黑树，类型必须实现Comparable

Deque<T> dq = new ArrayDeque/LinkedList<>(); // 替代Stack，提供push()/pop()/peek()，对应dq的xxxFirst；也继承了Queue，对应dq的xxxLast
dq.addFirst/Last()/remove()/get()失败时抛异常，offer()/poll()/peek()失败时返回false或null，因此避免把null添加进去

// 重写equals和hashCode，@Override略。List/Set.contains()，Map.get()等会用到；hashCode对于相同对象一定要相等，不同对象尽量不等
public boolean equals(Object o) {
    if (o instanceof Person p)
        return Objects.equals(this.name, p.name) && this.age == p.age;
    return false;
}
int hashCode() {
    return Objects.hash(firstName, lastName, age);
}

Collections.reverse() shuffle()
LinkedHashMap：遍历时能按插入顺序
PriorityQueue：需要对象实现Comparable接口，取出时小的在前面

不用的：
Collections.synchronizedList、Vector：Java5后用java.util.concurrent
Collections.unmodifiableList：包装普通的List，拦截修改
Hashtable：线程安全的HashMap，没必要用。哈希表用HashSet
Properties：用于读写.properties文件。load(getClass().getResourceAsStream("/default.properties")); //从jar包或classpath中读取资源)
```

## IO

* 各种流读文件时都要关闭，可用try(resource)；如果用了包装，最外层的关闭即可
* Filter模式，接受一个InputStream，仍返回该类型，但内部已经包装了，减少继承链
* Scanner和老的流的默认编码受file.encoding影响，默认为代码页，读文件时记得指定编码
* 第三方库：okio

```java
System.out.print()/println()/printf()
var scanner = new java.util.Scanner(System.in);
scanner.nextLine()/nextInt()/next()默认以空格分隔返回String。findAll("xxx").map(MatchResult::group)、findInLine()
System.console().readLine()/readPassword()

import java.io.*;
try (InputStream ins = new FileInputStream("readme.txt"/FileObj)){ ... } // 字节流无需设定编码，一般还加一层BufferedInputStream，之后可用Scanner
ins.transferTo(os)
Reader reader = new FileReader("readme.txt"/FileObj, StandardCharsets.UTF_8)/StringReader("Hello")/InputStreamReader(ins, "UTF-8");
var br = new BufferedReader(reader); br.readLine(); // 这样才能读一行
PrintStream：属于OutputStream，支持一组print()/println()打印各种数据类型，System.out就是；一般用PrintWriter包裹其他Writer来用
ByteArrayOutputStream 内存字节流。StringWriter 可toString()

import java.nio.file.*; // 替代File，默认编码UTF_8，不跟随系统
Path p = Path.of("..", "project").toAbsolutePath().normalize();
String content = Files.readString(p.resolve("data.txt")); // readAllLines()/readAllBytes()/writeString()/newInputStream()
Files.lines()/list()/walk() // 返回stream，需要关闭但可用在try()中
Files.newDirectoryStream() // 等于list但可foreach，需要关闭
Files.newBufferedReader(p).readline()
Files.exists()/isRegularFile()/isDirectory()
```

## 函数式

* 接口
  * 单方法接口（但可有默认方法）用`@FunctionalInterface`注解，可用Lambda表达式代替匿名类`(s1, s2) -> s1.compareTo(s2)`
  * 方法引用：用双冒号。可引用实例方法，则相当于隐式添加第一个参数this，如`String::trim()`，C#做不到
* java.util.stream.Stream
  * 惰性，链式map().filter().sorted().limit().distinct()，聚合操作才进行计算.sum()/reduce()
  * stream转List和其它：collect(Collectors.toList()/toSet()/toMap()/joining())，toArray(String[]::new)，直接toList()是不可变的。Collectors.groupingBy(Function.identity(), Collectors.counting())转为Map
  * parallel()自动多线程，concat()连接两个stream，flatMap()把`stream<List<T>>`变成`stream<T>`相当于SelectMany，mapMulti允许处理每个元素
  * map.entrySet().stream().max(Map.Entry.comparingByValue())
  * anyMatch() allMatch()
  * mapToObj() mapToInt()：普通的map()传lambda时没有问题，但无法直接接受函数，会无法推断类型
* Arrays.stream(arr)返回IntStream能提高效率，它toArray()能返回int[]；普通的装箱stream转它用mapToInt(Integer::valueOf)，它转装箱的用boxed()
* `Optional<T>`：原意是替代null，返回空时用Optional.empty()，一定有值时用Optional.of()，如果值为null会抛异常，调用方用isPresent()判断是否有结果，get()获得结果，但它不可序列化。实际一般用ofNullable包裹原来的可能为null的值，之后用类似stream的API链式处理，关键是中间如果存在null不会抛异常，只会视为empty()，最后用ifPresent()或orElse(null)/orElseGet(fun)/orElseThrow()
* 无法方便地从Iterable转换成Stream，只能`StreamSupport.stream(it.spliterator(), false)`，Guava实现了；Stream转Iterable可以强转s::iterator，但还是很麻烦
* `Predicate<T>`：可以把多个函数用and() or() negate()串联起来，还有not()静态方法，isEqual()静态方法
* Objects::isNull、nonNull；Character::isAlphabetic、toLowerCase
* foreach：不能用(i->sum+=1)因为要求闭包的变量是final的

## 反射

* java.lang.reflect.*
* Class cls = String.class; / int.class / s.getClass(); / Class.forName("java.lang.String"); 其中前几个实际上是泛型，在调用newInstance()时能返回T，否则只会返回Object
* Field f = getField(name)根据名字获取包括父类的公共字段，getDeclaredField(name)不包括父类但可获取私有字段，getFields()略；f.setAccessible(true)后f.get(o)可访问私有字段
* getMethod(), getReturnType(), getParameterTypes(), getModifiers(), invoke()：略
* getConstructor(构造函数的参数对应的clazz).newInstance()
* getSuperclass(), getInterfaces()
* obj instanceof String s；cls.isAssignableFrom(cls2)。nullobj instanceof xxx -> false
* 引入泛型后有xxxType与Class继承Type

## HttpClient

* 第三方库：okhttp retrofit，同一组织出的，后者用于把restapi封装成易使用的类

```java
var client = HttpClient.newHttpClient();
var request = HttpRequest.newBuilder()
    .uri(URI.create("https://javastack.cn")).GET().build();
// 同步
HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
System.out.println(response.body());
// 异步
client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
    .thenApply(HttpResponse::body)
    .thenAccept(System.out::println);
```

## 正则

```java
var p = Pattern.compile(...);
var m = p.matcher(str);
m.matches();
m.group(n);
Pattern::asPredicate // 用在filter中
```

## 日期和时间

* 时间戳：System.currentTimeMillis()，类型为long的毫秒。另外long字面量要加L后缀
* java.time新API：Month的范围是1-12，Week的范围是1-7表示周一到周日
* LocalDate .now() .of(年,月,日) .parse("2019-11-19")
* LocalTime .now() .of(时,分,秒) .parse("15:16:17")
* LocalDateTime .now() .of(d,t) .of(年,月,日,时,分,秒) .parse("2019-11-19T15:16:17"); dt.toLocalDate() .toLocalTime()
* 链式运算：dt.plusDays(5).minusHours(3).withYear().withDayOfMonth().with(TemporalAdjusters.firstDayOfNextMonth())
* 比较：dt.isBefore/isAfter(target)
* 两个DT的差值：Duration.between(start, end)/ofHours(9)，转换为字符串后类似PT1235H10M30S表示1235小时10分钟30秒；两个Date的差值：d1.until(d2)，Period类型，类似P1M21D表示1个月21天
* DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
  * dtf.format(dt); dt.parse("...", dtf); dtf.withLocale(lo)
  * M为9，MM为09，MMM为Sep，MMMM为September
  * E表示英文星期如Sun，EE表示中文星期，使用时第二个参数传Locale.US/CHINA
  * ZZZZ表示时区，如GMT+08:00
  * 预定义了几个静态格式，如.ISO_DATE.format(dt)、.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT)
  * 默认按照ISO 8601处理
* ZonedDateTime
  * .now() .now(ZoneId.of("America/New_York")) 是同一时刻
  * dt.atZone(ZoneId.systemDefault()/ZoneId.of("America/New_York"))) 给LocalDateTime附加时区，时间不变，时区不同，不是同一时刻
  * zdt.withZoneSameInstant(ZoneId.of("Asia/Shanghai")) 时刻不变，转换时区，转换时间，再.toLocalDateTime()就丢掉了时区
* Instant.now()
  * ins.getEpochSecond() 秒，.toEpochMilli() 毫秒
  * ins.atZone(...) ZDT.ofInstant(ins, ZoneId.of(...)) 时刻转ZDT
  * Instant.ofEpochMilli(milli) 时间戳转时刻
* java.util旧API：Date Calendar TimeZone。旧转新：对前两者实例使用.toInstant()再变成ZDT，后者用.toZoneId()

## 其它内置库

* Math：略
* java.math.BigInteger：创建用new，运算用实例方法，转换成基本类型用.longValueExact()
* BigDecimal：scale()表示小数位数，负数表示是整数且末尾有0，setScale()指定小数位数和舍入方式；加减乘时精度不会丢失，但除法除不尽时要指定精度和如何截断；divideAndRemainder()可以做除法的同时求余数；equals()要求值和scale()都相等，一般应该用compareTo()，或先用stripTrailingZeros()
* JavaEE的javax名称空间现在变为了jakarta，不过还是有几个类在前者里
* 随机数：Random类；java.security.SecureRandom.getInstanceStrong()，一般用nextBytes填充buffer。JDK17：RandomGenerator.getDefault()

## Maven

* 主用GUI，手动只辅助
* 添加依赖：在仓库搜索想要的包后看示例添加进pom，没有命令行添加的功能，之后mvn dependency:resolve
* 默认依赖包存放位置：$HOME/.m2/repository
* 仓库：https://search.maven.org/ https://mvnrepository.com/
* 镜像：https://maven.aliyun.com/mvn/guide
* 初始化：mvn archetype:generate -B -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-quickstart -DgroupId=com.company -DartifactId=project -Dversion=1.0-SNAPSHOT -Dpackage=com.company.project。会生成project文件夹，里面有pom.xml和src文件夹，无法直接在CWD生成
* 运行：mvn exec:java -Dexec.mainClass=com.company.project.App
* 编译打包jar：mvn clean package：默认到target目录，其实是从clean阶段运行到package阶段。一般还有compile和test
* 编译时若提示”不再支持源选项 5“，往pom的properties里添加`maven.compiler.source`和target为17
* dependency.scope：默认是compile表示编译时需要用到该jar包，还可以是test如junit、runtime如mysql-connector、provided如servlet-api
* 插件：https://spotbugs.github.io/
* TODO: https://www.runoob.com/maven/maven-tutorial.html

## GC调优

* G1默认最大暂停200ms
* 现在64位的JDK只有Server模式，-client参数会直接忽略
* -XX:+UseShenandoahGC：目标是替换g1，吞吐量大，适用于Web服务端。目前OpenJDK和OracleJDK的编译版都不包含
* -XX:+UseZGC：延迟低，最好设置mx；CPU负荷最好小于70%
* -Xmx512m：最大堆大小；ms是最小和初始堆大小
* -XX:+UseLargePages：大内存如16G时启用，还需设置/sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages，值至少为16G/2M=8192
* -XX:+AlwaysPreTouch：启动jvm时真实分配那么多内存，能减少延迟卡顿
* -Xlog:gc+stats：显示当前使用了哪种GC以及运行过程中的调用情况
* -XX:+DisableExplicitGC：避免用户乱调用System.gc()
* -XX:SoftMaxHeapSize=1G：尽量不要超过此值规定的最大堆大小，仅限ZGC
* -XX:+UseStringDeduplication 在GC时合并重复的字符串
* 不进行GC：-XX:+UnlockExperimentalVMOptions -Xlog:disable -XX:+UseEpsilonGC
* 查看当前选项包括所使用的GC模式：java -XX:+PrintCommandLineFlags -version，查看包括默认值在内的所有选项：-XX:+PrintFlagsFinal

## Gson

* 其他JSON库：Jackson，Spring使用的。moshi，okhttp组织出的

```java
import com.google.gson.Gson;
Gson gson = new Gson();
Gson gson2 = new GsonBuilder().serializeNulls().create(); // 默认序列化时会忽略值为null的
gson.toJson(obj);
gson.fromJson(jsonstr, clazz.class/int[].class/new TypeToken<Map<String, String>>(){}.getType())

类字段注解：@SerializedName、@Expose
TODO: https://www.studytrails.com/2016/09/12/java-google-json-introduction/
```

## 日志

* TODO: google/flogger logback

```java
// java.util.logging
Logger logger = Logger.getLogger(Main.class.getName()); // 或System.getLogger()
logger.severe warning info config fine finer finest // 默认LEVEL是INFO，会记录INFO及之上的
throwing(String className, String methodName, ex)
logger.addHandler(new FileHandler()) // 文件的默认格式为XMLFormatter，冗余信息较多。控制台默认为SimpleFormatter
```

## JUnit

* 测试代码文件名：xxxTest.java
* assertEquals()比较浮点数时有一个重载指明精度
* assertTrue() assertFalse() assertNotNull() assertArrayEquals()
* @Disabled：临时禁用，仍识别为测试方法，只是会跳过。@EnabledOnOs(OS.WINDOWS)，@EnabledIfEnvironmentVariable(k="v")

```java
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

public class FactorialTest {
    @Test
    void testFact() {
        assertEquals(1, Factorial.fact(1));

        assertThrows(IllegalArgumentException.class, () -> {
            Factorial.fact(-1);
        });
    }

    @ParameterizedTest
    @ValueSource(ints = { 1,2,3 })
    void testAbs(int x) {
        assertEquals(x, Math.abs(x));
    }

    @ParameterizedTest
    @MethodSource // 从一个同名的静态函数中提供参数。还支持@CsvSource和@CsvFileSource
    void testXXX(int a, int b);
    static List<Arguments> testXXX(){
        return List.of(
            Arguments.arguments(1,2),
            ...
        )
    }

    // Fixture：做准备和清理工作。还有@BeforeAll和@AfterAll在所有Test前后运行一次，但只能标注静态方法
    @BeforeEach // 每个Test都运行一次
    public void setUp() { ... }
    @AfterEach
    public void tearDown() { ... }
}
```

## 第三方库

* jsoup：HTML请求和解析库，支持css选择器
* Springboot，等3。spring data jpa。https://www.liaoxuefeng.com/wiki/1252599548343744/1266263217140032
* mybatis：把连接字符串和SQL都写在xml中
* guava：不可变集合、检查非空、Multiset/map、自定义行为的字符串Splitter和Joiner、简单的缓存类
* netty：代替nio做socket编程
* zxing：等学安卓再说，而且它现在处于维护模式
* hutool：国产工具库，农历、汉字转拼音、身份证合法性、定时任务、图形验证码、Excel操作、RSA加解密、哈希

## TODO

* https://www.liaoxuefeng.com/wiki/1252599548343744/1255945288020320
* 线程池：execute无返回值直接抛出异常，submit返回Future，之后再get获取返回值或抛出异常
* https://github.com/Snailclimb/JavaGuide 看：CAP 理论和 BASE 理论解读、何为限流？限流算法有哪些？、并发
* https://dev.java/learn/ https://github.com/doocs/advanced-java https://www.baeldung.com/java-tutorial https://books.trinket.io/thinkjava/ https://programming.guide/java/
* JEP 412 新的调用本地函数的API，还在孵化
* javadoc：http://www.herongyang.com/Java-Tools/javadoc-The-Java-Document-Generator.html
* java.util.concurrent java.util.function
* 数据库：jOOQ、HikariCP
* http://www.monkey1024.com/javaseroute
