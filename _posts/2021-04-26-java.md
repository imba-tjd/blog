# Java

## 环境

* JDK
  * https://jdk.java.net
  * Eclipse Temurin：https://adoptium.net/ 提供Win下x86版本，还提供EA版。Docker：eclipse-temurin:17-jdk-alpine
  * Liberica：https://bell-sw.com/pages/downloads/ 提供Lite版（通过jlink创建的）和带FX的Full版，有32位。还有NativeImage版、Docker镜像
  * 镜像：https://www.injdk.cn 收录了不少版本的build，还有Graal
  * OpenJ9/Semeru：https://developer.ibm.com/languages/java/semeru-runtimes/downloads/ 不基于OpenJDK VM，内存占用更小，启动时间可能更长，但开启AOT后再次运行有缓存
  * Debian：openjdk-17-jdk openjdk-17-jre
  * Oracle GraalVM：闭源但商用免费（和OracleJDK一样的协议），且具有一部分GraalVM CE没有的功能。默认生成的代码要在支持AVX的CPU上运行
  * Oracle免费协议：https://www.oracle.com/be/java/technologies/javase/jdk-faqs.html
  * https://www.microsoft.com/openjdk 基于Adoptium的，JDK11有一些未合并到上游的修改，基本没啥用
* VSC
  * 扩展
    * Language Support for Java
      * java.jdt.ls.java.home
    * Debugger for Java 不调试可以不用
    * Project Manager for Java 还有一个maven的扩展
    * Test Runner 执行单元测试
    * SonarLint
    * Oracle的Java Platform Support：基于netbeans，不使用
  * 裸依赖的jar放在lib文件夹里，或者调java.project.referencedLibraries
  * 出现is not on the classpath of project, only syntax errors are reported，用F1 Java: Clean the Java language server workspace
  * launch.json: stepFilters(justMyCode功能)默认跳过JDK和junit
  * 自动删除未使用的import："editor.codeActionsOnSave": { "source.fixAll": true, "source.organizeImports": true }, "editor.formatOnSave": true
* Docker：openjdk和java的deprecated了。可以用eclipse-temurin，还有alpine版
* JAVA_HOME：当存在多个JDK时，设置此环境变量可用想要的版本。已知Java8的java.exe不会检测它，maven会优先使用它
* 运行时查看版本：System.getProperty("java.version")
* EClipse
  * 最后一个32位版本是2018-09(4.9)
  * 中文：Help-InstallNewSoftware，必须找语言包网址添加，选Language Pack for eclipse in Chinese (Simplified)
  * 单元测试：右键项目的package-新建-JUnit测试用例，会自动添加JUnit到构建路径中。右键XXXTest.java，运行方式RunAs
* IDEA
  * 默认修改POM后必须手动点击按钮重新加载，Maven的设置里选“所有更改”可自动重载
  * 设置-编辑器
    * 常规 - 自动导入 - 自动优化import
    * 文件编码 - Properties文件：改为U8，否则存在中文时会乱码，好像只有Java8及之前要改
    * 常规 - Move code fragments with drag-and-drop 关掉
    * inlay hints - Types：显示var的类型
  * 保存时自动格式化：Tools - Actions on Save
  * 帮助-更改VM选项：调整最大内存，默认2GB有点小、使用ZGC
  * HTTP客户端支持保留cookie，不同测试之间用三个井号分隔
  * Build工具 - Docker - compose - 使用V2
  * 最后一个支持32位的版本：2021.1。需要在安装程序里联网下32位的jdk
  * 插件：禁用code with me
  * 更改使用的JRE：Ctrl+Shift+A，Choose Boot Java Runtime for the IDE
  * Profiling：打开Profile窗口可以在运行的时候记录，不用从头开始运行
  * 调试器 - Stepping步进 - Skip Simple Getter
  * Logging breakpoint：不中断，只打印日志，代替print调试之后又要去掉的问题
  * 切换选项卡：Alt+左右。扩大选区：Ctrl+W。历史剪切板：Ctrl+Shift+V。调试时评估表达式：Alt+左键。多光标：Shift+Alt+左键。最近打开的文件：Ctrl+E。光标返回上一处位置：Ctrl+Alt+左
* DataGrip
  * “数据库更改”窗口：可以将未提交的所有修改统一显示。之后可选择变为SQL脚本还是直接提交
  * 数据源
    * DDL数据源：解析sql文件中的DDL语句，显示为类似于真的有数据库的样子
    * 数据选项中的“只读”：操作生产数据库时可以用
    * 显示表之间的关系：右键-Diagrams
    * 复制数据源到剪切板：产生JB系IDE可以解析的含有连接字符串的纯文本
    * SQL Generator：创建生成此数据库的DDL
    * 运行SQL脚本：不要在SQL编辑器中运行，极慢
  * SQL编辑器
    * 替换SELECT *为具体列：Alt+Enter。修改Join的别名后也可以自动更改
    * 运行光标所在语句或选择(拖黑)区域：Ctrl+Enter
    * 评估表达式：Alt+左键
    * 给查询命名：在SELECT上方加注释
    * 最后一个按钮“编辑器内结果”：使得SELECT的结果就显示在语句下方
  * 数据查看窗口
    * 默认是以500条分页的，Ctrl+F本地搜索只会搜索当前页的。另外数据编辑器的Filter就是WHERE而不是本地搜索
    * 修改提交如果出现错误，可以右键一行或一个数据Revert再提交
    * 查看某一id数据关联的其它数据：右键 - Go to - Related Data。可以从主键找外键，也可以反过来
    * Data Extractor：复制和导出支持csv、json、INSERT语句，支持将查询出来的数据导出到另一个数据库的新表。导入支持csv
    * 选择要显示的列：右键列 - 列列表 - 用空格切换
* API文档：https://docs.oracle.com/en/java/javase/21/docs/api/index.html

### 命令行

* 编译
  * javac -Xlint -g -cp lib.jar:pkg/* -d bin src/com/xxx.java，编译成bin/com/xxx.class（实际是因为package语句）
  * 若CWD为src，用 -d ../bin com/xxx.java
  * linux可用 `src/**/*.java`
  * 为老JRE编译 --release 8 要求源码只能用JAVA8的，不会检查库兼容性
  * Win的cp分隔符为分号
  * 不加-g只是没有局部变量调试信息，仍有行号和源文件信息
* 运行class：java -cp a.jar:pkg/*:bin com.Main，即指定main()所在的完整类名，不是指定.class文件
  * cp默认为.（CWD）
  * 运行选项必须在运行目标前，可用JAVA_TOOL_OPTIONS环境变量设置，对运行jar也有效
    * -ea启用assert语句
    * XX:+ShowCodeDetailsInExceptionMessages空指针异常时显示更详细的信息，但JDK15后默认启用了
  * java命令行现在也能直接运行xxx.java，但好像无法导入模块化的依赖，且main()所在的类必须是第一个
* 打包jar cvf out.jar -C bin .
  * 其中f指定输出的文件，C更改工作目录
  * 列出jar中的文件：jar tf out.jar。显示模块化jar的依赖：df
  * 打包完成的jar的根就是com等，不是bin
  * 还可以打包出含有入口点的jar，用cef com.Main out.jar。然而如果依赖其它jar包，则必须手动创建MANIFEST.MF，写Classpath属性。运行时加-cp无效
  * 运行含有入口点的包：java -jar out.jar args
  * Error: Unable to access jarfile a.jar：看看是不是不存在a.jar
* 模块化
  * 目的：jar是class的容器，但并不关心jar之间的依赖。如果运行时少了某个需要的jar就会出问题。模块化是使得一个jar能够自动找到依赖的jar
  * 创建和com平级的module-info.java，都放在src下：`module 模块名{requires 模块名; exports 模块名;}`，隐式导入了java.base，其余的import了的库必须在这里声明，别的库想访问本模块的类（如反射）则必须在这里声明导出
  * 模块名与pkg名不必相同，一个模块可以包括多个package，一个jar只能有一个模块，自己的.java不能和module-info平行
  * 编译：普通地编译module-info即可。依赖的库可用-p pkg直接指定文件夹了；另一种方式是用-m 模块名 --module-source-path src。之后生成jar没区别
  * 运行：java -p pkg;out.jar -m 模块名，或-p bin -m 模块名/完整类名（此处的斜杠为字面量）
  * 生成jmod：jmod create --class-path out.jar或bin out.jmod。无法简写成cp，当out.jmod已存在时不会自动覆盖，生成的out.jmod无法运行，仅用于生成jre，感觉没啥用，不如jlink时直接指定.jar或pkg
  * 生成jre：jlink -p out.jmod --add-modules java.base,模块名 --output jre --strip-debug/-G --compress=2/-c=2 --no-man-pages --no-header-files。之后可用jre/bin/java -m 模块名 运行，或先用--launcher创建启动脚本。其中add-modules的内容用jdeps分析。JDK21推荐改用-c=zip-9。TODO: 不清楚怎么加依赖，需不需要把依赖的jar转换成jmod
  * 分析依赖：jdeps xxx.class或--module-path out.jar;pkg -m 模块名
* jshell JAVASE：REPL，且自动导入所有标准库
* jpackage -n 项目名
  * 模块化项目：-p 模块路径 -m 模块名/完整类名
  * 非模块化项目：-i bin --main-jar out.jar
  * 创建含有jre和本项目exe的文件夹：-t app-image
  * 创建带有图形界面的安装程序，Win下还要装Wix：--win-dir-chooser --win-console --win-shortcut --icon i.ico
* jdeprscan dir/jar/class：扫描是否使用了废弃的API，设置--release 8可得到尽量少的结果。另一种做法是jdeps -jdkinternals
* keytool
* 分析工具
  * jps：显示哪些java程序正在运行
  * jinfo：显示系统属性和VM配置，还能更改VM配置
  * jmap：诊断内存问题，如内存泄漏，可以生成heapdump
  * jstack：显示调用栈。-l可显示死锁信息
  * jcmd：JFR工具，用于Profile。-l列出正在运行的Java程序
  * jconsole：GUI工具
  * JMC：openjdk出的JFR工具
  * async-profiler：生成火焰图
  * VisualVM：Oracle出的
  * JMH：benchmark
  * MAT：基于Eclipse的内存分析工具

### 编码

* 源代码不支持UTF8-with-BOM
* javac -encoding utf8 -d bin Main.java：源文件用u8编码
* java -Dfile.encoding=gbk -cp bin Main：设定运行时编码
* JDK17及之前file.encoding和javac默认为代码页；JDK18默认为U8。改回原行为用=COMPAT，取得代码页编码用System.getProperty("native.encoding")或System.console().charset()
* 如果直接用java命令行运行.java，file.encoding就也影响硬编码字符串的编码了，Win下就一定存在问题
* 用PS时file.encoding要加引号

## 语法

* import导入类，可以用*，默认导入了java.lang.*
* package类似命名空间，顺序要与文件夹匹配；但不同maven包可以有相同的package，且内容感觉会合并，类似于Py的命名空间包。再加上幽灵依赖，用起来非常混乱了
* 一般一个文件只有一个public类，且要与文件名匹配
* 函数参数不能有默认值；可变参数数组用`元素类型...`定义
* 异常：Error是严重错误，除RuntimeException以外的异常是Checked Exception，一定要捕获，或在方法参数签名后加throws xxx，可加在main上；catch时可用`|`同时处理多个异常类型，C#无此功能
* break和continue支持跳转到label处以跳出多层循环，但label必须紧贴循环语句前边，相当于对那一个循环做break或continue。不支持goto
* byte是有符号的，而C#是无符号的
* main：所在的类不必为public的，参数必须为String[]
* 所有的包装类都是Number抽象类的子类，不可变，用intValue()解包成int

### switch和模式匹配

```java
// 只记录java14的，不需要写break
String fruit = "apple";
int opt = switch (fruit) { // 表达式，有返回值
    case "apple" -> 1;
    case "pear", "mango" -> 2;
    case String s when !s.isEmpty() -> ... // 类型匹配+守卫，且null不会匹配进去。一般还需要一个同类型+无守卫的用于穷尽
    case null -> ... // 目前正在preview。传统上如果对象是null，会在switch一开始就抛NPE
    default -> { // sealed的接口无需此句
        int code = fruit.hashCode();
        yield code;
    }
}; // 要有分号

if(!(o instanceof String s))
    return;
// 运行在这个范围内使用s。但如果if中又用了o就不行了

o instanceof Point(int x, var y) // 匹配record，绑定多个变量，JAVA21
for(Point(...): points) // JAVA20
```

## 字符串

* 多行字符串为三个双引号，开始时必须要换行且此换行不算内容，以结束时的引号为对齐基准去掉前面的缩进，转义仍有效，不支持raw string
* 其它类型转换为字符串：String.valueOf
  * Integer.toHexString整数转为十六进制字符串无前缀。还有toBinaryString
* 字符串转为其它基本类型：Integer.parseInt，可设定基数，值的部分必须只是值。Integer.decode()支持解析前缀
  * Integer.getInteger与System.getProperty一样，是获得系统属性的值，垃圾命名
* 判断相等用equals；推荐用Objects.equals()，不用判断是否为null
* 取字符必须用charAt()，不支持索引器
* 函数
  * contains、[last]indexOf、startsWith、substring、isEmpty、isBlank
  * replace、replaceAll 正则、split 正则
  * strip[Leading/Trailing] 如果只有ASCII字符也可用trim
  * formatted/String.format C风格，也可都用%s
  * toCharArray、getBytes 转为字符串用构造函数，第二个参数指定编码，默认是file.encoding的
  * lines 按换行符分隔返回Stream
  * chars 变为Stream。codePoints 按码点变为Stream
* StringBuilder：和C#一样，不线程安全，但delete方法第二个参数是index而不是length；StringBuffer更老单线程性能差多线程安全
* java.text.MessageFormat.format()：类似C#，但模式要先new出来
* String.valueOf(nullobj)为"null"，C#为""
* StringJoiner：支持设定开头、结尾、分隔符。new出来，add，toString。一般String.join()更方便
* 正则：java.util.regex.Pattern.compile("...", MULTILINE); p.matcher(text).results().map(MatchResult::group)

## 类

* 复用构造函数在函数体内用this()；调用父类成员用super
* 类和接口的继承：extends关键字。实现接口：implements关键字。abstract class可以有字段
* 接口：可以有字段，隐式public static final。接口里的函数可以在声明前面用default关键字实现默认方法，但不能访问字段，可以访问私有方法
* 重写：@Override。默认public函数都是虚函数，这个注解只是帮助检查
* final关键字：用在未初始化的字段上和参数上相当于C的const，用在初始化了的字段上相当于C#的const，用在函数上会阻止重写（private函数都隐式final），用在类上阻止继承
* 没有访问修饰符的类和字段为package包作用域，能被同包的普通类和public类使用，无需import，不会被其它包import，等价于C#的internal；protected等价于C#的protected internal
* 内部类
  * 普通类不能用private，内部类才可以
  * 如果内部类没有private，就也为包作用域，但在外部使用必须从外部类的对象实例化：`Outer.Inner inner = outer.new Inner()`
  * 用static修饰内部类就不再依附外部类对象了，且仍可实例化new Outer.Inner()，编译后就是不相关的两个类。不存在C#的静态类的概念，外部类无法加static
  * 内部类对象内部能直接访问外部类对象：`Outer.this.xxx`，能修改外部类的private成员。外部类对象在类种也能访问内部类的private成员
  * 可用于Lazy单例模式：静态内部类创建final static instance=C()，外面定义getInstance()返回inner.instance
* 匿名类：`var obj = new 接口名或父类名(){类成员代码}`，用于一个类中包含另一个类，且省去定义内部类再实例化。C#无此功能
* 对象初始化器：在类定义里裸写一个{}，会在每次普通构造函数前调用，能访问实例成员，当多个构造函数具有相同逻辑又怕忘了手动调用复用时可用
  * 双大括号：其实就是匿名类加对象初始化器。但由于能访问new了obj的类里的对象，如果将obj作为返回值传出去，有可能导致资源无法被释放
* 静态代码块：`static {...}`，类似于C#的静态构造函数
* static成员可通过实例对象使用，且对象为null也可以，不过会有Lint警告
* record Point(int x, int y) {}
  * 定位是命名元组，不是用于封装数据的
  * 自动生成构造函数、不可变成员、toString、equals、hashCode
  * 检查范围：public Point{if(x<0) throw new IllegalArgumentException();} 称为Compact Constructor，写不含参数的构造函数且无需自己给成员赋值
  * 在模式匹配中可用类似于构造函数的语法解构成员并使用，且可用var
* enum枚举：可用==比较两个对象，可定义方法，可在类中用`实例名(参数),实例2;`创建枚举常量对象。E.values()获得所有实例，valueOf("实例名")或Enum.valueOf(clazz, "实例名")从字符串转换，e.name()与未重写时的toString()相同，ordinal()略
* 让类支持try-with-resources：实现AutoCloseable接口的close()
  * Finalize()废弃了，用Cleaner机制替换。本质就是在另一个实现close()的类里注入本类（或者也可以实现在本类里），try(那个cleaner对象)。主要是可以一次性register多个，一起clean掉，以及在另一个线程运行资源回收
* Objects.requireNonNull(obj)
* JavaBean：getXXX、setXXX。boolean字段的getter的命名为isXxx
* 密封类，当业务上需要处理接口的每个实现时使用：sealed interface Ixx permits Xxx, Yyy
* 注解
  * 创建：@interface A{int i() default 0; String value() default "";}
  * 还可加@Target指定注解能用在什么上。@Retention指定生命周期，默认为CLASS，一般要改成RUNTIME。@Repeatable允许重复使用。@Inherited使用时子类可以继承父类使用的
  * 应用：@A("value的值", i=123)
  * 反射读取：C.class.isAnnotationPresent/getAnnotation(A.class);

## 泛型

* 泛型方法
  * 与C#相比`<T>`需放在返回值前。调用时显式指明类型时放在方法名前
  * 静态泛型方法可声明于泛型类中，但调用时无需也不能具体化泛型类，实际与泛型类的泛型无关系
* 类型擦除
  * 不能放基本类型
  * 泛型方法自动推断时会转换成对应的包装类型
  * `C<A>.class == C<B>.class == c.getClass() == C<Object>.class`
  * 不能new T()因为相当于new Object()。变通手段是创建带有Class参数的函数，反射创建实例
  * 重载：无法声明`f(C<A> c) f(C<B> c)`方法重载。public boolean equals(T t)会变成equals(Object t)导致与继承自Object的冲突
  * 不能判断带泛型的类型：`o instanceof C<Object>`编译错误，只能用`C`或`C<?>`
  * 不能new泛型类型数组`new List<Integer>[5]`，只能`@SuppressWarnings("unchecked") List<Integer>[] l = new List[5]`。或用反射创建：(T[])Array.newInstance(cls,5)。可以创建基本类型数组的泛型类，因为数组是引用类型`new List<int[]>()`
  * 类的静态字段类型不能是T
* 泛型约束：泛型定义中`<T extends R>`
  * extends A & B：取二者子类型的交集，同时实现了AB接口
  * 如R用`Comparable<T>`，则t就可以调用compareTo()
* 可变性
  * 使用者写在函数参数或变量的类型**声明**后，可直接用于类；不是放在类和接口的定义上。编译器根据此变量的方法中T所在位置限制允许使用的方法
  * 协变用`类型名<? extends 具体类型>`，称为上界通配符；逆变用super
  * 如Animal是Dog的父类，如果f(Animal)是f(Dog)的父类，则称为协变；如果是子类，则称为逆变。此处的f表示某种变换
  * 比C#更灵活，因为可以不用类作者更改代码
  * 例子
    * `List<? extends String>`表示只读集合，但仍能调用set(null)；逆变可表示只写集合，仍能用get()但只能赋给Object
    * `static <T> void copy(List<? extends T> src， List<? super T> dest)`：不修改src，不读取dest
  * `<?>`unbounded wildcard type无限定通配符
    * 作为协变时与`<? extends Object>`同义，同时也是所有逆变的父类
    * 其变量可做null判断，可get为Object，可set(null)
    * 一般可用泛型方法代替
    * `Class<?>`中用到。还有List.size() clear()，因为这些方法不依赖T

## 数组和容器

```java
import java.util.*;

String[] arr = {"one", "two"};
Arrays.toString(arr); // 结果类似Py；二维数组int[][]用Arrays.deepToString()
Arrays.sort()/parallelSort() // 升序排序，需要元素类型实现Comparable<T>。排序方式：基本类型为快排，对象类型为归并排序稳定，Stream的sorted()同理
Arrays.copyOf() // 浅拷贝，第二个参数可用于数组扩容。copyOfRange()可用于得到subarray
Arrays.Equals()
System.arraycopy() // 相当于memcpy的高效方法
int[]转Integer[]：Arrays.stream(arr).boxed().collect()
for(final int item: arr) // foreach，也可用var

List<Integer> lst = new ArrayList<>(); // 不接受数组作为参数，只接受其它容器，会浅拷贝
lst = List.of(1, 2, 3); // 只读，set运行时抛异常，想写可再传给ArrayList的构造函数；不要用Arrays.asList，是包装且非只读且不是普通的ArrayList，除非是Java8；lst.subList()返回的是一个内部类的视图，且父列表增加删除后不能再用子视图
List.of(Integer[])、List.copyOf(其它容器) // 非包装
Integer[] arr = lst.toArray(Integer[]::new); // 或new Integer[0]，实际是复制到实参数组中，长度短了会自动扩展，长了的会设为null；无参使用只返回Object[]
lst.add()/remove()/get()/set()/removeIf() // 不能用[]获取元素。会自动增长但删除后不会自动收缩，手动收缩用trimToSize()

Map<String,Integer> map = new HashMap<>(); // 还有Map.of(k1,v1,k2,v2)或Map.ofEntries(...)。不要用双大括号来初始化。Java8可用Guava的ImmutableMap.of()或.builder().put(k1,v1).build()
map.put(...)/get()/containsKey()
for (Map.Entry<String,Integer> entry: map.entrySet()) // keySet()
Map<DayOfWeek, String> map = new EnumMap<>(DayOfWeek.class); // Key是枚举时用此类效率最高
SortedMap = TreeMap：红黑树，类型必须实现Comparable接口的compareto
LinkedHashMap：遍历时能按插入顺序。不是链表实现的kv对

Sets.newHashSet(1,2,3); TreeSet

Deque<T> dq = new ArrayDeque/LinkedList<>(); // 提供push()/pop()/peek()替代Stack，对应dq.xxxFirst；也继承了Queue，对应dq.xxxLast
dq.addFirst/Last()/remove()/get()失败时抛异常，offer()/poll()/peek()失败时返回false或null，因此避免把null添加进去
PriorityQueue：取出时会先取出小的。与SortedSet相比能存重复数据。需要对象实现Comparable接口

// 重写equals和hashCode，@Override略。List/Set.contains()，Map.get()等会用到；hashCode对于相同对象一定要相等，不同对象尽量不等
public boolean equals(Object o) {
    if (o instanceof Person p)
        return Objects.equals(this.name, p.name) && this.age == p.age;
    return false;
}
int hashCode() {
    return Objects.hash(firstName, lastName, age);
}

Collections.reverse() shuffle()

并发集合java.util.concurrent，线程安全
ConcurrentLinkedDeque 无限长，size()非O(1)，批量添加和遍历非原子操作
BlockingQueue接口，具有数量上限的队列：含有put take阻塞方法，和具有超时的offer poll。ArrayBlockingQueue、LinkedBlockingDeque。类似于Go的阻塞Channel：SynchronousQueue
LinkedTransferQueue：生产者调用transfer()阻塞等待直到消费者将那个元素取出。是无限长的。SynchronousQueue可看作它的特例
ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet
CopyOnWriteArrayList 每次插入时整个复制，超级低效


不用的：
Collections.synchronizedList、Vector
Collections.unmodifiableList：包装普通的List，拦截修改
Hashtable：线程安全的HashMap，没必要用。哈希表用HashSet
Properties：用于读写.properties文件，也可以手动new当作Map用。load(getClass().getResourceAsStream("/default.properties"))从jar包或classpath中读取资源
```

## IO

* 各种流读文件时都要关闭，可用try(resource)；如果用了包装，最外层的关闭即可；会导致里面的异常被抑制
* Filter模式，接受一个InputStream，仍返回该类型，但内部已经包装了，减少继承链
* Scanner和老的流的默认编码受file.encoding影响，默认为代码页，读文件时记得指定编码
* 环境变量：System.getenv() 无法设置
* 第三方库：okio

```java
System.out.print()/println()/printf()
var scanner = new java.util.Scanner(System.in);
scanner.nextLine()/nextInt()/next()默认以空格分隔返回String。findAll("xxx").map(MatchResult::group)、findInLine()
InputStream转String：new Scanner(in, "UTF-8").useDelimiter("\\A").next() // 如果流为空会抛NoSuchElementException。JDK9可用readAllBytes()
System.console().readLine()/readPassword() 在jshell下不存在

import java.io.*;
try (InputStream ins = new FileInputStream("readme.txt"/FileObj)) // 字节流无需设定编码，一般还加一层BufferedInputStream，之后可用Scanner
Reader reader = new FileReader("readme.txt"/FileObj, StandardCharsets.UTF_8)/StringReader("Hello")/InputStreamReader(ins, "UTF-8"); // 字符流
var br = new BufferedReader(reader); br.readLine(); // 这样才能读一行。仍然没有全部读完的方法
PrintStream：属于OutputStream，支持一组print()/println()打印各种数据类型，System.out就是；一般用PrintWriter包裹其他Writer来用。二进制流用DataOutputStream
ByteArrayOutputStream 内存字节流，可toString("UTF-8")。StringWriter 可toString()
ins.transferTo(os); r.transferTo(w)

import java.nio.file.*; // 替代File，默认编码UTF_8，不跟随系统。那些返回stream<T>的需close或try()
Path p = Path.of("..", "project").toRealPath() // 解析软链接和相对路径
Files.readString(p.resolve("data.txt"))/readAllLines()/lines()/readAllBytes()，writeString()/write(p,lines/bytes)，newInputStream()/newBufferedWriter()需close
Files.list()/newDirectoryStream()/walk(root).filter(path -> !path.equals(root)).map(root::relativize); 将绝对路径变为相对路径
Files.exists()/isRegularFile()/isDirectory()
Files.delete()/deleteIfExists() // 对于文件夹，必须非空。没有自带递归删除的方法，可以和walk配合遍历删；但Spring有FileSystemUtils
Files.createTempFile()
Files.copy() // 只能用于单个文件，支持stream
```

### Socket

* UDP很复杂，用DatagramSocket和DatagramPacket，自己处理byte[]
* JDK16支持UnixDomainSocketAddress

```java
import java.net.Socket;
var s = new Socket(ip,port); // 客户端，指定要连接的地址
try(var in = s.getInputStream(); var out = s.getOutputStream()){
    handle(in,out); // 里面把两个stream用缓冲读写器包一下再使用，用完了一般要flush()
}

var ss = new ServerSocket(port); // 服务端，指定绑定的端口
while(true){(new Thread(new Handler(in,out))).start()}

// NIO
var s = SocketChannel.open(new InetSocketAddress(ip,port));
s.write(ByteBuffer.wrap("data".getBytes()))
var readBuffer = ByteBuffer.allocate(512);
while (socketChannel.read(readBuffer) > 0){
    readBuffer.toString(); readBuffer.flip();
}

var ss = ServerSocketChannel.open().bind(new InetSocketAddress(8080));
// ss.configureBlocking(false); // 使用后accept()将不再阻塞，如果没有连接会立刻返回null，感觉没啥用
while(true){ try(var s = ss.accept()) }
// 还有transferTo()对应sendfile。文件：FileChannel.open(path)可用
```

## 函数式

* 接口
  * 单方法接口SAM(Single Abstract Method)（但可有默认方法）用`@FunctionalInterface`注解（不强制使用，使用后如果有多个方法会编译期错误），可用Lambda表达式代替匿名类隐式实现接口（C#办不到）`(s1, s2) -> s1.compareTo(s2)`
  * 方法引用：用双冒号。可引用实例方法，则相当于隐式添加第一个参数this，如`String::trim`，C#做不到
* java.util.stream.Stream
  * 惰性，链式map().filter().sorted().limit().distinct()，聚合操作才进行计算.sum()/reduce()
    * sorted()一般是稳定的，对于并行流会并行排序不稳定
  * collect(Collectors.toList()/toSet()/toMap(kf,vf)k重复时抛异常或用第三个参数处理重复的/joining(","))
    * 取一个：findFirst()有序，findAny()可能并行处理不稳定
    * Collectors.groupingBy(Function.identity(), Collectors.counting())
    * partitionBy：根据Predicate把数据分为true和false两组
    * tee：需要对某一序列多次collect时使用
  * toArray(String[]::new)。直接toList()是不可变的，JAVA8没有
  * flatMap()把`stream<List<T>>`变成`stream<T>`相当于SelectMany，mapMulti允许处理每个元素
  * Stream.concat()连接两个stream。Guava的Streams支持变参；或用Stream.of().flatMap(Function.identity())
  * map.entrySet().stream().max(Map.Entry.comparingByValue())
  * anyMatch() allMatch()
  * Arrays.stream(int_arr)或range()静态方法得到IntStream，它toArray()能返回int[]。普通的装箱类型stream转它用mapToInt(Integer::valueOf)，它转装箱的用boxed()或mapToObj()。它的map只能仍保持IntStream
  * takeWhile() dropWhile()
* `Optional<T>`
  * 原意是替代null，但不可序列化
  * 创建者返回空时用Optional.empty()；一定有值时返回Optional.of(xxx)，如果xxx为null会抛异常
  * 调用方用if(op.isPresent())判断是否有结果，get()获得结果，如果为null会抛异常，用orElse(null)解决。或orElseGet(fun)/orElseThrow()
  * 处理链式调用a?.f()?.g()的场景：ofNullable(a).ifPresent(f).ifPresent(g).orElse(中间出现了null时最后的值)
* 无法方便地从Iterable转换成Stream，只能`StreamSupport.stream(it.spliterator(), false)`，Guava实现了；Stream转Iterable可以强转s::iterator，但还是很麻烦
* `Predicate<T>`：可以把多个函数用and() or() negate()串联起来，还有not()静态方法如filter(Predicate.not(s -> s.contains("11")))，isEqual()静态方法
* Objects::isNull、nonNull；Character::isAlphabetic、toLowerCase
* forEach：不能用(i->sum+=1)因为要求闭包的变量是final的；默认可以并行，forEachOrdered才保证顺序。Collection接口里的forEach是正常的
* java.util.function
  * Function<S,T>接口：类似于C++的lambda函数的实现原理
* 通过指定Field得到排序器：`Comparator<T>.comparing(o->o.v).thenComparing()`，基元类型用comparingInt

## 反射

* java.lang.reflect.*
* Class cls = String.class / int.class / s.getClass() / Class.forName("java.lang.String") 它们都有泛型版
* getName()就是forName所需的，但遇到数组时不太好读。getCanonicalName()是易读结果
* getParameterizedType() 获得当前类的泛型类型
* Field f = getField(name)根据名字获取包括父类的公共字段，getDeclaredField(name)不包括父类但可获取私有字段，getFields()略；f.setAccessible(true)后f.get(o)可访问私有字段
* getMethod(), getReturnType(), getParameterTypes(), getModifiers(), invoke()
* getConstructor(构造函数的参数对应的clazz).newInstance()
* getSuperclass(), getInterfaces()
* obj instanceof String s；cls.isAssignableFrom(cls2)。nullobj instanceof xxx -> false
* 引入泛型后有xxxType与Class继承Type
* 浅拷贝：Object自带一个protected的clone()，自定义类implements Cloneable接口用super.clone()就能实现浅拷贝；此接口实际上什么也不包含，但如果不实现它直接调用clone()就会抛异常
* 深拷贝：序列化再反序列化，bao = new ByteArrayOutputStream(); new ObjectOutputStream(bao).writeObject(this); new ObjectInputStream(new ByteArrayInputStream(bao.toByteArray())).readObject()

## HttpClient

* keepalive时间：JDK21默认30秒，之前默认20分钟
* 第三方库
  * okhttp retrofit 同一组织出的，后者用于把restapi封装成易使用的类
  * feign：在多种http客户端上的封装，受到了retrofit的启发。另有Spring Cloud OpenFeign但只维护了

```java
var client = HttpClient.newHttpClient(); // JDK11
var request = HttpRequest.newBuilder() // URI也可传进这里面
    .uri(URI.create("https://javastack.cn")).header(k,v).timeout(duration).GET().build();
// 同步
HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
System.out.println(response.body());
// 异步
client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
    .thenApply(HttpResponse::body)
    .thenAccept(System.out::println);


var client = new OkHttpClient();
或 new OkHttpClient.Builder().connectionTimeout(60, TimeUnit.SECONDS).cache(...).build()
public static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
var body = RequestBody.create(json, JSON);
var req = new Request.Builder().url(url).post(body).build();
try (var resp = client.newCall(request).execute()) {
  return resp.body().string();
}
异步：call.enqueue(new Callback(){ onFailure(); onResponse(); })
```

## 正则

```java
var p = Pattern.compile(...);
var m = p.matcher(str);
m.matches();
m.group(n);
Pattern::asPredicate // 用在filter中
```

## 日期和时间

* 时间戳：System.currentTimeMillis()，类型为long的毫秒。另外long字面量要加L后缀
* java.time新API：Month的范围是1-12，Week的范围是1-7表示周一到周日
* 日期：LocalDate .now() .of(年,月,日) .parse("2019-11-19")
* 时间：LocalTime .now() .of(时,分,秒) .parse("15:16:17")
* 日期和时间：LocalDateTime .now() .of(d,t) .of(年,月,日,时,分,秒) .parse("2019-11-19T15:16:17"); dt.toLocalDate() .toLocalTime()
* 链式运算：dt.plusDays(5).minusHours(3).withYear().withDayOfMonth().with(TemporalAdjusters.firstDayOfNextMonth())
* 比较：dt.isBefore/isAfter(target)
* 两个DT的差值：Duration.between(start, end) / ofHours(9)，转换为字符串后类似PT1235H10M30S表示1235小时10分钟30秒
* 两个Date的差值：d1.until(d2)，Period类型，类似P1M21D表示1个月21天
* DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
  * dtf.format(dt); dt.parse("日期字符串", dtf)
  * ofLocalizedDateTime(FormatStyle.MEDIUM) -> `2023年6月12日 19:33:30`
  * M为9，MM为09，MMM为Sep，MMMM为September
  * E表示英文星期如Sun，EE表示中文星期，使用时第二个参数传Locale.US/CHINA
  * ZZZZ表示时区，如GMT+08:00
* OffsetDateTime：与ZDT相比在运算时不会处理夏令时(Daylight saving)，比如ZDT指定一个区域，半年后它的时区可能会发生改变
* ZonedDateTime
  * .now() .now(ZoneId.of("America/New_York")) 是同一时刻
  * dt.atZone(ZoneId.systemDefault()/ZoneId.of("America/New_York")) 给LocalDateTime附加时区，时间不变，时区不同，不是同一时刻
  * zdt.withZoneSameInstant(ZoneId.of("Asia/Shanghai")) 时刻不变，转换时区，转换时间，再.toLocalDateTime()就丢掉了时区
* Instant.now()
  * ins.getEpochSecond()时间戳秒 .toEpochMilli()毫秒
  * ins.atZone(...) ZDT.ofInstant(ins, ZoneId.of(...)) 时刻转ZDT
  * Instant.ofEpochMilli(milli) 时间戳转时刻
* java.util旧API
  * Date
    * getYear()要+1900，getMonth()要+1
    * 内部实际上储存的是时间戳，但对外（包括序列化反序列化）默认以本地时区表示
    * ToString为文字版：`Fri Dec 01 19:01:55 CST 2023`
  * java.sql.Timestamp
    * Date的子类，添加毫秒功能
    * ToString和valueOf的模式默认日常使用的那种
    * 新转旧：Timestamp.of(ldt/inst)
  * SimpleDateFormat
    * new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); sdf.format(date)。能在此处setTimeZone()
    * 线程不安全，要复用时考虑配合ThreadLocal
    * 中文文字版：DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM)
    * 简单使用版：DateFormat.getInstance() -> "2023/12/1 19:10"。还能单独取日期或时间
  * Calendar添加了一些对Date简单运算的方法，只能用Calendar.getInstance()创建，最后.getTime()
  * TimeZone.getDefault()
  * 旧转新：Date和Calendar用.toInstant()再变成ZDT，TimeZone用.toZoneId()
* -Duser.timezone=Asia/Shanghai 或 GMT+8

## 多线程

* Thread
  * 可以创建一个类继承它，重写run()。可以创建类实现Runnable接口的run()。可以传()->{...}
  * t.start(); t.join(毫秒); t.setDaemon(true);守护线程不影响主线程退出，不应持有需要关闭的资源
  * 睡眠：Thread.sleep(毫秒)、Thread.sleep(Duration.ofSeconds(秒))、java.util.concurrent.TimeUnit.SECONDS.sleep(秒)
  * 无需import
  * 新版创建方法：Thread.ofPlatform().daemon().start(runnable)
  * 中断：调用者t.interrupt()，线程里自己检测isInterrupted()，这种方式必须用继承。也可以用volatile变量running
  * 获得返回值：var ft = new FutureTask<>(()->...)，传进Thread，ft.get()
  * 设置未捕获异常的Handler：t.setUncaughtExceptionHandler()、Thread.setDefaultUncaughtExceptionHandler()
* synchronized
  * 一般在方法上加，相当于整个方法体synchronized(this)
  * 也可以自定义Counter类，static final Object lock = new Object()，使用时synchronized(Counter.lock){...}
  * 是可重入锁。无论是否有异常都会在结束时释放锁
  * 消费者获得锁后若发现不满足条件，可循环调用预定义在Object上的wait()，另一线程生产者在相同锁对象上notify()/notifyAll()。它们是native方法，会释放锁
  * 只在里面访问变量不需要再加volatile
* 同步器
  * Semaphore：保护数量有限的资源，require和release
  * CountDownLatch：类似于Go的WaitGroup
  * CyclicBarrier：达到指定数量的线程后才开始同一时间执行。或看作可多次生效的CountDownLatch。还有个自定义程度更高的Phaser
  * Exchanger：类似于Go的阻塞Channel，但可以两者互相发数据
* AQS锁concurrent.locks
  * ReentrantLock：和手动使用synchronized差不多，但允许tryLock()指定超时，更不容易死锁；lockInterruptibly()允许线程被中断。要在finally释放
  * Condition：代替wait和notify
  * ReadWriteLock
  * StampedLock：与ReadWriteLock类似，但是读乐观锁，读时也允许获取写锁后写入，需要读完一条后validate()一下，如果发现有写入再加普通读锁重读。不可重入
* 原子类concurrent.atomic
  * AtomicInteger：incrementAndGet()
  * AtomicReference：对于引用类型的原子操作。volatile相当于它的get()和set()，而它提供更多功能
  * AtomicIntegerArray：其元素具有volatile语义
  * LongAdder：对自增友好
  * 手动控制已有的volatile变量：AtomicXXXFieldUpdater
  * 单条赋值语句，引用类型、除了long和double的基本类型，是原子的。long和double在x64上是原子的
  * 属于CAS(Compare and Swap)操作，乐观锁，具有ABA问题：两个线程分别取出值A，第一个线程改成B又改回A，第二个线程CAS操作能成功。如果要检测这种情形，解决办法是版本号，用AtomicStampedReference或AtomicMarkableReference；其中后者只用1bit检测，适用于最多两个线程并发
* 线程池：ExecutorService es = Executors.newFixedThreadPool(4); es.submit(runnable); es.shutdown()等待完成/shutdownNow()不等待/awaitTermination()等待一段时间
  * CachedThreadPool 线程数根据任务动态调整，SingleThreadExecutor 仅单线程执行，ScheduledThreadPool 可定期反复执行或提交后隔一段时间再执行 可取代java.util.Timer
  * execute()无返回值直接抛出异常，submit()返回Future，等get()时抛出异常。也支持实现了`Callable<T>`接口的`T call()`对象，返回`Future<T>`，可以get()取值
  * ForkJoinPool：把大任务拆分成小任务最后合并。太复杂了
* CompletableFuture
  * 静态方法创建：completedFuture(已有的值)、supplyAsync(()->{自动在线程池中运行，返回值})、runAsync()返回void、failedFuture(异常)、new出来complete(设置值)
  * 进一步处理：thenApply(相当于map)、thenCompose(相当于Monad，参数为一个已存在的`x->CF<x>`，避免返回值变成`CF<CF<x>>`)、thenAccept(返回void)、thenRun(无需上一步结果且返回void)
    * 处理异常：exceptionally(设定异常时的默认值)、handle(相当于thenApply和exceptionally的结合)、whenComplete(返回void)
    * 组合多个：thenCombine(另一个CF, 处理二者结果的回调)、thenAcceptBoth(CF, 返回void)
  * 阻塞获得结果：join()相比于get没有了CheckedException。非阻塞处理结果就用那些void回调的方法。非阻塞获得状态：isCompletedExceptionally() isCancelled() isDone()
  * 其它静态方法：allOf()、anyOf()。Java9新增延迟执行和超时
  * 不指定Executor时Async结尾的方法默认用ForkJoinPool
* ThreadLocal
  * 在一个线程中横跨若干方法调用需要传递的对象称作上下文，给每个方法增加一个context参数非常麻烦
  * 用此对象，先声明`static final ThreadLocal<String> ctx = new ThreadLocal<>();`，创建者try{ctx.set(o); step1(); step2()}finally{ctx.remove()}，使用者ctx.get()
  * 可以看作一个全局的`Map<Thread, Object>`
  * 另一种用途：储存线程不安全但昂贵的对象，如DateFormat
  * 虚拟线程可以使用，但如果虚拟线程很多，会消耗大量资源
* 虚拟线程
  * Thread.startVirtualThread(runnable) 创建并执行
  * Thread.ofVirtual().unstarted(runnable) 创建但不执行
  * Thread.ofVirtual().factory(); fa.newThread(runnable)
  * 都是守护线程，不支持stop suspend
  * 执行synchronized和本地方法中无法换出，用ReentrantLock则可以
  * Executors.newVirtualThreadPerTaskExecutor
  * 不能加速计算任务，虚拟线程的overhead比平台线程大，只是创建和阻塞虚拟线程的代价远比平台线程小

## 密码学

* 哈希：java.security.MessageDigest.getInstance("MD5").update(bytes).digest(); new BigInteger(1, result).toString(16)
  * HMAC：javax.crypto.MAC.getInstance("HmacMD5").init(key).update().doFinal()
* 随机数
  * 普通随机数：Random类。JDK17：RandomGenerator.getDefault()
    * 多线程下推荐用ThreadLocalRandom.current()
  * 密码学安全随机数：java.security.SecureRandom.getInstanceStrong()，一般用nextBytes填充buffer。不要new它。也实现了RandomGenerator接口
    * 多线程下，JDK8没说是线程安全的，17是
* 密钥生成器：javax.crypto.KeyGenerator.getInstance("HmacMD5" / HmacSHA256 / AES / ChaCha20).generateKey()
* 加密
  * Cipher.getInstance("AES/CFB8/NoPadding")
  * cipher.init(Cipher.ENCRYPT_MODE, key, iv) 解密用另一种MODE。RSA只在加密/解密时分别提供pubkey/privkey
  * cipher.doFinal(原地修改bytes)

## 其它内置库

* Math
* java.math.BigInteger：创建用new，运算用实例方法，转换成基本类型用.longValueExact()
* BigDecimal：scale()表示小数位数，负数表示是整数且末尾有0，setScale()指定小数位数和舍入方式；加减乘时精度不会丢失，但除法除不尽时要指定精度和如何截断；divideAndRemainder()可以做除法的同时求余数；equals()要求值和scale()都相等，一般应该用compareTo()，或先用stripTrailingZeros()
* JavaEE的javax名称空间现在变为了jakarta，不过还是有几个类在前者里
* java.net.URLEncoder/URLDecoder：会把空格编码成加号
* java.util.Base64.getEncoder().encodeToString(bytes)。还有一种getUrlEncoder()，把+变成-，/变成_
* 运行外部命令
  * Runtime.getRuntime().exec()
  * new ProcessBuilder("cmd", "arg").start()
    * 可以在此处设置stderr合并到stdout、输出重定向到文件和继承（默认是管道）
  * Process：获得STDIN用getOutputStream()，因为使用者要往里write
    * 等待退出用waitFor，不是wait；超时时返回false，不是抛InterruptedException

## GC调优

* G1默认最大暂停200ms，可以用-XX:MaxGCPauseMillis调整
* 当大量实例突然变得符合回收条件时，考虑用ZGC和SGC。当堆的很大一部分被持续占用时，用G1
* 现在64位的JDK只有Server模式，-client参数会直接忽略
* -Xmx512m：最大堆大小，默认为1/4的内存。ms是最小和初始堆大小，低于它的占用也不会返回给系统
  * -XX:SoftMaxHeapSize=1G：要求VM尽量不超过此值规定的最大堆大小，好像只有ZGC支持，不过这参数是JDK的，别的GC就算不支持也不会报错
  * -XX:MaxRAMPercentage=75：分配所有内存的75%，当在容器里运行且限制了内存时考虑使用。一般来说还是用Xmx且不限内存，因为程序需要多少内存应该由程序的功能决定
* -XX:+UseLargePages：大内存如16G时启用，还需设置/sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages，值至少为16G/2M=8192。ZGC使用时内核最好大于4.14
  * Linux下考虑改用-XX:+UseTransparentHugePages，还要设置echo "madvise" > /sys/kernel/mm/transparent_hugepage/enabled; echo advise > /sys/kernel/mm/transparent_hugepage/shmem_enabled。相比之下某些时候能减少内存占用，但可能造成延迟抖动。内核最好大于4.7
* -XX:+AlwaysPreTouch：启动jvm时申请较多内存，能减少延迟卡顿
* 在GC时合并重复的字符串：-XX:+UseStringDeduplication JDK17及之前仅限G1，之后都支持
* -XX:+UseShenandoahGC：也是低延迟，适用于Web服务端。实测Win下内存占用很高。RedHat提供JDK8的
* -XX:+UseZGC -XX:+ZGenerational：延迟低；最好设置mx，一般最少16G，CPU负荷最好小于70%。借鉴了Azul的C4算法
* 显示当前使用了哪种GC、GC参数、运行过程中的调用情况：-Xlog:gc+init+stats
* 查看当前选项包括所使用的GC模式：java -XX:+PrintCommandLineFlags -version。查看包括默认值在内的所有选项：-XX:+PrintFlagsFinal
* 避免用户乱调用System.gc()：-XX:+DisableExplicitGC
* 不进行GC：-XX:+UnlockExperimentalVMOptions -Xlog:disable -XX:+UseEpsilonGC
* 禁用析构函数：--finalization=disabled JDK18后支持

## Maven

* https://maven.apache.org/download.cgi 的Binary zip archive。或用mavend
* 初始化：mvn archetype:generate -B -DgroupId=com.company.project -DartifactId=project
  * 目录结构：会生成project文件夹，里面有pom.xml src，src里有main和test，下面各有java和resources，代码在java下对应package的层级
  * 包名与groupId相同，也可用-Dpackage指定
  * 无法直接在CWD生成
  * 实际上以-DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-quickstart -Dversion=1.0-SNAPSHOT为默认值
  * properties
    * 必须设置maven.compiler.source和target，用release无效，否则默认为1.5；maven4默认1.8。一般先设置java.version再引用它
    * project.build.sourceEncoding:UTF-8 不设置时会有warning说构建依赖平台。project.reporting.outputEncoding不清楚需不需要
    * 以上两项在spring-boot-starter-parent里都设置了，只要自己再设置java.version即可
    * 里面写的东西可在别的地方用${xxx}使用
    * maven.compiler.showDeprecation
* 运行：mvn exec:java -Dexec.mainClass=com.company.project.App -Dexec.args="arg1 arg2" 也可写进properties里。加-q不会显示maven的信息但也不会显示traceback（SpringBoot可以）
* 流程：内置了default、clean等生命周期，每个生命周期又包括多个phase，每个phase又会触发goal。mvn命令后跟的就是phase，冒号后跟的就是goal。大部分phase默认什么也不做
* 常见命令
  * mvn clean 删除target文件夹
  * mvn clean compile 先清理再运行到compile，生成class文件到target目录。单纯compile只会编译未编译的文件，不会自动clean，以下略
  * mvn test 包含了compile
  * mvn clean package -DskipTests 打包生成jar到target目录
  * mvn install 把当前项目打包到本地仓库作为依赖供其它项目使用
* 并行编译：-T 4或1C表示每个核一个线程。并行测试另有选项
* 生成文档：mvn site。不知道要不要手动装插件
* 额外插件：https://spotbugs.github.io/ 静态分析。maven-shade-plugin将依赖也一起打包
* 查看插件版本：mvn -Dplugin=gid:aid help:describe
* maven.compiler.debug默认为true，对应javac的-g，已经是最全的调试信息了

### 依赖

* 添加依赖：在仓库搜索想要的包后看示例添加进pom，没有命令行添加的功能
* 下载依赖：mvn dependency:resolve 一般用于添加后第一次使用，或者更新SNAPSHOT的
  * 非maven项目下载依赖：mvn dependency:copy -Dartifact=gid:aid:RELEASE -DoutputDirectory=lib
* 默认依赖包存放位置（本地仓库）：$HOME/.m2/repository
* （中央）仓库：https://central.sonatype.dev https://search.maven.org/ https://mvnrepository.com/
* 镜像：https://maven.aliyun.com/mvn/guide
* dependency.scope：默认是compile表示编译时需要用到该jar包，还可以是test如junit、runtime如JDBC驱动因为自带接口只需要运行时用jar编译时不用、provided表示JDK或tomcat会提供如servlet-api。optional：设为true表示依赖不传递，如A依赖Lombok，B依赖A，则B不会依赖Lombok
* 使用本地的jar依赖：maven4后install:install-file -Dfile=xxx.jar安装到本地仓，前提是此jar就是maven打包的，否则还要指定groupId等。scope=system废弃了
* 版本
  * LATEST和RELEASE能使用，但宣布废弃了，且对插件无效
  * versions:use-latest-releases versions:update-properties 比较有用
  * versions:update-parent 可以更新spring-boot-starter-parent
  * display-dependency-updates 无法用于springboot因为会检查parent里的依赖
  * 范围：[1.0,2.0)、[1,)。但这样会把所有大于1的版本都下下来。用mvn versions:resolve-ranges会替换为具体版本
  * 冲突解析策略：先按深度，再按声明顺序
* 递归查看所有依赖：mvn dependency:tree
* 单纯import对象而不使用，即使依赖的jar不存在也不会报错。可在Main里用Class.forName(xxx)缓解。TODO:是不是编译时有jar，但运行时没有，会直到调用时才报错

### 多POM、继承

* 子POM查看继承解析后的：mvn help:effective-pom

```xml
根：编译这一个就能编译所有的。module里的子模块的parent不必是父模块
<groupId>com.itranswarp.learnjava</groupId>
<artifactId>build</artifactId>
<version>1.0</version>
<packaging>pom</packaging>
<name>build</name>

<modules>
    <module>parent</module>
    <module>module-a</module>
    <module>module-b</module>
</modules>

parent：一个单纯的parent/pom.xml，与其它模块平级，用来定义依赖和属性
<groupId>略
<artifactId、name>：parent
<version>1.0</version>
<packaging>pom</packaging>
<dependencies> ...

module-a：无需写自身的groupId
<parent>
  <groupId>略
  <artifactId>parent</artifactId>
  <version>1.0</version>
  <relativePath>../parent/pom.xml</relativePath> 默认为../pom.xml。spring-boot-starter-parent为<relativePath/>表示不找项目里上一层的，直接去找仓库里的
</parent>
<artifactId、name>：module-a
<packaging>jar</packaging>

统一管理依赖版本，子POM引入依赖时无需指定版本，还能控制传递依赖的版本：
<properties> xxx.version
<dependencyManagement>
    <dependencies>
        <dependency>
            正常写，可以exclude传递依赖。但type如果不是jar则子POM必须加
        </dependency>
    </dependencies>
</dependencyManagement>
或用非继承方式引入，此处maven4才支持exclude，且支持glob：
<dependencyManagement>
    <dependencies>
        <dependency>
            dependencies_pom的groupId artifactid version
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

## Json

* 暂时不学的：moshi，okhttp组织出的

```java
// com.google.code.gson:gson
import com.google.gson.Gson;
Gson gson = new Gson();
Gson gson2 = new GsonBuilder().serializeNulls().create(); // 默认序列化时会忽略值为null的
gson.toJson(obj);
gson.fromJson(jsonstr, clazz/int[].class/new TypeToken<Map<String, String>>(){}.getType())
类字段注解：@SerializedName、@Expose
TODO: https://www.studytrails.com/2016/09/12/java-google-json-introduction/

// com.fasterxml.jackson.core:jackson-databind。处理LocalDateTime：jackson-datatype-jsr310
ObjectMapper mapper = JsonMapper.builder()
    .findAndAddModules()
    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false) // 默认为true，设为false后当JSON存在Bean没有的字段时不报错
    .configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true) // 便于反序列化record
    .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false) // 默认true将Date和TS序列化为unix时间戳毫秒，设为false后默认为ISO格式0时区字符串；LocalDateTime分别为内部结构表示和当前时区ISO格式。Spring默认false
    .build();
mapper.setPropertyNamingStrategy(PropertyNamingStrategies.LOWER_CASE) // 默认不改变大小写。还有SNAKE_CASE
    .setTimeZone(TimeZone.getDefault()) // 仅当不设置DateFormat且WRITE_DATES_AS_TIMESTAMPS=false时考虑使用，设置了DateFormat似乎默认就变成当前时区了
    .setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")); // 对LocalDateTime无效

mapper.writeValueAsString(obj); writeValue(os, obj)
mapper.readValue(str/in_stream, clazz); // 一般的类要求存在无参ctor，record不必
类字段注解：@JsonIgnore、@JsonProperty("重命名", access = Access.WRITE_ONLY)、@JsonFormat(pattern="yyyy-MM-dd",timezone = "GMT+8")
类注解：@JsonIgnoreProperties(ignoreUnknown = true)
前端无法直接处理Long，使用：@JsonSerialize(using=ToStringSerializer.class)，反序列化默认就支持传入字符串

// com.alibaba.fastjson2:fastjson2
JSON.toJSONString(o)
JSON.parseObject(str, clazz)
JSONArray.from(List)
jsonarr.toList(clazz)
```

## 日志

* 暂时不学的：google/flogger

```java
// java.util.logging。若想以它为实现用slf4j，用org.slf4j:slf4j-jdk14
Logger logger = Logger.getLogger(Main.class.getName()); // 或System.getLogger()
logger.severe warning info config fine finer finest // 默认LEVEL是INFO，会记录INFO及之上的
throwing(String className, String methodName, ex)
logger.addHandler(new FileHandler()) // 文件的默认格式为XMLFormatter，冗余信息较多。控制台默认为SimpleFormatter

org.slf4j:slf4j-api
static final Logger log = LoggerFactory.getLogger(AppConfig.class);
log.info("{}", o); log.error("", e) // 异常对象不要占位符
// 若用了Lombok，在类上加@Slf4j，就能log.xxx了
// 用ch.qos.logback:logback-classic会自动传递依赖logback-core和slf4j-api
// 还有一个slf4j-simple也是实现，感觉没啥用

org.apache.logging.log4j:log4j-api、log4j-core、log4j-slf4j-impl
不要装log4j-to-slf4j，它是将代码中的log4j api调用转为调用slf4j的，而log4j-slf4j-impl是代码调用slf4j api，以log4j为实现，这才是正常用法
```

## JUnit

* org.junit.jupiter:junit-jupiter，scope=test。或在dependencyManagement添加指定版本的org.junit:junit-bom，之后再用其它依赖就不用指定版本了
* 测试代码结构：src/test/java/xxxTest.java
* assertEquals()比较浮点数时有一个重载指明精度
* assertTrue() assertFalse() assertNotNull() assertArrayEquals()
* Assumptions.assumeTrue() 如果传入的是true，才会继续执行后面的语句，否则跳过
* @Disabled：临时禁用，仍识别为测试方法，只是会跳过。@EnabledOnOs(OS.WINDOWS)，@EnabledIfEnvironmentVariable(k="v")
* 另一个包AssertJ流畅断言：https://assertj.github.io/doc/ 对比：https://annaduldiier.medium.com/assertj-vs-junit-483b7d6dc997
* 命令行运行测试：直接运行 junit-platform-console-standalone.jar，包含了所有依赖

```java
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

public class FactorialTest {
    @Test
    void testFact() {
        assertEquals(1, Factorial.fact(1));

        assertThrows(IllegalArgumentException.class, () -> {
            Factorial.fact(-1);
        });

        fail("可选reason");
    }

    @ParameterizedTest
    @ValueSource(ints = { 1,2,3 })
    void testAbs(int x) {
        assertEquals(x, Math.abs(x));
    }

    @ParameterizedTest
    @MethodSource // 从一个同名的静态函数中提供参数。还支持@CsvSource({"1,2","3,4"})和@CsvFileSource
    void testXXX(int a, int b) { ... }
    static List<Arguments> testXXX() {
        return List.of(
            Arguments.arguments(1,2),
            ...
        )
    }

    // Fixture：做准备和清理工作。还有@BeforeAll和@AfterAll在所有Test前后运行一次，但只能标注静态方法
    @BeforeEach // 每个Test都运行一次
    public void setUp() { ... }
    @AfterEach
    public void tearDown() { ... }

    @Mock
    Clock clock;
}
```

### Mockito(org.mockito:mockito-core, scope=test)

* Mock：注解版相当于new了
* Spy：对于未设定的调用，保留了真实对象的行为
* @InjectMocks：若A内部依赖B，对A用本注解，B用Mock，会自动注入依赖
* 注解：在setUp中设置MockitoAnnotations.openMocks(this);后可用，还要在tearDown里close。或用mockito-junit-jupiter和`@ExtendWith(MockitoExtension.class)`
* 验证行为：创建mock对象，测试业务调用函数，verify(m).f(arg)表示验证m之前调用过f(arg)。支持验证刚好/至少/至多/从未调用了多少次
* Stub：when(m.f(arg)).thenReturn(r)，之后m.f(arg)就会返回r
  * 支持多种argument matcher匹配指定规则的参数，常用any()，argThat(lambda)。@Captor在后续验证时能取出
  * thenAnswer(lambda)
  * 若f的返回值是void：doReturn(r).when(m).f()
* @MockBean：SpringTest特有
* Mockito5支持Stub静态函数、构造函数、final函数
* BDD风格：把when()改成了given()，没必要用

## Lombok

* Data：Getter、Setter、GetHashCode、Equals
* RequiredArgsConstructor：对于所有的final成员生成构造函数参数，配合Spring的@Component可以自动注入
* Builder：C.builder().p1(v1).p2(v2).build()
* With：类似于C#的record的
* 字段的第一个单词不要只有一个字母，如不要用cData
* boolean类型（不包括Boolean）会特殊处理，原意是对于isXXX canXXX shouldXXX这种形式的命名生成更人性化的方法，但缺点是不符合一般生成规律
* SneakyThrows：自动把CheckedException变成Unchecked

## 数据库

* 不学：jOOQ 性能超差
* PG驱动：https://jdbc.postgresql.org/

### JDBC

```java
import java.sql.*;
Connection con = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWD);
try(PreparedStatement stmt = conn.prepareStatement("SELECT ... WHERE id=?")) { // 原生不支持命名参数
    stmt.setObject(1, xxx); // 注意索引不是从0开始
    try(ResultSet rs = stmt.executeQuery()) {
        while(rs.next()) {
            int id = rs.getInt(1); // 索引不是从0开始
            String name = rs.GetString("name");
        }
}}
CRUD：ps.executeUpdate()
插入并获取自增主键：prepareStatement第二个参数加Statement.RETURN_GENERATED_KEYS，返回的结果集用getGeneratedKeys()获取
默认处于自动提交模式，用con.setAutoCommit(false)相当于开启事务，try{commit}catch{rollback}finally{改回自动提交}
一次性执行多个相同的模板的数据插入，BATCH模式：反复给ps设置参数后用ps.addBatch()，全部加完后executeBatch()
con.getMetaData() 有数据库产品名称、版本号
```

### [MySQL Connector](https://dev.mysql.com/doc/connector-j/8.0/en/)

* Class.forName("com.mysql.cj.jdbc.Driver"); 以前是com.mysql.jdbc.Driver
* 协议为带有FOSS例外的GPL，简单来说就是项目可以用别的正常的开源协议，不必是GPL。但还是要求二进制必须附上源代码
* JDBC URL：jdbc:mysql://user:password@host:port/db
  * user和password也可以在properties中指定，若含有特殊字符如@和#则不能在前面指定
  * host默认localhost，port默认3306
  * properties用?k=v指定
    * useCompression=true
    * sslMode：DISABLED PREFERRED REQUIRED VERIFY_CA VERIFY_IDENTITY
    * useServerPrepStmts 是否启用服务端预编译，默认为false。若改为true，最好还启用cachePrepStmts和调整prepStmtCacheSize、prepStmtCacheSqlLimit。对于频繁读的语句，可以启用。另有useConfigs=maxPerformance-8-0一次开启多个优化选项
    * rewriteBatchedStatements=true 影响executeBatch()
    * 不要启用autoReconnect
    * allowMultiQueries：默认一个SQL语句只能有一个SELECT，启用后可以有多个，会产生多个结果集，变复杂
    * 时区
      * 8.0.23后增加了多个选项，如果数据库和本地JVM不在同一个时区，必须设置
      * preserveInstants看起来默认为true无需更改，改为false没啥好处
      * connectionTimeZone以前叫做serverTimezone
        * 设为SERVER能正确处理TIMESTAMP的时区，不过如果按String反序列化则保留了服务器时区的时间
        * 设为LOCAL或UTC%2B8或不设置，且加forceConnectionTimeZoneToSession=true时，反序列化出的TIMESTAMP和String都为本地时间
        * 单纯设置serverTimezone为本地时区与什么都不设置一样

```xml
<dependency>
    <groupId>com.mysql</groupId>  <!-- 以前叫mysql -->
    <artifactId>mysql-connector-j</artifactId>  <!-- 以前叫mysql-connector-java -->
    <exclusions>
        <exclusion>  <!-- 不使用X DevAPI时添加此排除 -->
            <groupId>com.google.protobuf</groupId>
            <artifactId>protobuf-java</artifactId>
        </exclusion>
        <exclusion>  <!-- 不使用OCI AIM验证时添加此排除 -->
            <groupId>com.oracle.oci.sdk</groupId>
            <artifactId>oci-java-sdk-common</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

### MariaDB

* org.mariadb.jdbc:mariadb-java-client
* 协议为LGPL
* JDBC URL
  * 即使连接MySQL也要写mariadb
  * timezone=auto或UTC+8：与mysql的LOCAL方案效果一样
  * sslMode=默认disable、trust、verify-ca、verify-full
  * user和password不支持写在前面。或者用credentialType=ENV，然后设置MARIADB_USER和MARIADB_PWD
  * autocommit默认为true
  * pool参数表示启用池化，用于DriverManager.getConnection()中
  * localSocket 使用UnixSocket，依赖net.java.dev.jna:jna（waffle-jna传递依赖了）
* 主动控制池化：new MariaDbPoolDataSource(jdbcurl); try(pool.getConnection; con.createStatement())

```xml
<dependency>
	<groupId>org.mariadb.jdbc</groupId>
	<artifactId>mariadb-java-client</artifactId>
        <exclusions>
          <exclusion>
            <groupId>com.github.waffle</groupId>  <!-- 不使用GSSAPI时添加此排除，Win下本来就不支持 -->
            <artifactId>waffle-jna</artifactId>
          </exclusion>
      </exclusions>
</dependency>
```

### HikariCP

* com.zaxxer:HikariCP
* connectionTimeout默认30秒，是等待从池里取出连接的时间。maximumPoolSize默认10。autoCommit默认为true

```java
HikariConfig config = new HikariConfig(); // 也可传Properties对象
config.setJdbcUrl(JDBC_URL); config.setUsername(xxx); config.setPassword(xxx); config.addDataSourceProperty(k,v)
HikariDataSource ds = new HikariDataSource(config); // 也可对它设置
try (Connection conn = ds.getConnection()) { ... }
```

### [JDBI](https://jdbi.org/)

* org.jdbi:jdbi3-core和jdbi3-sqlobject
* ObjectAPI可以自动释放资源，withHandle中的语句在create后要加.attachToHandleForCleanup()
* 可以和HikariCP结合使用，具体见文档

```java
Jdbi jdbi = Jdbi.create(JDBC_URL);
List<T> l = jdbi.withHandle(hnd -> { // 流畅API。不返回值用useHandle
    hnd.execute(SQL, params); // 占位符支持?和:key，参数支持多种绑定方式
    hnd.createUpdate(CRUD).bind(0-based-ndx,val).bind(k,v).bindBean(obj).execute();
    return hnd.createQuery(SELECT) .mapToBean(clazz)/mapToMap() .list()/collect(Collectors.toSet())/.useStream(s->...);
    hdn.select().mapTo(String.class).one()/first();
});

public interface UserDao {
    @SqlUpdate("INSERT INTO \"user\" (id, \"name\") VALUES (?, ?)")
    void insertPositional(int id, String name);

    @SqlUpdate("INSERT INTO \"user\" (id, \"name\") VALUES (:id, :name)")
    void insertBean(@BindBean User user);

    @SqlQuery("SELECT * FROM \"user\" ORDER BY \"name\"")
    @RegisterBeanMapper(User.class)
    List<User> listUsers();
}
jdbi.installPlugin(new SqlObjectPlugin());
jdbi.withExtension(UserDao.class, dao -> {
    return dao.listUsers();
}
```

## 第三方库

* 文档：https://javadoc.io
* jsoup：HTML请求和解析库，支持css选择器
* guava：不可变集合、检查非空、Multiset/map、自定义行为的字符串Splitter和Joiner、简单的缓存类
* netty：代替nio做socket编程
* zxing：等学安卓再说，而且它现在处于维护模式
* hutool：国产工具库，农历、汉字转拼音、身份证合法性、定时任务、图形验证码、Excel操作、RSA加解密、哈希
* 爬虫：apache/nutch、PulsarRPA
* 轻量级微服务Web框架：Quarkus，RedHat的。Micronaut，Graal的。Helidon，Oracle的
* awaitility：用于多线程异步测试
* joda-money
* redis：redisson或lettuce(基于netty)。jedis在redis官方组织下，线程不安全但池化后就可以了
* mapstruct
* 处理Excel：poi(Apache)、easyexcel(阿里)
* apache commons：tuple.Pair；或用AbstractMap.SimpleEntry但没有无参构造函数
* bytebuddy：操纵字节码
* caffeine：本地缓存

## TODO

* https://dev.java/learn/ 看到Mastering the API、Lambda、Generics
* https://github.com/Snailclimb/JavaGuide https://github.com/doocs/advanced-java
* https://www.baeldung.com/java-tutorial https://books.trinket.io/thinkjava2/ https://programming.guide/java/
* JEP 442 新的调用本地函数的API（Project Panama），还在孵化。jextract从C头文件中生成java绑定
* javadoc：http://www.herongyang.com/Java-Tools/javadoc-The-Java-Document-Generator.html
* Compact Object Headers https://openjdk.org/jeps/450
