# Java

## 环境

* JDK
  * https://jdk.java.net
  * https://www.microsoft.com/openjdk 基于Adoptium的，有一些未被合并到上游的修改，但目前都是ARM64的
  * Eclipse Temurin：https://adoptium.net/ 提供Win下x86版本，还提供EA版
  * Liberica：https://bell-sw.com/pages/downloads/ 提供Lite版（通过jlink创建的）和带FX的Full版，有32位
  * 镜像：https://www.injdk.cn 收录了不少版本的build，还有Graal
  * OpenJ9/Semeru：https://developer.ibm.com/languages/java/semeru-runtimes/downloads/ 不基于OpenJDK VM，内存占用更小，启动时间可能更长，但开启AOT后再次运行有缓存
  * Debian：openjdk-17-jdk openjdk-17-jre
* VSC
  * Language Support for Java
  * Debugger for Java 不调试可以不用
  * Project Manager for Java 还有一个maven的扩展
  * SonarLint
  * 裸依赖的jar放在lib文件夹里，或者调java.project.referencedLibraries
  * 出现is not on the classpath of project, only syntax errors are reported，用F1 Java: Clean the Java language server workspace
* Docker：openjdk和java的deprecated了。可以用eclipse-temurin，还有alpine版
* JAVA_HOME：当存在多个JDK时，设置此环境变量可用想要的版本
* 运行时查看版本：System.getProperty("java.version")

### 命令行

* 编译
  * javac -Xlint -g -cp lib.jar:pkg/* -d bin src/com/xxx.java，编译成bin/com/xxx.class（实际是因为package语句）
  * 若CWD为src，用 -d ../bin com/xxx.java
  * linux可用 `src/**/*.java`
  * 为老JRE编译 --release 11 要求源码也是那个版本兼容的。另一种方式是指定--source和--target，但只会检查语法，不会检查库兼容性
  * Win的cp分隔符为分号
* 运行class：java -cp a.jar:pkg/*:bin com.Main，即指定main()所在的完整类名，不是指定.class文件
  * cp默认为.（CWD）
  * 运行选项必须在运行目标前，可用JAVA_TOOL_OPTIONS环境变量设置。-ea启用assert语句。-XX:+ShowCodeDetailsInExceptionMessages空指针异常时显示更详细的信息
  * java命令行现在也能直接运行xxx.java，但好像无法导入模块化的依赖，且main()所在的类必须是第一个
* 打包jar -cvef com.Main out.jar -C bin .
  * 其中e指定入口点，f指定输出的文件，C更改工作目录，还可加--module-version 1.0
  * 运行含有入口点的包：java -jar out.jar args。列出jar中的文件：jar -tf out.jar。显示模块化jar的依赖：jar -d -f
  * 打包完成的jar的根就是com等，不是bin
* 模块化
  * 目的：jar是class的容器，但并不关心jar之间的依赖。如果运行时少了某个需要的jar就会出问题。模块化是使得一个jar能够自动找到依赖的jar
  * 创建和com平级的module-info.java，都放在src下：`module 模块名{requires 模块名; exports 模块名;}`，隐式导入了java.base，其余的import了的库必须在这里声明，别的库想访问本模块的类（如反射）则必须在这里声明导出
  * 模块名与pkg名不必相同，一个模块可以包括多个package，一个jar只能有一个模块，自己的.java不能和module-info平行
  * 编译：普通地编译module-info即可。依赖的库可用-p pkg直接指定文件夹了；另一种方式是用-m 模块名 --module-source-path src。之后生成jar没区别
  * 运行：java -p pkg;out.jar -m 模块名，或-p bin -m 模块名/完整类名（此处的斜杠为字面量）
  * 生成jmod：jmod create --class-path out.jar或bin out.jmod。无法简写成cp，当out.jmod已存在时不会自动覆盖，生成的out.jmod无法运行，仅用于生成jre，感觉没啥用，不如jlink时直接指定.jar或pkg
  * 生成jre：jlink -p out.jmod --add-modules java.base,模块名 --output jre --strip-debug/-G --compress=2/-c=2 --no-man-pages --no-header-files。之后可用jre/bin/java -m 模块名 运行，或先用--launcher创建启动脚本。其中add-modules的内容用jdeps分析。TODO: 不清楚怎么加依赖，需不需要把依赖的jar转换成jmod
  * 分析依赖：jdeps xxx.class或jdeps --module-path out.jar;pkg -m 模块名
* jshell JAVASE：REPL，且自动导入所有标准库
* jcmd：JFR工具，用于Profile。-l列出正在运行的Java程序。其它命令暂不学习
* jpackage -n 项目名
  * 模块化项目：-p 模块路径 -m 模块名/完整类名
  * 非模块化项目：-i bin --main-jar out.jar
  * 创建含有jre和本项目exe的文件夹：-t app-image
  * 创建带有图形界面的安装程序，Win下还要装Wix：--win-dir-chooser --win-console --win-shortcut --icon i.ico
* jdeprscan dir/jar/class：扫描是否使用了废弃的API
* keytool

### 编码

* 源代码不支持UTF8-with-BOM
* javac -encoding utf8 -d bin Main.java：源文件用u8编码
* java -Dfile.encoding=gbk -cp bin Main：设定运行时编码
* JDK17及之前file.encoding和javac默认为代码页；JDK18默认为U8。改回原行为用=COMPAT，取得代码页编码用System.getProperty("native.encoding")或System.console().charset()
* 如果直接用java命令行运行.java，file.encoding就也影响硬编码字符串的编码了，Win下就一定存在问题
* 用PS时file.encoding要加引号
* maven：properties `<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>` 不设置时会有warning说构建依赖平台

## 语法

* import导入类，可以用*，默认导入了java.lang.*
* package类似命名空间，顺序要与文件夹匹配；一般一个文件只有一个public类，且要与文件名匹配
* 函数参数不能有默认值；可变参数数组用`类型...`定义
* 异常：Error是严重错误，除RuntimeException以外的异常是Checked Exception，一定要捕获，或在方法参数签名后加throws xxx，可加在main上；catch时可用`|`同时处理多个异常类型
* break和continue支持跳转到label处以跳出多层循环，但label必须紧贴循环语句前边
* byte是有符号的，而C#是无符号的
* main()所在的类不必为public的，且必须有String[]参数
* 所有的包装类都是Number抽象类的子类，不可变，用intValue()解包成int

### switch和模式匹配

```java
// 只记录java14的，不需要写break
String fruit = "apple";
int opt = switch (fruit) { // 表达式，有返回值
    case "apple" -> 1;
    case "pear", "mango" -> 2;
    case String s when !s.isEmpty() -> ... // 类型匹配+守卫，且null不会匹配进去
    case null -> ... // 目前正在preview。传统上如果对象是null，会在switch一开始就抛NPE
    default -> { // sealed的接口无需此句
        int code = fruit.hashCode();
        yield code;
    }
}; // 要有分号

if(!(o instanceof String s))
    return;
// 运行在这个范围内使用s。但如果if中又用了o就不行了

o instanceof Point(int x, var y) // 匹配record，绑定多个变量
for(Point(...): points) // 可能出现在JDK20
```

## 字符串

* 多行字符串为三个双引号，开始时必须要换行且此换行不算内容，以结束时的引号为对齐基准去掉前面的缩进，转义仍有效，不支持raw string
* 其它类型转换为字符串：String.valueOf，字符串转为其它基本类型：Integer.parseInt，可设定基数；Integer.toHexString把整数转换为十六进制字符串；Integer.getInteger与System.getProperty一样，是获得系统属性的值，垃圾命名
* 判断相等用equals；推荐用Objects.equals()，不用判断是否为null
* 取字符必须用charAt()，不支持索引器
* 函数
  * contains、[last]indexOf、startsWith、substring、isEmpty、isBlank
  * replace、replaceAll 正则、split 正则
  * strip[Leading/Trailing] 如果只有ASCII字符也可用trim
  * formatted/String.format C风格，也可都用%s
  * toCharArray、getBytes 转换回来用构造函数，第二个参数指定编码
  * lines 按换行符分隔返回Stream
  * chars 变为Stream
* StringBuilder：和C#一样，不线程安全，但delete方法第二个参数是index而不是length；StringBuffer更老单线程性能差多线程安全
* java.text.MessageFormat.format()：类似C#，但模式要先new出来
* String.valueOf(nullobj)为"null"，C#为""
* StringJoiner：支持设定开头、结尾、分隔符。new出来，add，toString。一般String.join()更方便

## 类

* 复用构造函数在函数体内用this()；调用父类成员用super
* 类和接口的继承：extends关键字。实现接口：implements关键字。abstract class可以有字段
* 接口：可以有字段，隐式public static final。接口里的函数可以在声明前面用default关键字实现默认方法，但不能访问字段，可以访问私有方法
* 重写：@Override。默认public函数都是虚函数，这个注解只是帮助检查
* final关键字：用在未初始化的字段上和参数上相当于C的const，用在初始化了的字段上相当于C#的const，用在函数上会阻止重写（private函数都隐式final），用在类上阻止继承
* 没有访问修饰符的类和字段为package包作用域，能被同包的普通类和public类使用，无需import，不会被其它包import，等价于C#的internal；protected等价于C#的protected internal
* 内部类
  * 普通类不能用private，内部类才可以
  * 如果内部类没有private，就也为包作用域，但在外部使用必须从外部类的对象实例化：`Outer.Inner inner = outer.new Inner()`
  * 内部类对象内部能直接访问外部类对象：`Outer.this.xxx`，能修改外部类的private成员。外部类对象在类种也能访问内部类的private成员
  * 用static修饰内部类就不再依附外部类对象了，仍可实例化，编译后就是不相关的两个类。不存在C#的静态类的概念
  * 可用于Lazy单例模式：静态内部类创建final static instance=C()，外面定义getInstance()返回inner.instance
* 匿名类：`var obj = new 接口名或父类名(){类成员代码}`，用于一个类中包含另一个类，且省去定义内部类再实例化。C#无此功能
* 静态代码块：`static {...}`，类似于静态构造函数
* 静态函数可通过对象调用，且对象为null也可以，不过会有Lint警告
* record Point(int x, int y) {}
  * 定位是命名元组，不是用于封装数据的
  * 自动生成构造函数、不可变成员、toString、equals、hashCode
  * 检查范围：public Point{if(x<0) throw new IllegalArgumentException();} 称为Compact Constructor，写不含参数的构造函数且无需自己给成员赋值
  * 在模式匹配中可用类似于构造函数的语法解构成员并使用，且可用var
* 枚举：可用==比较两个对象，可定义方法
* Finalize()废弃了，用Cleaner机制替换
* Objects.requireNonNull(obj)
* 让类支持try-with-resources：实现AutoCloseable接口的close()
* JavaBean：getXXX、setXXX。boolean字段的getter的命名为isXxx
* 注解
  * 创建：@interface A{int i() default 0; String value() default "";}
  * 还可加@Target指定注解能用在什么上。@Retention指定生命周期，默认为CLASS，一般要改成RUNTIME。@Repeatable允许重复使用。@Inherited使用时子类可以继承父类使用的
  * 应用：@A("value的值", i=123)
  * 反射读取：C.class.isAnnotationPresent/getAnnotation(A.class);

## 泛型

* 泛型方法与C#相比`<T>`需放在返回值前；静态泛型方法可声明于泛型类中，但调用时无需也不能具体化泛型类，实际与泛型类的泛型无关系
* 类型擦除
  * 不能放基本类型
  * 泛型方法自动推断时会转换成对应的包装类型
  * `C<A>.class == C<B>.class == c.getClass() == C<Object>.class`
  * 不能new T()因为相当于new Object()。变通手段是创建带有Class参数的函数，反射创建实例
  * public boolean equals(T t)会变成equals(Object t)导致与继承自Object的冲突，不过编译器会自动阻止
  * 不能判断带泛型的类型：`o instanceof C<Object>`编译错误，只能用`C`
  * 不能new泛型类型数组，只能new非泛型版的，再在前面加 @SuppressWarnings("unchecked")，但`List<List<String>>`却又没事，不懂。也可用反射创建：(T[])Array.newInstance(cls,5)
* 可变性
  * 协变用`类型名<? extends T>`，称为上界通配符；逆变用super
  * 声明在函数参数或变量的类型后，一般直接具体化，可直接用于类，不是声明在类和接口的定义上，之后编译器会限制此变量所使用的方法中T在哪种位置
  * 定义泛型类的时候也可以加`类型名<? extends T>`，但这类似于C#的泛型约束
  * 比C#更灵活，因为可以不用类作者更改代码。
  * 例子
    * `List<? extends String>`表示只读集合，但仍能调用set(null)；逆变可表示只写集合，仍能用get()但只能赋给Object
    * `static <T> void copy(List<? extends T> src， List<? super T> dest)`：不修改src，不读取dest
  * `<?>`既不能读也不能写，只能做一些null判断，是所有`<T>`的超类。一般用泛型方法代替。`Class<?>`中用到
  * extends A & B：取二者子类型的交集，同时实现了AB接口
* 泛型约束：类的泛型定义中`<T extends R>`

## 数组和容器

```java
import java.util.*;

String[] arr = {"one", "two"};
Arrays.toString(arr); // 结果类似Py；二维数组int[][]用Arrays.deepToString()
Arrays.sort()/parallelSort() // 升序排序，需要元素类型实现Comparable<T>
Arrays.copyOf() // 浅拷贝，第二个参数可用于数组扩容
Arrays.Equals()
System.arraycopy() // 相当于memcpy的高效方法
int[]转Integer[]好像只能用stream
for(final int item: arr) // foreach，也可用var

List<Integer> lst = new ArrayList<>(); // 不接受数组作为参数，只接受其它容器，会浅拷贝
lst = List.of(1, 2, 3); // 只读，set运行时报UnsupportedOperationException，想写可再传给ArrayList的构造函数；也能传Integer[]对象转List，不是包装，仍只读，但不能是int[]；copyOf接受其它容器；不要用Arrays.asList，是包装且非只读且不是普通的ArrayList；lst.subList()返回的是一个内部类的视图，且父列表增加删除后不能再用子视图
Integer[] arr = lst.toArray(Integer[]::new); // 或new Integer[0]，实际是复制到实参数组中，长度短了会自动扩展，长了的会设为null；无参使用只返回Object[]
lst.add()/remove()/get()/set()/removeIf() // 不能用[]获取元素
Collections.sort(lst)

Map<String,Integer> map = new HashMap<>(); // 还有Map.of(k1,v1,k2,v2)或Map.ofEntries(...)。不要用双大括号来初始化
map.put(...)/get()/containsKey()/keySet()
for (Map.Entry<String,Integer> entry: map.entrySet())
Map<DayOfWeek, String> map = new EnumMap<>(DayOfWeek.class); // Key是枚举时用此类效率最高
// SortedMap = TreeMap：红黑树，类型必须实现Comparable接口的compareto

Deque<T> dq = new ArrayDeque/LinkedList<>(); // 替代Stack，提供push()/pop()/peek()，对应dq的xxxFirst；也继承了Queue，对应dq的xxxLast
dq.addFirst/Last()/remove()/get()失败时抛异常，offer()/poll()/peek()失败时返回false或null，因此避免把null添加进去

// 重写equals和hashCode，@Override略。List/Set.contains()，Map.get()等会用到；hashCode对于相同对象一定要相等，不同对象尽量不等
public boolean equals(Object o) {
    if (o instanceof Person p)
        return Objects.equals(this.name, p.name) && this.age == p.age;
    return false;
}
int hashCode() {
    return Objects.hash(firstName, lastName, age);
}

Collections.reverse() shuffle()
LinkedHashMap：遍历时能按插入顺序
PriorityQueue：需要对象实现Comparable接口，取出时小的在前面

java.util.concurrent：CopyOnWriteArrayList、ConcurrentHashMap、CopyOnWriteArraySet、LinkedBlockingDeque


不用的：
Collections.synchronizedList、Vector
Collections.unmodifiableList：包装普通的List，拦截修改
Hashtable：线程安全的HashMap，没必要用。哈希表用HashSet
Properties：用于读写.properties文件。load(getClass().getResourceAsStream("/default.properties")); 从jar包或classpath中读取资源
```

## IO

* 各种流读文件时都要关闭，可用try(resource)；如果用了包装，最外层的关闭即可
* Filter模式，接受一个InputStream，仍返回该类型，但内部已经包装了，减少继承链
* Scanner和老的流的默认编码受file.encoding影响，默认为代码页，读文件时记得指定编码
* 环境变量：System.getenv()
* 第三方库：okio

```java
System.out.print()/println()/printf()
var scanner = new java.util.Scanner(System.in);
scanner.nextLine()/nextInt()/next()默认以空格分隔返回String。findAll("xxx").map(MatchResult::group)、findInLine()
System.console().readLine()/readPassword() 在jshell下不存在

import java.io.*;
try (InputStream ins = new FileInputStream("readme.txt"/FileObj)){ ... } // 字节流无需设定编码，一般还加一层BufferedInputStream，之后可用Scanner
ins.transferTo(os)
Reader reader = new FileReader("readme.txt"/FileObj, StandardCharsets.UTF_8)/StringReader("Hello")/InputStreamReader(ins, "UTF-8");
var br = new BufferedReader(reader); br.readLine(); // 这样才能读一行
PrintStream：属于OutputStream，支持一组print()/println()打印各种数据类型，System.out就是；一般用PrintWriter包裹其他Writer来用
ByteArrayOutputStream 内存字节流。StringWriter 可toString()

import java.nio.file.*; // 替代File，默认编码UTF_8，不跟随系统
Path p = Path.of("..", "project").toAbsolutePath().normalize();
Files.readString(p.resolve("data.txt"))/readAllLines()/readAllBytes()/writeString()/write(p,lines/bytes)/newInputStream()
Files.lines()/list()/walk() // 返回stream，需要关闭但可用在try()中
Files.newDirectoryStream() // 等于list但可foreach，需要关闭
Files.newBufferedReader(p).readline()
Files.exists()/isRegularFile()/isDirectory()
Files.delete()/deleteIfExists() // 对于文件夹，必须非空；没有自带递归删除的方法，可以和walk配合遍历删
```

### Socket

* UDP很复杂，用DatagramSocket和DatagramPacket，自己处理byte[]

```java
import java.net.Socket;
var s = new Socket(ip,port); // 客户端，指定要连接的地址
try(var in = s.getInputStream(); var out = s.getOutputStream()){
    handle(in,out); // 里面把两个stream用缓冲读写器包一下再使用，用完了一般要flush()
}

var ss = new ServerSocket(port); // 服务端，指定绑定的端口
while(true){(new Thread(new Handler(in,out))).start()}
```

## 函数式

* 接口
  * 单方法接口（但可有默认方法）用`@FunctionalInterface`注解（不强制使用，使用后如果有多个方法会编译期错误），可用Lambda表达式代替匿名类隐式实现接口（C#办不到）`(s1, s2) -> s1.compareTo(s2)`
  * 方法引用：用双冒号。可引用实例方法，则相当于隐式添加第一个参数this，如`String::trim()`，C#做不到
* java.util.stream.Stream
  * 惰性，链式map().filter().sorted().limit().distinct()，聚合操作才进行计算.sum()/reduce()
  * stream转List和其它：collect(Collectors.toList()/toSet()/toMap()/joining())，toArray(String[]::new)，直接toList()是不可变的。Collectors.groupingBy(Function.identity(), Collectors.counting())转为Map
  * parallel()自动多线程，concat()连接两个stream，flatMap()把`stream<List<T>>`变成`stream<T>`相当于SelectMany，mapMulti允许处理每个元素
  * map.entrySet().stream().max(Map.Entry.comparingByValue())
  * anyMatch() allMatch()
  * mapToObj() mapToInt()：普通的map()传lambda时没有问题，但无法直接接受函数，会无法推断类型
* Arrays.stream(arr)返回IntStream能提高效率，它toArray()能返回int[]；普通的装箱stream转它用mapToInt(Integer::valueOf)，它转装箱的用boxed()
* `Optional<T>`
  * 原意是替代null，但不可序列化
  * 创建者返回空时用Optional.empty()；一定有值时返回Optional.of(xxx)，如果xxx为null会抛异常
  * 调用方用if(op.isPresent())判断是否有结果，get()获得结果
  * 还能用于流式处理：用ofNullable包裹原来的可能为null的值，用map()等链式处理，如果值为null不会抛异常，只会视为empty()。最后用orElse(null)/orElseGet(fun)/orElseThrow()取出来
* 无法方便地从Iterable转换成Stream，只能`StreamSupport.stream(it.spliterator(), false)`，Guava实现了；Stream转Iterable可以强转s::iterator，但还是很麻烦
* `Predicate<T>`：可以把多个函数用and() or() negate()串联起来，还有not()静态方法，isEqual()静态方法
* Objects::isNull、nonNull；Character::isAlphabetic、toLowerCase
* foreach：不能用(i->sum+=1)因为要求闭包的变量是final的
* java.util.function

## 反射

* java.lang.reflect.*
* Class cls = String.class / int.class / s.getClass() / Class.forName("java.lang.String") 它们都有泛型版
* getParameterizedType() 获得当前类的泛型类型
* Field f = getField(name)根据名字获取包括父类的公共字段，getDeclaredField(name)不包括父类但可获取私有字段，getFields()略；f.setAccessible(true)后f.get(o)可访问私有字段
* getMethod(), getReturnType(), getParameterTypes(), getModifiers(), invoke()
* getConstructor(构造函数的参数对应的clazz).newInstance()
* getSuperclass(), getInterfaces()
* obj instanceof String s；cls.isAssignableFrom(cls2)。nullobj instanceof xxx -> false
* 引入泛型后有xxxType与Class继承Type
* 浅拷贝：Object自带一个protected的clone()，自定义类implements Cloneable接口用super.clone()就能实现浅拷贝；此接口实际上什么也不包含，但如果不实现它直接调用clone()就会抛异常
* 深拷贝：序列化再反序列化，bao = new ByteArrayOutputStream(); new ObjectOutputStream(bao).writeObject(this); new ObjectInputStream(new ByteArrayInputStream(bao.toByteArray())).readObject()

## HttpClient

* 第三方库：okhttp retrofit，同一组织出的，后者用于把restapi封装成易使用的类

```java
var client = HttpClient.newHttpClient(); // JDK11
var request = HttpRequest.newBuilder() // URI也可传进这里面
    .uri(URI.create("https://javastack.cn")).header(k,v).timeout(duration).GET().build();
// 同步
HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
System.out.println(response.body());
// 异步
client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
    .thenApply(HttpResponse::body)
    .thenAccept(System.out::println);
```

## 正则

```java
var p = Pattern.compile(...);
var m = p.matcher(str);
m.matches();
m.group(n);
Pattern::asPredicate // 用在filter中
```

## 日期和时间

* 时间戳：System.currentTimeMillis()，类型为long的毫秒。另外long字面量要加L后缀
* java.time新API：Month的范围是1-12，Week的范围是1-7表示周一到周日
* 日期：LocalDate .now() .of(年,月,日) .parse("2019-11-19")
* 时间：LocalTime .now() .of(时,分,秒) .parse("15:16:17")
* 日期和时间：LocalDateTime .now() .of(d,t) .of(年,月,日,时,分,秒) .parse("2019-11-19T15:16:17"); dt.toLocalDate() .toLocalTime()
* 链式运算：dt.plusDays(5).minusHours(3).withYear().withDayOfMonth().with(TemporalAdjusters.firstDayOfNextMonth())
* 比较：dt.isBefore/isAfter(target)
* 两个DT的差值：Duration.between(start, end) / ofHours(9)，转换为字符串后类似PT1235H10M30S表示1235小时10分钟30秒
* 两个Date的差值：d1.until(d2)，Period类型，类似P1M21D表示1个月21天
* DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
  * dtf.format(dt); dt.parse("...", dtf); dtf.withLocale(lo)
  * M为9，MM为09，MMM为Sep，MMMM为September
  * E表示英文星期如Sun，EE表示中文星期，使用时第二个参数传Locale.US/CHINA
  * ZZZZ表示时区，如GMT+08:00
  * 预定义了几个静态格式，如.ISO_DATE.format(dt)、.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT)
  * 默认按照ISO 8601处理
* ZonedDateTime
  * .now() .now(ZoneId.of("America/New_York")) 是同一时刻
  * dt.atZone(ZoneId.systemDefault()/ZoneId.of("America/New_York"))) 给LocalDateTime附加时区，时间不变，时区不同，不是同一时刻
  * zdt.withZoneSameInstant(ZoneId.of("Asia/Shanghai")) 时刻不变，转换时区，转换时间，再.toLocalDateTime()就丢掉了时区
* Instant.now()
  * ins.getEpochSecond() 秒，.toEpochMilli() 毫秒
  * ins.atZone(...) ZDT.ofInstant(ins, ZoneId.of(...)) 时刻转ZDT
  * Instant.ofEpochMilli(milli) 时间戳转时刻
* java.util旧API：Date Calendar TimeZone。旧转新：对前两者实例使用.toInstant()再变成ZDT，后者用.toZoneId()

## 多线程

* Thread
  * 可以创建一个类继承它，重写run()。可以创建类实现Runnable接口的run()。可以传()->{...}
  * t.start(); t.join(毫秒); t.setDaemon(true);守护线程不影响主线程退出，不应持有需要关闭的资源
  * 睡眠：Thread.sleep(毫秒)、Thread.sleep(Duration.ofSeconds(秒))、java.util.concurrent.TimeUnit.SECONDS.sleep(秒)
  * 无需import
  * 新版创建方法：Thread.ofPlatform().daemon().start(runnable)
  * 中断：调用者t.interrupt()，线程里自己检测isInterrupted()，这种方式必须用继承。也可以用volatile变量running
  * 获得返回值：var ft = new FutureTask<>(()->...)，传进Thread，ft.get()
* synchronized
  * 一般在方法上加，相当于整个方法体synchronized(this)
  * 也可以自定义Counter类，static final Object lock = new Object()，使用时synchronized(Counter.lock){...}
  * 是可重入锁。无论是否有异常都会在结束时释放锁
  * 消费者获得锁后若发现不满足条件，可循环调用预定义在Object上的wait()，另一线程生产者在相同锁对象上notify()/notifyAll()。它们是native方法，会释放锁
* AQS锁
  * ReentrantLock：和手动使用synchronized差不多，但允许tryLock()指定超时，更不容易死锁；lockInterruptibly()允许线程被中断。要在finally释放
  * Condition：代替wait和notify
  * ReadWriteLock
  * StampedLock：与ReadWriteLock类似，但是读乐观锁，读时也允许获取写锁后写入，需要读完一条后validate()一下，如果发现有写入再加普通读锁重读。不可重入
  * Semaphore：保护数量有限的资源，require和release
* 原子操作
  * java.util.concurrent.atomic：AtomicInteger AtomicIntegerArray LongAdder对自增友好
  * incrementAndGet()
  * 单条赋值语句，引用类型、除了long和double的基本类型，是原子的。long和double在x64上是原子的
  * 属于CAS(Compare and Swap)操作，乐观锁，具有ABA问题：两个线程分别取出值A，第一个线程改成B又改回A，第二个线程CAS操作能成功。解决办法是通过版本号，配合AtomicStampedReference使用
* 线程池：ExecutorService es = Executors.newFixedThreadPool(4); es.submit(runnable); es.shutdown()等待完成/shutdownNow()不等待/awaitTermination()等待一段时间
  * CachedThreadPool 线程数根据任务动态调整，SingleThreadExecutor 仅单线程执行，ScheduledThreadPool 可定期反复执行或提交后隔一段时间再执行 可取代java.util.Timer
  * execute()无返回值直接抛出异常，submit()返回Future，等get()时抛出异常。也支持实现了`Callable<T>`接口的`T call()`对象，返回`Future<T>`，可以get()取值
  * CompletableFuture：用回调方法避免普通的future get时阻塞
  * ForkJoinPool：把大任务拆分成小任务最后合并。太复杂了
* ThreadLocal：在一个线程中横跨若干方法调用需要传递的对象称作上下文，给每个方法增加一个context参数非常麻烦。用此对象，先声明`static final ThreadLocal<String> ctx = new ThreadLocal<>();`，创建者try{ctx.set(o); step1(); step2()}finally{ctx.remove()}，使用者ctx.get()。可以看作一个全局的`Map<Thread, Object>`
* 虚拟线程
  * Thread.startVirtualThread(runnable) 创建并执行
  * Thread.ofVirtual().unstarted(runnable) 创建但不执行
  * Thread.ofVirtual().factory(); fa.newThread(runnable)
  * 都是守护线程，不支持stop suspend
  * 执行synchronized和本地方法中无法换出，用ReentrantLock则可以
  * Executors.newVirtualThreadPerTaskExecutor

## 其它内置库

* 文档：https://docs.oracle.com/en/java/javase/19/docs/api/index.html
* Math
* java.math.BigInteger：创建用new，运算用实例方法，转换成基本类型用.longValueExact()
* BigDecimal：scale()表示小数位数，负数表示是整数且末尾有0，setScale()指定小数位数和舍入方式；加减乘时精度不会丢失，但除法除不尽时要指定精度和如何截断；divideAndRemainder()可以做除法的同时求余数；equals()要求值和scale()都相等，一般应该用compareTo()，或先用stripTrailingZeros()
* JavaEE的javax名称空间现在变为了jakarta，不过还是有几个类在前者里
* java.net.URLEncoder/URLDecoder：会把空格编码成加号
* java.util.Base64.getEncoder().encodeToString(bytes)。还有一种getUrlEncoder()，把+变成-，/变成_
* 哈希：java.security.MessageDigest.getInstance("MD5").update(bytes).digest(); new BigInteger(1, result).toString(16)
  * HMAC：javax.crypto.MAC.getInstance("HmacMD5").init(key).update().doFinal()
* 随机数：Random类；java.security.SecureRandom.getInstanceStrong()，一般用nextBytes填充buffer。JDK17：RandomGenerator.getDefault()
* 密钥生成器：javax.crypto.KeyGenerator.getInstance("HmacMD5").generateKey();

## GC调优

* G1默认最大暂停200ms
* 现在64位的JDK只有Server模式，-client参数会直接忽略
* -Xmx512m：最大堆大小。ms是最小和初始堆大小
* -XX:+UseLargePages：大内存如16G时启用，还需设置/sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages，值至少为16G/2M=8192
* -XX:+AlwaysPreTouch：启动jvm时真实分配那么多内存，能减少延迟卡顿
* 显示当前使用了哪种GC以及运行过程中的调用情况：-Xlog:gc+stats：
* 避免用户乱调用System.gc()：-XX:+DisableExplicitGC
* 在GC时合并重复的字符串：-XX:+UseStringDeduplication 不清楚是否仅限G1
* 不进行GC：-XX:+UnlockExperimentalVMOptions -Xlog:disable -XX:+UseEpsilonGC
* 禁用析构函数：--finalization=disabled JDK18后支持
* -XX:+UseShenandoahGC：也是低延迟，适用于Web服务端。目前OpenJDK和OracleJDK的编译版都不包含
* -XX:+UseZGC：延迟低，最好设置mx；CPU负荷最好小于70%。借鉴了Azul的C4算法
* -XX:SoftMaxHeapSize=1G：要求VM尽量不超过此值规定的最大堆大小，仅限ZGC
* 查看当前选项包括所使用的GC模式：java -XX:+PrintCommandLineFlags -version，查看包括默认值在内的所有选项：-XX:+PrintFlagsFinal

## Maven

* https://maven.apache.org/download.cgi 的Binary zip archive
* 初始化：mvn archetype:generate -B -DgroupId=com.company.project -DartifactId=project
  * 会生成project文件夹，里面有pom.xml src test。src里有main和test，main里有java和resources
  * 包名与groupId相同，也可用-Dpackage指定
  * 无法直接在CWD生成
  * 实际上以-DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-quickstart -Dversion=1.0-SNAPSHOT为默认值
  * properties必须设置maven.compiler.source和target，用release无效，否则默认为1.5。TODO：不知道设置java.version行不行
* 运行：mvn exec:java -Dexec.mainClass=com.company.project.App -Dexec.args="arg1 arg2" 也可写进properties里。加-q不会显示maven的信息但也不会显示traceback
* 流程：内置了default、clean等声明周期，每个生命周期又包括多个phase，每个phase又会触发goal。mvn命令后跟的就是phase，冒号后跟的就是goal。大部分phase默认什么也不做
* 常见命令
  * mvn clean 删除target文件夹
  * mvn clean compile 先清理再运行到compile，生成class文件到target目录。单纯compile只会编译未编译的文件，不会自动clean，以下略
  * mvn test 包含了compile
  * mvn package 打包生成jar到target目录
  * mvn install 把当前项目打包到本地仓库作为依赖供其它项目使用
* POM可以继承，默认就有一个SuperPOM。写parent元素，groupId:artifactId:version，relativePath指定parent.pom的相对路径。查看解析后的：mvn help:effective-pom
  * build模块，把所有模块放到一起编译：modules里写module写../xxx，无需继承，编译这一个pom即可
* properties里写的东西在别的地方可用${xxx}使用
* 生成文档：mvn site。不知道要不要手动装插件
* 额外插件：https://spotbugs.github.io/ 静态分析。maven-shade-plugin将依赖也一起打包

### 依赖

* 添加依赖：在仓库搜索想要的包后看示例添加进pom，没有命令行添加的功能
* 下载依赖：mvn dependency:resolve 一般用于添加后第一次使用，或者更新SNAPSHOT的
* 默认依赖包存放位置（本地仓库）：$HOME/.m2/repository
* （中央）仓库：https://central.sonatype.dev https://search.maven.org/ https://mvnrepository.com/
* 镜像：https://maven.aliyun.com/mvn/guide
* dependency.scope：默认是compile表示编译时需要用到该jar包，还可以是test如junit、runtime如JDBC驱动因为自带接口只需要运行时用jar编译时不用、provided如servlet-api
* 指定本地的jar依赖：dependency.systemPath ${basedir}\src\lib\xxx.jar
* 版本：[1.0,2.0)、[1,)。但这样指定会把所有大于1的版本都下下来。用mvn versions:resolve-ranges会替换为具体版本
* 更新具体版本：mvn versions:use-latest-releases、mvn versions:display-dependency-updates
* 递归查看所有依赖：mvn dependency:tree
* java里import的东西会在用到时才去找jar，而不会在编译期报错。可在Main里用Class.forName(xxx)缓解

## Json

* 暂时不学的：moshi，okhttp组织出的

```java
// com.google.code.gson:gson:2.10
import com.google.gson.Gson;
Gson gson = new Gson();
Gson gson2 = new GsonBuilder().serializeNulls().create(); // 默认序列化时会忽略值为null的
gson.toJson(obj);
gson.fromJson(jsonstr, clazz/int[].class/new TypeToken<Map<String, String>>(){}.getType())
类字段注解：@SerializedName、@Expose
TODO: https://www.studytrails.com/2016/09/12/java-google-json-introduction/

// com.fasterxml.jackson.core:jackson-databind:2.14
ObjectMapper mapper = JsonMapper.builder()
    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false) // 默认为true，设为false后当JSON存在Bean没有的字段时不报错
    .configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true) // 反序列化record时使用
    .setPropertyNamingStrategy(PropertyNamingStrategies.LOWER_CASE); // 序列号record时使用 TODO:普通类的序列化策略是什么？如camelcase？
    .build();
mapper.writeValueAsString(obj);
mapper.readValue(input_stream, clazz); // 一般的类要求存在无参ctor，record不必
类字段注解：@JsonIgnore、@JsonProperty("重命名", access = Access.WRITE_ONLY)、@JsonIgnoreProperties(ignoreUnknown = true)
```

## 日志

* 暂时不学的：google/flogger

```java
// java.util.logging
Logger logger = Logger.getLogger(Main.class.getName()); // 或System.getLogger()
logger.severe warning info config fine finer finest // 默认LEVEL是INFO，会记录INFO及之上的
throwing(String className, String methodName, ex)
logger.addHandler(new FileHandler()) // 文件的默认格式为XMLFormatter，冗余信息较多。控制台默认为SimpleFormatter

org.slf4j:slf4j-api:2
ch.qos.logback:logback-core和logback-classic:1.4
static final Logger log = LoggerFactory.getLogger(AppConfig.class);
log.info()
// 若用了Lombok，可在类上加@Slf4j，然后就能log.xxx了
```

## JUnit

* junit:junit:4.13 TODO:junit5
* 测试代码文件名：xxxTest.java
* assertEquals()比较浮点数时有一个重载指明精度
* assertTrue() assertFalse() assertNotNull() assertArrayEquals()
* @Disabled：临时禁用，仍识别为测试方法，只是会跳过。@EnabledOnOs(OS.WINDOWS)，@EnabledIfEnvironmentVariable(k="v")
* 另一个包：https://assertj.github.io/doc/ 用于流畅assert。对比：https://annaduldiier.medium.com/assertj-vs-junit-483b7d6dc997

```java
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

public class FactorialTest {
    @Test
    void testFact() {
        assertEquals(1, Factorial.fact(1));

        assertThrows(IllegalArgumentException.class, () -> {
            Factorial.fact(-1);
        });
    }

    @ParameterizedTest
    @ValueSource(ints = { 1,2,3 })
    void testAbs(int x) {
        assertEquals(x, Math.abs(x));
    }

    @ParameterizedTest
    @MethodSource // 从一个同名的静态函数中提供参数。还支持@CsvSource和@CsvFileSource
    void testXXX(int a, int b);
    static List<Arguments> testXXX(){
        return List.of(
            Arguments.arguments(1,2),
            ...
        )
    }

    // Fixture：做准备和清理工作。还有@BeforeAll和@AfterAll在所有Test前后运行一次，但只能标注静态方法
    @BeforeEach // 每个Test都运行一次
    public void setUp() { ... }
    @AfterEach
    public void tearDown() { ... }
}
```

## 数据库

* 不学：jOOQ 性能超差
* PG驱动：https://jdbc.postgresql.org/

### JDBC

```java
import java.sql.*;
Connection con = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWD);
try(PreparedStatement ps = conn.prepareStatement("SELECT ... WHERE id=?")) {
    ps.setObject(1, xxx); // 注意索引不是从0开始
    try(ResultSet rs = ps.executeQuery()) {
        while(rs.next()) {
            int id = rs.getInt(1); // 索引不是从0开始
            String name = rs.GetString("name");
        }
}}
CRUD：ps.executeUpdate()
插入并获取自增主键：prepareStatement第二个参数加Statement.RETURN_GENERATED_KEYS，返回的结果集用getGeneratedKeys()获取
默认处于自动提交模式，用con.setAutoCommit(false)相当于开启事务，try{commit}catch{rollback}finally{改回自动提交}
一次性执行多个相同的模板的数据插入，BATCH模式：反复给ps设置参数后用ps.addBatch()，全部加完后executeBatch()
```

### [MySQL Connector](https://dev.mysql.com/doc/connector-j/8.0/en/)

* Class.forName("com.mysql.cj.jdbc.Driver"); 以前是com.mysql.jdbc.Driver
* JDBC URL：jdbc:mysql://user@password:host:port/db
  * user和password也可以在properties中指定，若含有特殊字符如@和#则不能在前面指定
  * host默认localhost，port默认3306
  * properties用?k=v指定
    * useServerPrepStmts 是否启用服务端预编译，默认为false。若改为true，最好还启用cachePrepStmts和调整prepStmtCacheSize、prepStmtCacheSqlLimit。对于频繁读的语句，可以启用
    * rewriteBatchedStatements=true 可能产生注入？
    * useCompression=true
    * sslMode：默认是PREFERRED，当服务端启用时启用。其他值包括 DISABLED、REQUIRED服务端不启用时报错、双向验证的两种
    * 不要启用autoReconnect
    * allowMultiQueries：默认一个SQL语句只能有一个SELECT，启用后可以有多个，会产生多个结果集，变复杂

```xml
<!-- 还需要装一个SLF4J的实现才能用日志 -->
<dependency>
    <groupId>com.mysql</groupId>  <!-- 以前叫mysql -->
    <artifactId>mysql-connector-j</artifactId>  <!-- 以前叫mysql-connector-java -->
    <version>[8,)</version>
    <exclusions>
        <exclusion>  <!-- 不使用X DevAPI时添加此排除 -->
            <groupId>com.google.protobuf</groupId>
            <artifactId>protobuf-java</artifactId>
        </exclusion>
        <exclusion>  <!-- 不使用OCI AIM验证时添加此排除 -->
            <groupId>com.oracle.oci.sdk</groupId>
            <artifactId>oci-java-sdk-common</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

### HikariCP

* com.zaxxer:HikariCP:5
* connectionTimeout默认30秒，是等待从池里取出连接的时间。maximumPoolSize默认10。autoCommit默认为true

```java
HikariConfig config = new HikariConfig(); // 也可传Properties对象
config.setJdbcUrl(JDBC_URL); config.setUsername(xxx); config.setPassword(xxx); config.addDataSourceProperty(k,v)
HikariDataSource ds = new HikariDataSource(config); // 也可对它设置
try (Connection conn = ds.getConnection()) { ... }
```

### [JDBI](https://jdbi.org/)

* org.jdbi:jdbi3-core和jdbi3-sqlobject:3.36
* ObjectAPI可以自动释放资源，withHandle中的语句在create后要加.attachToHandleForCleanup()
* 可以和HikariCP结合使用，具体见文档

```java
Jdbi jdbi = Jdbi.create(JDBC_URL);
List<T> l = jdbi.withHandle(hnd -> { // 流畅API。不返回值用useHandle
    hnd.execute(SQL, params); // 占位符支持?和:key，参数支持多种绑定方式
    hnd.createUpdate(CRUD).bind(0-based-ndx,val).bind(k,v).bindBean(obj).execute();
    return hnd.createQuery(SELECT) .mapToBean(clazz)/mapToMap() .list()/collect(Collectors.toSet())/.useStream(s->...);
    hdn.select().mapTo(String.class).one()/first();
});

public interface UserDao {
    @SqlUpdate("INSERT INTO \"user\" (id, \"name\") VALUES (?, ?)")
    void insertPositional(int id, String name);

    @SqlUpdate("INSERT INTO \"user\" (id, \"name\") VALUES (:id, :name)")
    void insertBean(@BindBean User user);

    @SqlQuery("SELECT * FROM \"user\" ORDER BY \"name\"")
    @RegisterBeanMapper(User.class)
    List<User> listUsers();
}
jdbi.installPlugin(new SqlObjectPlugin());
jdbi.withExtension(UserDao.class, dao -> {
    return dao.listUsers();
}
```

## 第三方库

* 文档：https://javadoc.io
* jsoup：HTML请求和解析库，支持css选择器
* guava：不可变集合、检查非空、Multiset/map、自定义行为的字符串Splitter和Joiner、简单的缓存类
* netty：代替nio做socket编程
* zxing：等学安卓再说，而且它现在处于维护模式
* hutool：国产工具库，农历、汉字转拼音、身份证合法性、定时任务、图形验证码、Excel操作、RSA加解密、哈希
* apache/nutch：通用爬虫
* 轻量级微服务Web框架：Quarkus，RedHat的。Micronaut，Graal的。Helidon，Oracle的
* awaitility：用于多线程异步测试

## TODO

* https://github.com/Snailclimb/JavaGuide
* http://www.monkey1024.com/javaseroute 看：Java的新特性
* https://dev.java/learn/ https://github.com/doocs/advanced-java https://www.baeldung.com/java-tutorial https://books.trinket.io/thinkjava/ https://programming.guide/java/
* JEP 424 新的调用本地函数的API，还在孵化。jextract从C头文件中生成java绑定
* javadoc：http://www.herongyang.com/Java-Tools/javadoc-The-Java-Document-Generator.html
