---
title: C语言笔记
---

47.size_t和长度和溢出

```c
void* memcpy(void* dest, void* src, size_t n);
#define KSIZE 1024
char kbuf[KSIZE];

int copy_from_kernel(void* user_dest, int maxlen) {
    int len = KSIZE<maxlen ? KSIZE:maxlen; // 当maxlen为负数时，len为负数
    memcpy(user_dest, kbuf, len); // 隐式转换成无符号的超大数
    return len;
}
------------
// https://coolshell.cn/articles/11466.html
// 即使用了unsigned，如果进行了加法/乘法，仍然可能出错：
unsinged a=...,b=...;
int buffer[256];
if((a+b)>256){...} //a+b为小于2^32的大数，相加后可能溢出到小于256，导致检查失效
正确的做法：
void foo(int m, int n) {
    size_t s = 0;
    if ( m>0 && n>0 && ( UINT_MAX - m < n ) ){
        //error handling...
        return;
    }
    s = (size_t)m + (size_t)n;
}
------------
// 保证加法不溢出（乘法就太复杂了）
#include <limits.h>
void f(signed int si_a, signed int si_b) {
    signed int sum;
    if (((si_b > 0) && (si_a > (INT_MAX - si_b))) ||
        ((si_b < 0) && (si_a < (INT_MIN - si_b)))) {
        /* Handle error */
        return;
    }
    sum = si_a + si_b;
}
------------
int strlonger(const char *s1, const char *s2) {
return strlen(s1) - strlen(s2) > 0;
}// s1小于s2时，超大无符号数与0进行比较；其实用strlen(s1)>strlen(s2)即可
-------------
malloc时需要检测乘法是否溢出。
-------------
size_t代表了对象（包括数组、结构体）的支持的最大大小
```

65.1 变量和函数的多次声明

* 具有extern或static的对象的声明可多次出现，但作用域内的参数和返回值及它们的qualifiers（const、restrict等）必须相同，否则报error
* struct、union的声明可用重复；非VLA的typedef可以重复但类型不能变
* 变量的extern、static、无储存类混用：先static再extern不报错，extern和无不报错，其它情况报错；总地来说都只会指向本文件中唯一定义的变量
* 函数会出现声明和定义不同的情况，而且还会出现多次声明不同的情况。要是说明是未定义行为那还好，关键是连警告都没有，研究起来太复杂了
