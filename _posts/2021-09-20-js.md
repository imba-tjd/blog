# JavaScript

* 严格模式：在文件或函数的开头加上 'use strict'，之后访问undefined的会抛异常、禁止this指向顶层对象、不允许删除函数和变量、禁止八进制、变量必须先定义才能赋值等。class和module自动为严格模式
* 某些原地改变的函数仍会返回改变后的自身，常见的有reverse()和sort()
* 循环：支持break/continue label
* ES2020：globalThis表示顶层对象
* 换行一般会隐式加上分号，但下一行开头是括号、方括号、正则的/、+-、`时上一行就不会加，且会看作没有空格。其实是本行与下一行无法放在一起解释才会加，像var a = 1的每个空格都可以换行且有效，'123'.length的点前也可换行，return除外

## 变量

* 变量提升：用var声明变量和具名函数定义会隐式变到代码块最前面但不赋值，严格模式也这样
* 循环的大括号里的var不构成作用域，会泄露到外面，严格模式也这样。用let和const解决
* for开头用let，闭包时每次获取到的是不同的变量
* 解构赋值
  * var [,x, y, ...z] = ['discard', 'hello', 'world']
    * 交换两个变量：[x,y] = [y,x]
    * 只要右边的具有Iterator接口，都可以用数组形式解构
  * var {name, age, sex:gender, single=true} = person_obj
    * 可以取到继承的，如果不是对象会转成对象
    * 冒号相当于gender=person.sex，实际上是pattern，如 var { toString: s } = 123
    * 等号表示默认值，如果person没有single属性则赋为true，否则默认为undefined。此默认值表达式是惰性的
  * 如果有嵌套，解构的pattern也要对应
  * 如果变量已声明，赋值时可能报语法错误：var x; {x} = {x:100}，需在外面加小括号；模式中一般不能加括号

## 类型

* 以n结尾的数字字面量是BigInt，任意长度的整数
* ES2021允许用下划线分隔数字
* Boolean()：null/undefined/0/NaN/"" -> false，[]/{}/... -> true
* Number
  * 所有数字都用64位浮点储存，某些只有整数才能完成的运算会内部转成32位整数
  * Number()：null/[]/'' -> 0，undefined/{} -> NaN，true -> 1，[123]/['123'] -> 123
  * 大于2^2014/Number.MAX_VALUE的数为Infinite，小于2^-1075的数为0
  * 0b或0B开头的数为二进制，0o开头的为八进制；0开头的严格模式下报错
  * +0和-0一般都当作0，只有作为分母才有区别
  * Number.isInteger()不会转换参数，如传true/false/'0'都是false
  * Infinite
    * 基本符合数学运算规则
    * 0*它和它/它为NaN，与undefined运算返回NaN
    * Number.isFinite(Infinite/NaN/其他所有非数值) -> false。不要用传统的全局isFinite
  * NaN
    * 与任何值都不等，包括它自己。可以反过来用来判断一个对象是不是NaN：a !== a
    * Number.isNaN()：没有坑。不要用传统的全局isNaN
    * 主要出现在字符串解析出错的场合：1-'x' -> NaN
    * 与任何数算数运算都为NaN，进行>和<比较都为false
    * Object.is(NaN,NaN)为true，它还区分+0和-0，其余时候与===相同
* undefined
  * 获取不存在的属性会返回它
  * 无返回值的函数等于返回它
  * 空值合并??：给参数设置默认值，也支持null。以前用||的短路特性，但遇到false或0有意义时会出问题
  * 可选链：?. ?.[] ?.()，不能给它赋值
  * typeof xxx === 'undefined'，当xxx未声明时也可用，此时if就不行了；但如果后面才用let声明就也报错，称为暂时性死区
* 不要使用new Number()、new String()创建包装对象，仅供内部使用。调用原生类型的方法时会自动转换成临时只读包装对象
* symbol类型用于创建对象的唯一标识符
  * Symbol()：创建以参数作为描述的Symbol值(不登记在全局环境)
  * Symbol.for()：创建以参数作为描述的Symbol值，如存在此参数则返回原有的Symbol值(先搜索后创建，登记在全局环境)
  * Symbol.keyFor()：返回已登记的Symbol值的描述(只能返回Symbol.for()的key)
  * Object.getOwnPropertySymbols()：返回对象中所有用作属性名的Symbol值的数组

## 运算符

* 乘方：`**`，右结合
* 无符号右移：>>>
* o instanceof Constructor。'1' instanceof String -> false
* typeof返回字符串：typeof 123 -> 'number'; typeof f -> 'function'; typeof []/{}/null(历史原因) -> 'object'
* 一元运算符与非数字运算会转换成数字：+true -> 1，+'' -> 0
* 比较运算符：两个字符串之间的比较略。如果两者不都是字符串但都是原始类型，转成数字进行比较。如果有对象，可认为先转成字符串。不支持连续比较
  * '11' < '2'
  * '11' > 2
  * [11] > 2，[11] -> '11'，见上
  * [2] > [11]，都转换成字符串
  * {a:1} >= {b:2}，{a:1} <= {b:2}，因为{a:1} -> '[object Object]'；但{a:1} != {b:2}，此时比较引用
* 严格相等不会做类型转换。非严格相等，两个字符串之间略。都为原始类型则转成数字，对象先转成字符串
  * 1 == true，'' == false
  * '01' == 1，'\n 123 \t' == 123，'0' == 0，'' == 0；Boolean('0') != Boolean(0)
  * [1, 2] == '1,2'，[] == 0，[] != '0'；[1, [2]] -> '1,2'，[] -> ''
  * 'true' != true，因为Number('true') -> NaN
  * null == undefined，例外情况不转成数字
* null和undefined与数字做>或>=比较时会转换成数字，但与数字做==时却不会转换
* 1 && 2 && 3 -> 3，用`!!()`能转成Boolean
* ??的优先级低于+-，高于=。禁止不加括号就与||混合使用
* 去掉小数/取整：1.5 | 0 -> 1，-1.5 | 0 -> -1，或~~1.5，或1.5<<0，但这些最多处理32位整数；~NaN/null -> -1
* []+{} -> '[object Object]'，[]+[] -> ''，原因是[].toString() -> ''。{}+[] -> 0，原因是{}被当作是语句块，而+[]一元运算符把它变成数字
* 1+'1' -> '11'，1-'1' -> 0，'4'/'2' -> 2。总之对于+变为字符串，其他运算符变为数字
* 取小数：1.23 % 1 -> 0.23 不过有精度问题
* 展开操作符`...`：可用于一般数组和iterable的展开，还可用在函数传参上。[...arr]相当于浅拷贝数组或把伪数组转换为真数组，{...o1, ...o2}相当于合并object
* https://dorey.github.io/JavaScript-Equality-Table/unified/

## 字符串

* 单引号双引号都可以，多行字符串用反引号。模板/内插也用反引号，但要用${}，里面可以是表达式，可以嵌套
* 字面量：`` String.raw`1\n2` ``，但内插还是能用。这种紧跟在函数名后面的语法称作tagged template，会处理成特殊的函数调用
* Unicode转义：`\u{xxxxx}`，老式的是`\uxxxx`
* substring()：两个参数都是索引，但end却是右开区间，负数当作0，两个参数中的较小者作为起始点，行为诡异一般不用。substr()第一个参数可为负会倒数，第二个参数是length，不在核心规范中，浏览器都实现了，现在弃用了。slice()同数组的，一般用它
* split()：一般传正则。无参调用不会做切分，''变为字符数组，' '无法处理连续空格和换行符。字符数组转字符串、字符串数组合并：arr.join('')
* localeCompare()：考虑自然语言的顺序，让'B'>'a'
* codePointAt() String.fromCodePoint()：替代charCodeAt和fromCharCode
* replace()支持正则，默认只替换第一次出现的，正则+/g可替换所有的；ES2021添加replaceAll()
* base64：原生有btoa()和atob()，但不能有中文。前者是字符串转成base64，意思是beautiful to awful
* length indexOf() includes() trim() trimStart() trimEnd() startsWith() endsWith() padStart() padEnd() toUpperCase() toLowerCase()
* 其他对象转字符串：+""或String()或.toString()，后者对于数字字面量要用两个点，转换数字时可指定进制，无前缀
* 字符串转数字
  * Number()：如果整体无法成功转换就返回NaN，有不同进制的前缀时自动处理；例子见上文
  * Number.parseInt()/parseFloat()：会从字符串开头尽量转换。对true、null、'' -> NaN，前者第二个参数为进制，不支持前缀
  * 两者都自动忽略首尾空格，以0开头仍看作十进制

## 数组

* 创建：[1,2,3]或new Array(1,2,3)；但构造函数传单个数字参数时产生的是指定长度的空数组，Array.of无此问题
  * 类型化数组：Int32Array、Float32Array
* 给length赋值会直接修改此数组的长度，多出来的部分为空位(hole)，赋0快速清空
* 可以直接超出索引赋值，中间的为undefined；超出索引访问为undefined，严格模式下也无异常；delete arr[1]删除成员后那个位置为undefined
* 原理实际上是对象，[]里的会自动变成字符串
* foreach遍历：ES6 for of，自动跳过undefined；for in仅仅返回索引。iterable类型具有forEach方法用回调
* slice()：两个参数都是索引，但end却是右开区间；可以为负，但start必须在end前否则为空；非原地，无参调用为浅拷贝全部
* indexOf() lastIndexOf() push(变参) pop() unshift(变参)等于lpush shift() reverse()原地
* sort()：原地。无参调用隐式转成字符串按ASCII升序排序，导致[9,10].sort()为[10,9]；传`(a,b)=>a-b`后正常，此自定义排序函数应返回数值而不是bool
* splice(pos, delcnt, 变参)：从指定索引(可为负)删除几个元素作为返回值，再从该位置添加元素。传单个参数会删除后面的全部，等于将原数组在指定位置拆分成两个数组
* concat()：非原地连接数组，可接受任意参数和自动拆开数组，即arr.concat(1,2,[3,4])能添加1,2,3,4
* includes()：相当于其他语言的contains
* Array.isArray(arr)：判断是否是数组。对于arr instanceof Array，假如跨iframe传递，Array会是另一个构造函数
* 伪数组（array-like object如{0:'a',1:'b',length:2}）转换为真数组：[...alike]、Array.from()、[].slice.call(o)
* entries()：类似于Py的enumerate
* copyWithin()：浅拷贝数组的一部分到同一数组中的另一个位置，类似于memcpy()的高性能
* at()：支持负索引的取值，浏览器在2021年6月之后支持
* flat()：默认只展开一层，传Infinity可展开到底；flatMap() 先map再flat只能一层
* 高阶函数
  * map()：传`String`就能把所有元素变成字符串，第二个参数可传对象作为内部调用函数时的this
  * reduce()：[a,b,c].reduce(f)相当于f(f(a, b), c)，第二个参数可指定初始值防止数组为空时报错，f的参数为(acc,cur)，最多为(acc,elem,ndx,arr)；还有reduceRight()
  * filter() every() some() find() findIndex()
  * 可能传给回调函数多个参数，一般是elem,ndx,arr，JS的特性会自动忽略不匹配的。但像['1','2','3'].map(parseInt)却等于[1,NaN,NaN]，这是因为parseInt能接受两个参数，第二个参数产生的额外效果，而map实际上会给回调函数最多传三个参数。正确方式是map(e=>parseInt(e))或用Number
  * 回调函数中注意this的使用，如果要用，有的能传第二个参数，要不就用箭头函数

## object

* 定义时类似于Py的字典
* 定义函数：f:function(){...}。ES6：f(){}
* 键是字符串，即使不加引号
* console.log(o)可以直接显示成员和函数，但toString()后却不行
* 属性不存在时也可以直接赋值
* 获取可枚举属性，包括继承的，不需要iterator接口：Object.keys(o)->['p']；for in遍历它；Reflect.ownKeys()包括不可枚举和Symbol。遍历时首先升序遍历所有数值键，其余的按添加的顺序
* 删除属性：delete o.p，一般返回true，即使属性不存在。无法删除继承的属性
* 是否拥有属性：'p' in o，会搜索原型链；o.hasOwnProperty('p')或Object.hasOwn(o,'p')仅搜索自身，好像是唯一不会搜索原型链的
* 遇到大括号时，JS引擎如果不能确定，就视为代码块，k:视为标签，此时要加括号才能视为语句
* with (o){...}：严格模式禁用。可直接读写o的已有属性，不用加o.；但不存在的属性就等于访问顶层，导致绑定对象不明确和难优化
* ES6直接写`p`相当于`p:p`；key加上中括号后可在里面动态计算，且可用变量
* Object.getOwnPropertyDescriptor()获得属性描述对象，Object.defineProperty()动态定义属性，默认不可修改不可枚举
* 浅拷贝(ES2017)：Object.create(Object.getPrototypeOf(orig), Object.getOwnPropertyDescriptors(orig))

### 原型和类

* 给函数的prototype属性赋一个对象，那个对象就相当于类，但只存放方法；这个函数相当于构造函数，this能访问隐式创建的实例，不要有return，会自动返回this
* prototype还会隐式增加一个constructor属性指向构造函数
* 不要忘记写new，否则this指向undefined/顶层。构造函数不传参时不会报错，访问那些属性为undefined

```js
function Person(id) {
    this.id = id
}
Person.prototype = {
    Say: function() { console.log(this.id) }
}
p = new Person(1)
p.__proto__ == Person.prototype == Object.getPrototypeOf(p); p instanceof Person/Object
Person instanceof Function; Person.__proto__ == Function.prototype

// 原型继承。以下不使用非标准的__proto__
function Man(id) { // 打算创建的子类
    Person.call(this, id) // 调用父类构造函数
    this.base = Person; this.base() // 另一种写法
}
function f(){} // 定义一个过渡用的空函数
f.prototype = Person.prototype // 可理解为f是Person的另一个构造函数
Man.prototype = new f() // 实际上是Person的对象，但本身没有属性，只是为了获得原型链上的方法。属性在子类构造函数的父.call()中创建了，不用空函数会导致属性重复
Man.prototype = Object.create(Person.prototype) // 以上三句在ES5上可替换为此句；此方法不是浅拷贝
Man.prototype.constructor = Man // 手动往回绑定
Man.prototype.xxx = ... // 定义类方法
m instanceof Man/Person // 会搜索原型链
Man.prototype instanceof Person // 子类和父类
Object.assign(Man.prototype, Animal.prototype) // Mixin，伪多继承，把Animal的方法加到Man上，合并对象

// ES6的类
class Person {
    constructor(name) {
        this.name = name;
    }

    hello() { // 没有function关键字；其实ES6对普通对象也能这样了
        console.log('hello')
    }

    static f(){} // 静态方法，用Person.f()访问
    static {} // 可有多个，按顺序执行，类似于静态构造函数，里面的this可访问其他static对象

    get Name() {return this.name}; set Name(val) {...}

    [var_name](){} // 可计算的属性名：根据变量的值创建，一般用Symbol。使用时p[var_name]()
}

class Man extends Person {
    constructor(name, xxx) {
        super(name)
        // 访问父类成员用super.
    }
}
new.target.name：new是从哪个构造函数调用的，new子类时在父类中使用它会显示子类
```

## 函数

* var f=function(a,b){...}，或function f(){}。前者也可加名字但只能在内部使用。还可以用Function()构造函数，如果只有一个参数就当作函数体
* 立即执行的匿名函数：`!function(){...}()`或`(function(){})()`
* 调用函数时实参可完全与形参不对应，自动忽略多的，少了就为undefined，严格模式也无任何报错
* arguments关键字：函数原始参数，伪数组。其callee属性代表当前执行的函数，严格模式下禁用，用于匿名函数递归调用。现在用形参的`...rest`接收变参，参数正好匹配时为[]
* name属性：函数名，ES6可识别匿名函数赋给的变量名。length属性：预期参数个数。toString()：源代码包括注释
* 箭头函数返回对象要加括号`()=>({a: 1})`
* generator：用function*声明，内部yield。`yield*`等于Py的yield from。调用者可用g.next()手动消费，可传参相当于Py的send
* ES6有了块级作用域，理论上在外面声明f，块级里再次声明f，在外面使用f，应该是最初的。但浏览器选择把f变为undefined。总之应该避免在块级作用域里声明函数，只在顶层和函数作用域里声明
* 函数定义时如果引用了非局部变量，即使到有同名局部变量的地方调用也仍使用原来的，属于闭包
* 不要在return与返回值之间添加新行，会隐式加分号导致return undefined
* 支持默认参数，箭头函数也支持；但为惰性求值，且每次调用函数都会求一次，所以尽量用字面量
* 类似于Py命名关键字参数的做法：function f(a, b, { option = false } = {})
* 箭头函数不能当作构造函数，不能使用new，不能使用yield

## this

* 调用函数时，参数隐式传递了调用对象(context)，函数体中用`this`访问
* this是在执行时才确认的，如果函数调用时前面没有.或[]，ctx就是顶层(window/global)，严格模式下为undefined
* 函数数组`a=[f,f2]; a[0]()`，f里的this为a
* call()：第一个参数明确指定ctx，后面的变长参数传递给实际函数。apply()类似，只不过第二个参数为数组，适用于实际函数是变长的如Math.max.apply(null,arr)，但现在可用...arr代替了
* bind()：返回一个永久修改了this的函数，之后直接调用或用其他ctx也没问题；相当于在上一级用that=this记录了
* TODO: 事件中的this是触发事件的HTML对象，是监听器所在的元素
* 箭头函数
  * 不存在自己的this，它里面的this按词法作用域绑定，且apply/call自动忽略ctx参数
  * 相当于匿名函数定义后加了bind(this)，或相当于把this闭包了
  * 直接作为对象成员时，如果对象定义在函数中那this就是函数的；如果对象定义在顶层，就是顶层；对象定义不具有作用域，嵌套时不变
  * 构造函数中再调用高阶函数传箭头函数，this就是临时对象
* 严格模式下立即执行的匿名函数的this是undefined
* 回调函数如果用function(){}定义，里面的this如果不做处理一般就是全局，如setTimeout和map
* 这几种用法会改变this的指向为undefined，主要就是表达式：(o.f=o.f)(); (false || o.f)(); (1,o.f)()
* Node命令行（非REPL）执行脚本时，全局的this为{}，GlobalThis才等于global，在全局var的变量不会附到global和this上
* 普通情况下，var声明的变量或非严格模式不声明的变量会挂到顶层下面

```js
var obj = {
    birth: 1990,
    getAge: function () {
        var that = this
        var fn = function () {
            return 2021-this.birth; // this指向window或undefined，因为后面直接调用了fn()
            return 2021-that.birth; // 传统的修复方式
        }
        var fn2 = () => 2021-this.birth; // this指向obj对象
        return fn()
    }
}
```

## JSON

* JSON.stringify(o, null, 4)：第二个参数可为['要序列化的属性',]，也可为(key, value)=>{}对每个对象都用一遍的convert函数。第三个参数为缩进。若o定义了toJSON函数则会自动使用
* JSON.parse(str)：只支持真正的JSON字符串，key必须用双引号，最后一项不能有逗号，不能有注释。用来构造对象会稍微快一点，但不要手动这样优化

## RegExp

* 创建：`/pattern/`或`new RegExp('pattern')`；前者内部的/要转义，选项加在结尾的/后
* 判断是否匹配：r.test(s)，返回bool；r.lastIndex()返回匹配索引
* s.match(p) 只匹配一次，返回伪数组，第一个元素是整个正则匹配到的，余下的是分组的结果，index属性返回匹配到的索引
* match在/g下返回真数组，是所有匹配的字符串，类似一般意义上的搜索，但是不存在分组捕获的结果
* r.exec(s)在/g下相当于有状态的match，多次调用，每次返回一个match的结果，不能中途更改s；test也有此功能。本质上是在r里储存了lastIndex的状态，匹配成功时非0，下次从它开始
* s.search(r)返回第一次匹配到的索引
* 替换的特殊符号，非标准：`$&`相当于其他语言的`$0`，`$反引号`匹配结果前面的文本，`$'`匹配结果后面的文本，`$$`转义一个$
* /u选项：正确匹配非BMP的。/y：类似于/g，但迭代下一次的匹配必须从剩下的开头(lastIndex)开始，隐含了^
* ES6添加了`r[Symbol.match](s)`、search、replace、split
* 现代的浏览器和node支持lookbehind
* 命名分组后可对groups解构；replace的第二个参数可以是函数，差不多参数就是匹配结果的展开
* ES2020添加了string.matchAll(r)，相当于/g+exec，关键是可用for of遍历它
* ES2022给exec添加了indices：https://github.com/tc39/proposal-regexp-match-Indices

## Math

* max() min()：变参；无参调用时max()会返回负无穷
* abs()
* random()：[0,1)，可配合*n和floor随机生成数组长度内的下标
* floor()、round()、ceil()、trunc()；num.toFixed(n)舍入到小数点后n位，结果是字符串
* pow() exp() sqrt() cbrt()立方根 hypot(变参)所有参数平方和的平方根 log() log2() log10()
* PI E LN2 SQRT2
* imul() 大数相乘时保持低位精度

## Promise

* then的第二个参数也是失败处理函数，与catch的区别是then的第一个参数回调中失败时catch能捕获。then的第二个参数类似于if-else的else分支，仅限于前面的Promise对象失败，而catch类似于try-catch。如果最后失败没有处理，会抛UnhandledPromiseRejection
* 执行完毕状态：包括成功和失败，可用.finally()处理
* Promise.all() 有时用于保证最低执行时间
* Promise.allSettled() 结果为Promise数组，不会自动解包，方便手动处理所有失败的。而all()配合try-catch最多处理一个失败的
* Promise.race() 返回第一个执行完毕的Promise
* Promise.any() 有时用于多个异步任务是为了容错
* “微任务”：追加到本轮事件循环末

```js
// 创建：给Promise传一个回调，内部成功时resolve()，失败时调用reject()。本身立即返回
function f() {
  return new Promise((resolve, reject) => // 或用Promise.resolve()工厂方法
    if (...) {
      resolve(value)
    } else {
      reject(new Error())
    }
  )
}

// 使用：f()获得Promise对象
f().then(result => {
    console.log('成功：' + result);
    return 另一个后续处理的Promise；或返回其它对象，会自动包装成视为已成功的Promise
  })
  .then(...)
  .catch(function (reason) {
    console.log('失败：' + reason);
  });

function timeout(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(resolve, ms, 'done');
  });
}

// async
async function f(){
  return "成功"
}
let result = await f()

async function* gen(){await ...; yield ...}
for await(const item of gen())
```

## Map和Set(ES6)

* key可以不是字符串
* Map的构造函数与Py类似，get set delete，遍历：for(const [k,v] of m)
* Set：add delete has
* WeekMap WeekSet 不可迭代
* m.keys() values() entries()迭代返回[k,v]；普通对象用Object.entries(o)后也能这样

## 其它语法

* Date对象：不加new创建的是字符串。toLocaleString()返回的字符串与toString()格式不同
  * Temporal：新式日期API，目前没有浏览器实现了
  * 时间戳：Date.now()返回毫秒。秒：Math.floor(前者/1000)；或|0，原理是位运算会丢弃小数，但会产生2038问题
* eval()：严格模式下，其内部新var的变量不会影响外面。但使用别名或其他方式间接执行eval，内部（this）一律是全局作用域
* Canvas
* encodeURI() encodeURIComponent()：不推荐用escape()
* Proxy：拦截目标对象的基本操作
* Reflect：Reflect.get(o, 'prop_name')
* ArrayBuffer
* 异常
  * throw new Error('xxx'); err.name/message/stack
  * 预定义的：RangeError TypeError

# BOM(window)

* setTimeout() setInterval()
  * 第一个参数是要执行的回调函数，也可以是字符串表示的js代码。第二个参数是毫秒
  * setTimeout不传时间或传0并不是真的0秒后就执行，而是等本轮事件循环完成后再执行，可循环中避免大量设置DOM造成阻塞，而且浏览器可根据是否是当前tab进一步延迟以省电
  * setTimeout的时间用的是开始的事件，不考虑执行时间。如设置的100，但执行要50，感觉上就只间隔了50；浏览器的定时线程是单独的，主线程被阻塞了也会一直添加任务，导致主线程恢复后一次性执行多个
  * 剩下的参数为回调函数的参数
  * 返回值可传入clearTimeout()/clearInterval()取消执行
  * 回调函数一般写匿名函数而不是直接传函数对象，否则回调函数内部的this会指向全局，因为只有obj.f而不是obj.f()，或用obj.f.bind(obj)
  * 在事件中使用时一般用箭头函数
* alert()模态 prompt()用户能输入字符串 confirm()返回bool用户能确定和取消
* innerWidth innerHeight outerWidth outerHeight：后者是整个浏览器窗口的宽高，前者是除去菜单栏等的显示网页的宽高但包括滚动条，等于viewport的大小加滚动条
* open()、close()：后者只有是前者打开的才能关闭
* screen对象：width、height
* history对象：back()和forward()相当于用户点击浏览器的后退前进。现代页面大量使用ajax，一般不用此对象了
* URL：createObjectURL(blob-obj) 创建临时下载地址
* origin：scheme+domain
* getComputedStyle()
* length：iframe的个数
* 元素的id直接附在BOM下，推荐命名里加-，这样不会无意识引用到

## Console

* $_是上一次表达式的值，$0-$4保存了最近5个在Elements面板中选中的元素，$和$$都类似于querySelectorAll但又不完全相同，感觉一般用后者，$x执行xpath，inspect(o)跳转到Elements面板中那个元素的位置，copy(o)把元素复制到剪贴板
* log：支持C风格的格式化，但%c用于CSS；还有info warn error debug，前面图标不一样，error还会输出调用栈
* table()：对于[]或{}的JSON可输出表格，每一项作为一行，{}的成员还可以是{}，看作属性
* count('label')：输出被调用了多少次，不同参数不同计算
* dir() dirxml()：美化显示DOM对象，对于Chrome，前者显示各种属性，后者显示HTML树。但FF没区别
* assert(expression, message)
* time('label'); timeEnd('label')
* clear()：清除所有输出
* trace()：显示调用栈

## DOM(document)

* getElementsByxxx()：返回实时集合，都是O(1)的。querySelector querySelectorAll()：静态集合，无法选中伪元素。可以在元素上用，但效果是先从根查询再过滤出当前元素的子元素，会产生一些违反直觉的结果。devtools中用复制css selector就行，css path反而不是唯一的，js path自动加上本方法
* head、body、documentElement(即html元素)
* links、forms、images、scripts、styleSheets：都是HTMLCollection，可.[id]取到指定成员
* iframe中的用其contentDocument属性
* documentURL/URL、domain：值完全等于location.href、hostname
* title、referrer、characterSet
* lastModified：如果页面被本地JS更新了，会返回新的时间
* hidden visibilityState：前者为bool，后者为visible和hidden字符串，都是只读的，窗口最小化 选项卡切换 锁屏就是不可见的；不等于元素属性
* currentScript：当前正在执行的脚本的script元素
* evaluate()：使用xpath，但是比较麻烦，最好再封装一层
* createDocumentFragment()：存放Element的内存容器，避免处理DOM中途渲染，插入DOM后不会插入自己本身
* write()：如果页面加载完成后调用，会隐式open()把当前页面全部清掉，然后输出指定内容，之后再用就是继续输出了，直到close()；可在head里用，此时没有加载完成，可理解为open了但没有close，不会清除已有内容，但会阻塞正常加载。writeln()输出`\n`但渲染成HTML后不会换行因为要用br所以没用
* cookie：设置了httpOnly的不能被js读取
* 创建和添加元素：oDiv=createElement('div')，oDiv.xxx设置属性，oTxt=createTextNode('文本内容')，oDiv.appendChild(oTxt)
* 解析HTML字符串：`r=createRange(); r.createContextualFragment('<ul><li></li></ul>')`
* 不学的：createTreeWalker() createNodeIterator() adoptNode() importNode()

### 节点(Node)

* 一般获取到的是引用，修改后会直接在页面上生效；如果待插入的节点是从树中获取的，插入到别的地方会从原位置删去
* 包括Element Attr Text Comment等，n.nodeType返回几个数字常量，可与Node.ELEMENT_NODE等进行===比较
* 返回Node的：childNodes parentNode firstChild lastChild nextSibling previousSibling
* 返回Element的：children parentElement firstElementChild lastElementChild nextElementSibling previousElementSibling childElementCount
* nodeName：对于Element返回大写的tagName，Text返回'#text'
* nodeValue：只有Attr Text Comment具有，其他的返回null；但这仨用textContent也行
* isConnected：是否在DOM中
* ownerDocument：一般来说返回document对象
* 文本
  * innerText：IE提出的，性能稍差，受CSS影响，如不返回隐藏元素的文本、text-transform:uppercase后返回的是大写的；把br变成\n，对空白符号的处理类似于HTML。只有HTML元素能用
  * textContent：标准化得更早一些，IE8不支持。差不多就是原样把所有HTML标记去掉
  * 赋值时都会自动对内容进行HTML编码，尖括号变成实体，保证无法直接设置HTML元素；devtools中可能直接看不出
  * 都能得到style和script里的内容；对他俩赋值时，无论是已经在DOM中还是后来添加进DOM，都能执行
  * text：好像仅在script标签中有，行为和上面俩一样
* cloneNode()：true深拷贝，false仅拷贝元素本身，不包括子元素
* appendChild(new) insertBefore(new, ref)两者都是在父节点上调用，参数一般是Element；append()和prepend()能添加多个节点，参数可为字符串作为Text
* replaceChild() removeChild()只是从DOM中删除，对象还在内存中
* remove() replaceWith() before() after()以自身为对象调用，后两者是添加兄弟
* contains()：是否含有指定子节点，或就是自己
* isEqualNode()：判断两个节点是否结构相同
* normalize()：规范化后不存在空的文本节点或者两个相邻的文本节点

### HTMLElement

* tagName
* style属性（inline）：font-size在JS中要用fontSize，float用cssFloat，因为float是关键字
* className属性：对应CSS的Class，因为class是JS关键字；htmlFor类似
* classList.add()/+= remove() toggle() contains() 原生的类似JQ的方法
* attributes hasAttribute() getAttribute() setAttribute() removeAttribute() getAttributeNames()：inline的。其中attributes是属性节点对象（含有name和value属性）的对象
* HTML中data-xxx的自定义属性，用dataset.xxx访问
* innerHTML 给它赋值不会执行script
* outerHTML 给它赋值相当于在DOM中替换元素，但原元素还是在内存中
* matches(selector)：调用者是否符合指定选择器
* closest()：从自己开始往上找满足选择器的第一个元素或自己
* insertAdjacentHTML('beforebegin'/'afterbegin'/'beforeend'/'afterend', 'HTML文本')：能直接把HTML字符串插入DOM。还有Element和Text后缀的
* scrollIntoView({behavior: 'smooth'})：滚动到调用者
* focus() blur()：改变光标焦点；click() 模拟鼠标点击
* 大小
  * clientHeight clientWidth 含有padding和content，不含滚动条。html元素的这俩属性就叫viewport的大小
  * offsetHeight offsetWidth 加上边框。对于自然出现滚动条的元素，大小与scrollWidth差不多
  * clientTop clientLeft 边框宽度
  * scrollHeight scrollWidth 当内容超过其设定高度时的实际高度，即使overflow:hidden了也是，包括::before的大小
  * scrollTop scrollLeft 可写，拖动滚动条后元素被卷起的高度。html元素的这俩就是整个页面的滚动的距离
  * offsetTop offsetLeft offsetParent 见css的position。如果元素本身是标准流的，那就是相对于body顶端的偏离
  * getBoundingClientRect() 相对于viewport的top left bottom right集合
  * getClientRects()

## location

* href：当前完整url
  * href = protocol + host + pathname + search + hash
  * protocol：如`https:`
  * host = hostname + port。如果是标准端口则不含port
  * pathname：以/开始
  * search：如`'?a=1&b=2'`
  * 直接给href或location赋值是不好的做法，应用assign
* assign()：可以重定向到指定网页，如果在iframe中就只有内部有效；一般要加协议或者斜杠。之后的js代码都会失效，因为已经换到另一个网页去了
* replace()：与assign类似，但会“替换”当前页面，在历史记录里只会出现新的页面
* reload()

## navigator

* appName appVersion：浏览器名称 版本，但FF是Netscape和5.0，所以没有意义
* language：浏览器设置的语言
* platform：操作系统类型，"Win32"
* userAgent
* geolocation对象：H5新增，地理位置API。getCurrentPosition()
* 是否联网：onLine；强网弱网：connection，包括预估速度、RTT等。监听联网断网事件：window下的online、offline

## 表单

* input标签一般用value属性，单复选框用checked属性
* submit()手动提交，会触发onsubmit事件，返回false就不会提交；用户在最后一个输入框按回车也会提交
* 本来file控件只有服务器能处理，value表示有没有选择。H5新增了File API，一般监听change事件，用.files[0]获得File，有name size type等属性；new FileReader()设置onload回调后用readAsDataURL()读取文件

## Event

* 分为捕获阶段、事件目标阶段、冒泡阶段
* window.getEventListeners(domobj)只有chrome有，原生没有通用的方法。只能看到函数对象，看不到函数内容，也看不到是在哪里定义的
* html的onxxx属性是老方法，无法设置多个事件处理程序
* 用JS代码改变内容不会触发change事件，其它的一样，只能直接调用
* EventTarget.addEventListener(eventname, e=>...)：添加事件处理程序，第三个参数可传{once:true, capture:true}
  * 移动端滑动性能优化：监听touchxxx事件时，如果不需要调用preventDefault()，则应设置passive:true
* e.stopPropagation()：事件会由内而外冒泡，此方法就是停止冒泡
* e.target是触发事件的元素，冒泡到上层时此变量就有用了；而那时this就只是上层元素，永远等于e.currentTarget
* e.preventDefault()：拦截form的提交、阻止a的跳转等
* dispatchEvent()：触发自定义事件，参数为document.createEvent()再initEvent()创建出来的
* removeEventListener()

## 预定义事件

* window.onload：所有资源加载完成后触发，在这里取元素不用担心还没加载完导致找不到；但若网页已经加载完则不会触发，可配合document.readyState，若它是complete就直接执行代码，否则用onload。注意不是document.onload。body和img等几个也支持。document上的DOMContentLoaded事件：初始的HTML加载完就会触发
* onbeforeunload：离开页面时触发
* 鼠标：onclick onmouseover onmouseout onmouseup onmousedown onmousemove
* 键盘：onkeydown onkeyup onkeypress相对高层，能区分大小写，不能捕获功能键，不区分小键盘。会先处理这些事件再把字符输进DOM
* 表单：onfocus onblur(丢失焦点) onselect(选中文本框) onchange(单选复选下拉框)
* 编辑：oncopy onselectstart oncontextmenu
* HTML的onxxx属性为JS语句而不是函数名，会自动包装成一个具有event参数的函数，且还会再包一层with(document)和with(当前元素)，表单还有with(form)，因此不用加document.，form里可以直接用submit()
* 现在一般用addEventListener，因为onXXX属性会覆盖之前绑定的处理器，事件名不用加on前缀了
* 防止a触发点击事件后还跳转：onclick中return false

## Fetch

* 默认不带cookie，option加`credentials:'same-origin'`或`credentials: 'include', mode: 'cors'`
* 404或500等并不会引发错误，只会在网络错误（如IP无法解析、CORS不允许）的情况下才视为错误
* 相比于XHR的劣势：不自带超时、取消（可以abort但还是会把调用执行完消耗流量）、监视进度事件（可以手搓）。一些讨论：https://github.com/whatwg/fetch/issues/27
* 相比于XHR的优势：ServiceWorker里也能用、同源请求也可以自定义不带cookie、可自定义重定向场景，xhr只能follow、可自定义referrer
* window.Headers、Response、Request
* URLSearchParams：构建查询字符串
* 第三方网络库：axios sindresorhus/ky(浏览器) sindresorhus/got(Node)

```js
fetch('/' [,{opt}])
.then(resp => resp.json()/text())
.then(data => console.log(data))
.catch(error => ...)
// 或
var resp = await fetch(url)
var data = resp.json()

// POST
fetch('/', {method:'POST', body: JSON.stringify({...})/new FormData(), headers:{'Content-Type': 'application/json'}})
```

### XMLHttpRequest

```js
const xhr = new XMLHttpRequest();
xhr.open('GET', '/bar/foo.txt', false);  // false表示是同步阻塞的
xhr.responseType = 'json';
xhr.send();
if (xhr.status === 200) {
  console.log(xhr.responseText);
}
```

## 本地储存

* typeof(Storage)!=="undefined"：浏览器支持此特性
* localStorage和sessionStorage：可直接用点读取和设置，前者永久保存，用removeItem/clear删除，后者关闭浏览器后清除
* indexedDB用于大量数据，类似于NoSQL
  * open()创建或打开，一般要更新版本号。返回的对象的onsuccess和onupgradeneeded的db=e.target.result就是数据库连接
  * store=db.createObjectStore('对象仓库名',{keyPath:'主键名'/autoIncrement:true})创建对象仓库，store.add()添加对象，db.transaction开启事务

## Worker

* 不能访问DOM，不能跨域加载JS
* 顶层对象是self
* 不同页面不能访问对方的worker
* 库：Workerize

```js
// 主线程
var worker = new Worker('worker.js')
worker.onerro = ...
worker.postMessage(xxx) // 会序列化一遍，损失性能
worker.postMessage(xxx,[xxx]) // 这种形式称作Transferable Objects，只会传引用，但之后主线程就不要用了
worker.onmessage = function(e){console.log(e.data)}
...
worker.terminate() // 主动终止，如果worker关闭了就不用
// worker.js
importScripts('script1.js')
onmessage = function(e) { // 或 addEventListener('message', ...)
    var d=e.data // 前台发送来的数据
    d.cmd -> 'start', 'stop'
    d.msg
    postMessage(xxx) // 发送给主线程，会序列化一遍
    close()
}
// 使用同一页面中的代码
<script id="worker" type="app/worker">...</script>
var blob = new Blob([document.querySelector('#worker').textContent])
var url = window.URL.createObjectURL(blob)
var worker = new Worker(url)
```

## SSE(Server Send Events)

* 基于HTTP利用长连接特性实现服务端向客户端推送数据。本质上就是GET，但对后端数据结构有要求
* const e = new EventSource('url', opt) 选项包括是否发送cookie、要发送的headers、超时
* e.onopen onerror onmessage事件
* 服务端响应的Content-Type为text/event-stream，内容为`data: 数据\n\n`
* 还可以自定义事件类型（默认叫message）

## 其它

* File System Access API：https://github.com/GoogleChromeLabs/browser-fs-access

# Node.js

* 安装
  * https://github.com/Schniz/fnm Rust写的跨平台Node版本管理和安装器，本身用脚本安装。fnm install 18; fnm use 18
  * npx n latest 不支持win
  * nvm 不支持win
  * curl -fsSL https://deb.nodesource.com/setup_19.x | bash - && apt install nodejs
* CLI
  * -e 'console.log(123)' 执行语句，不显示表达式结果
  * 没有python -i的功能，代替用cat xxx.js | node -i
  * --enable-source-maps

## CommonJS

* 一个文件就是一个模块
* 引用别的模块：`const greet = require('./hello')`
* 导出本模块的对象：`exports.xxx=xxx`，其中exports是预定义的object。默认导出：module.exports=xxx或export=xxx(仅TS)
* 不会循环引用或重复加载，如果父子互相引用，顺序为父->子一直执行完->父
* 如果不加./，会依次在当前目录下和~下的node_modules目录中寻找
* 对于目录(包)，看package.json里的main，或找index.js
* AMD和CMD：RequreJS和SeaJS都不更新了，不学

## ES Module

* 后缀为mjs，或package.json指定type:module
* import语句会自动提到开头，依赖关系在编译阶段就确定，解析、实例化、执行，过程是异步的
* import的在本模块中是const的
* 动态导入：import('xxx')，不会用缓存，ES2020
* 导出对象导出的是引用，而CJS导出的是浅拷贝
* 无NODE_PATH、__dirname/__filename->处理import.meta.url、require.resolve->module.createRequire()
* 支持导入Json文件：https://github.com/tc39/proposal-json-modules 目前FF不支持https://bugzilla.mozilla.org/show_bug.cgi?id=1777526 Chrome91，node，ts支持
* 路径
  * ESM导入本地的文件必须加后缀，CJS会自动猜测后缀和允许导入含有index.js的文件夹。Node可以自定义Loader模仿CJS行为，但默认情况下Node和浏览器要求加，因此不考虑不加
  * 使用Node的库时官方推荐用：import fs from 'node:fs/promises'，但不加node:也可以
  * 可以直接导入CJS模块的库

```js
const a = 'hello'
const b = 'world'
export { a, b as c } // 按需导出
export var d = 123 // 在定义时就导出；可多次使用
export const say = function () {
    console.log('hello')
}
import { a, c as b, say } from './m.js' // 按需导入
import * as m from './m.js'
export { a } from './m.js' // 导入并导出(聚合)

export default a // 直接导出，只能导出一个，其实相当于导出了一个名为default的对象；不能在此处用var声明，但却可声明函数；此处导出的是a的值非对象，用export a会报错
import m123 from './m.js' // 对应默认导出，可任意取名
import "./m.js"; // 会执行那个文件，但不会导入任何东西
```

## package.json

* 创建：npm init -y
* main：默认为index.js，是使用者require(包名)后的东西。module：ESM版main，可与main同时存在，但目前没有标准化，只是打包工具使用，算事实上的标准。exports:"./index.js"指定后封禁子路径
* bin:{"myapp":"xxx"} 使用者安装后会在./node_modules/.bin下创建二进制入口，scripts里的命令能调用到而无需添加那个目录进PATH
* dependencies:{"pkg":"ver"}、devDependencies
* scripts:{"自定义命令名": "shell内容"} 使用用 npm run 命令名。存在server.js时npm start会使用它，不支持mjs
* type:"module"
* engines：最低使用的Node版本
* 不允许trailing comma。不能直接写注释，但允许在根元素下写一个"//"的属性表示注释

## npm

* npm config set registry https://registry.npmmirror.com 还有 https://mirrors.cloud.tencent.com/npm/
* i/install pkg@version，up/update按package的语义更新lock，un/uninstall
  * 默认操作的都是当前包的运行时依赖，默认--save，install时会下下来。-D/--save-dev表示开发依赖，install加--production时不会下
  * -g：安装到%AppData%\npm\node_modules
* ls：列出安装了的包，ll也显示包的描述，-a显示包内部的依赖。ou/outdated按依赖范围限制显示过时的包。-D对它们无用
* 更新package里的依赖：全局安装npm-check-updates; ncu -u。不过它比较重，依赖300多个包。还有个npm-check也是依赖300多个包
* cache clear --force
* prune：清理安装到了node_modules但不在dependencies中的包
* audit fix：有的包有安全问题时此命令可更新到没问题的最低版本
* view(info) pkg：查看包的信息
* 发布：adduser、publish
* pnpm：对一些隐式依赖的包不友好、有时VSC的auto import失效。快、省空间、支持monorepo、避免幽灵依赖
* https://github.com/dylang/npm-check
* 分析包的大小：https://bundlephobia.com/ https://packagephobia.com/

### 语义化版本

* ~1.0.0等于1.0.x，^1.0.0等于1.x.x，*等于x.x.x
* 如果package.json和package-lock.json语义版本一致，则安装lock的，而不管package中指定的是否有更新；如果不一致，安装package的并更新lock的
* 存在lock且不编辑package时install，package就跟没有一样
* npm ci：完全按照lock安装，不会更改package或lock，速度更快。lock不符合package时直接报错

## 文件操作

* fs
  * readdir()非递归，返回string[]，传{withFileTypes:true}后返回Dirent对象，具有isFile()等
  * mkdir(...,{recursive: true})、stat()
* path：normalize()、join()、extname()、parse()返回{root,dir,base,ext,name}
* Buffer字节数组：Buffer.from(text, 'utf-8')，b.toString('utf-8')，可变，slice()不会拷贝而只是引用，拷贝用copy()；Buffer.concat([])。应该优先用js的ArrayBuffer，这个Buffer是node在没有AB时创建出来的

```js
import fs from 'node:fs/promises';
let data = await fs.readFile('data.txt', 'utf8') // 不加编码时返回Buffer
await fs.writeFile('output.txt', data) // 写字符串的默认编码就是u8
fs.access('/path/to/file').then(() => true, () => false); // 或用非异步的existsSync()
fs.rm('/dir', { force: true, recursive: true, maxRetries: 3 }) // 或用rimraf第三方库
fs.mkdir('/dir', { recursive: true })

// 文件流，只在非promises的fs中存在
var rs = fs.createReadStream('sample.txt', 'utf-8')
rs.on('data', chunk => {rs.pause(); console.log('DATA: ' + chunck); re.resume()})
rs.on('end', () => console.log('END'))
rs.on('error', err => console.log('ERROR: ' + err))
var ws1 = fs.createWriteStream('output1.txt', 'utf-8')
ws1.write('文本流'); ws1.write('数据'); ws1.end()
var ws2 = fs.createWriteStream('output2.txt')
ws2.write(new Buffer('二进制流', 'utf-8'))

rs.pipe(ws) // 从输入流读取内容后写入输出流，读完后自动关闭输出流。多个pipe之间每个都需要错误处理
const { pipeline } = require('stream/promises'); // 优先用这个
await pipeline(rs,mid,ws)
```

## 其它模块

* 判断是在浏览器中还是nodejs中：typeof(window) === 'undefined'
* setImmediate() process.nextTick()都和setTimeout(f,0)相似且更轻，后者保证在下一次循环都执行，前者可能推迟到下下次
* process：代表当前nodejs进程。version platform arch cwd() chdir() on('exit', 退出时调用的函数) argv
  * 外部可执行文件：execa第三方包
* util/types：如判断是否是正则表达式。判断string还是要用typeof
* timers/promises：含有异步版的setTimeout
* undici：node官方HTTP客户端，但没进标准库。fetch内部用了它
* assert/strict
* 调试日志：const util = require('util'); const debug = util.debuglog('egg-bin:test'); debug('%s', xxx); NODE_DEBUG=egg-core,egg-bin:*

# 构建

* TODO: https://nodejs.org/api/packages.html#dual-commonjses-module-packages 构建同时面向CJS和ESM的包
* esbuild src/browser.ts --bundle --outdir=dist
  * --minify --sourcemap
  * --watch、--serve开启http服务器当产生请求时自动重新打包
  * 默认面向浏览器，可设置--target=es2020,chrome58。还可以--platform=node
  * 不支持生成.d.ts
  * bundle表示把所有import的东西内嵌，还支持jsx json css等
  * tsup：基于esbuild的零配置打包工具
* swc：替代babel，不做ts的错误检查
* sucrase：比swc和esbuild还快的ts和jsx转现代js的工具
* stylelint：检测CSS的
* vercel/ncc：零配置，用了webpack
* https://github.com/rome/tools：目标是替代Babel, ESLint, webpack, Prettier, Jest
* 不学的
  * webpack rollup：用esbuild和vite替代
  * parcel和Microbundle：都说是零配置。前者面向应用。后者面向库，用了rollup babel terser，在零配置的基础上又加了很多配置，感觉太重了
  * terser：JS的parser和压缩，API与uglify差不多，用esbuild替代
  * uglify-js：不支持ES6
  * clean-css：用PostCSS的cssnano
  * lerna：用于monorepo，暂时用不到
  * systemjs：ESM的前身实验
  * huozhi/bunchee 国产，零配置，用户太少
  * https://www.rspack.dev/zh/ 字节，基本兼容webpack的配置，对vue支持较差

## babel

* .babelrc：转码规则
* 默认只转换Syntax，不转换API。core-js提供了一些标准库的polyfill
* 一般都是-D开发依赖
* @babel/cli或npx babel：命令行转码。src可为目录，-o指定输出文件，-d指定输出目录，-s生成source map
* @babel/register：引用后会对require加钩子，之后再引用js会自动转码
* @babel/standalone能在浏览器端转换
* @babel/core @babel/preset-env
* babel src --out-dir dist -w --source-maps

## eslint

* .eslintrc.json：用eslint --init创建，需有packages.json
* 有命令行检查，有--fix自动修复
* VSC：eslint.lintTask.enable eslint.format.enable
* TS：看github typescript-eslint
* https://zhuanlan.zhihu.com/p/159426292 https://zhuanlan.zhihu.com/p/145601639

## ts-node

* ts-node命令行在package里指定type:module时无法使用。ts-node-esm：仍无法使用
* https://github.com/esbuild-kit/tsx 感觉可以完全替代ts-node，只不过大小相对大。esno：在tsx上再加了一点点功能，不使用
* 其它各编译器的比较：https://github.com/privatenumber/ts-runtime-comparison 其中jiti可以直接运行module的ts，基于内置的Babel，但没有REPL
* https://github.com/digital-loukoum/esrun esbuild的简单包装，Star数少贡献者没有

## 在浏览器里直接执行TS脚本

* `<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script> <script type="text/babel" data-type="module" data-presets="typescript" src="./test.ts"></script>` 大小2.8M。无法导入其它ts，因为不加后缀识别为html，加js报404，加ts被浏览器识别为video
* https://github.com/klesun/ts-browser
* TypeScript-Console 浏览器扩展

# TypeScript

## Module

* 当文件根级别不存在import和export时，该代码处于全局空间，里面的变量在另一个全局空间的文件中能直接显示，这是为了兼容浏览器脚本代码
* 导入本地模块：from './xxx'或'./xxx.js'，不能是.ts
  * 添加了 import type {} 语句专门用于导入type，方便编译后自动移除
  * 允许配合CJS形式的导入 import fs = require("fs");
* 命名空间namespace：不使用

## 类型

* 鸭子类型/Structural Type System：类似于Go，两个不同名的类型，只要内容一样就可以。但非public成员要同源。与之相对的叫Nominal Type System
* Union 联合 |
  * 当不确定是哪一种类型时，只能访问共有属性
  * 类型断言（但类似于其它语言中的类型转换）：推荐用as。也可用尖括号，但JSX中不能用
  * 类型保护
    * if(typeof x === 'string') { x是string } 只支持几种基本类型
    * o instanceof C、D extends B
    * '属性名' in o
    * 自定义类型保护：function isFoo(arg: Foo | Bar): arg is Foo { return (arg as Foo).foo !== undefined } 之后在if里调用它就能检测
* Intersection 交叉 &：作用在interface上时感觉是把两个接口合并了，但实际是把类型收窄了
* any：等于没声明类型，与其它任意类型运算都是它
* unknown：可以任意赋值但无法访问任何属性，类型系统中的Top，所有类型的父类
* never：类型收窄时的Bottom，是任何类型的子类型，表示不会到达，与其它类型联合时相当于不存在。如函数只会抛异常时的返回类型，以及类型保护穷尽其它类型时的类型
* enum：优先用const enum，不支持计算项，编译时移除
* 数组：`Array<T>`或T[]、`ReadonlyArray<T>`或readonly T[]。伪数组：IArguments
* tuple：如`[number, string]`
* Type Aliases：type T = 其它类型声明。与interface相比不允许重新定义
* 函数类型：(user: User) => void。在object class interface中声明返回类型还是用的冒号。泛型函数：`<T>`写在小括号前

### 泛型

* 默认值：T = string。否则默认为unknown
* 联合类型中的泛型，可看作允许给使用者自定义联合类型中的一种：`type A<T> = number | T`
* 约束：T extends Car
* K extends keyof O：K的值是O的属性。key表示O的public属性的字面量联合类型
* O[K]：O.K的类型。称为索引访问操作符
* 映射
  * 同态：前三个使用后是作用于T。非同态：创建了新类型
  * `Readonly<T>`：表示把T的属性变为只读的对应的类型。实现上是{readonly [P in keyof T]: T[P]}，此处P in会依次把P绑定到T的属性上。Option：都变成可选的
  * Partial：把属性变为可选的
  * `Pick<O, 'a'|'b'>`：抽取属性子集
  * `Record<'x'|'y', O>`：产生{x:O, y:O}类型
* 条件：T extends U ? X : Y
  * 若T是联合类型，则会拆解后依次执行条件类型判断，再联合
  * `Exclude<T,U>`：从T中排除U。实现上是T extends U ? never : T
    * NonNullable：排除null和undefined
  * Extract：和Exclude相反，选择在U中的T类型
  * ReturnType<F>：获得函数的返回类型。实现上使用了infer

## interface

* 继承用extends，实现用implements。另一种扩充方法：多次定义同名接口
  * 支持多继承，多个父类有同名属性时会报错
  * 可以继承类，会抽出所有成员；若有私有的，则只有原类的子类才能实现那种接口了
* 构造函数类型声明：new()。但不能用来约束继承它的类的构造函数
* 可索引类型：`[index: number]: any`，任意属性：`[key: string]: any`
* 实现者自身可调用：():xxx

```ts
interface F { // 函数类型接口，可用于声明重载
  (a: number): number
  (a: string): string
}
interface S { // 类类型接口。object对象也可用它声明，对于obj字面量，成员必须刚好匹配
  f(): string
  // 也可含有属性：属性名:类型。可选属性：属性名?。只读属性：readonly，必须初始化
}
class Stu implements S {
  fullName: string; // 默认public；私有可用private也可用#
  constructor(
    public firstName: string, // 自动生成公开属性
    private lastName: string // 自动生成
  ) { this.fullName = firstName + " " + lastName }
  f() { return '123' }
}
```

## 类型声明

* 对于lib.js，在相同级别写一个lib.d.ts。里面基本上就是ts的对象定义前加declare。对于模块再加一个export=
* js库一般默认导出一个函数，再在上面挂一些属性。先声明一个函数，再声明同名namespace，里面的成员会合并作为函数对象的属性
* global.d.ts里放全局类型声明
  * interface Window { p:any } js中可以用window.p
  * declare var xxx：表示存在这么一个变量，不用管从哪来的
  * declare function：能重复使用声明重载
  * declare module：不按文件名作为模块名。或者用于里面就不用再加declare了
* @types/xxx维护了大量常见库的声明，其中node应作为-D（开发Node时必须手动安装），其余的应为直接依赖
* https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/README.zh.md https://github.com/sindresorhus/typescript-definition-style-guide

## [tsconfig.json](https://www.typescriptlang.org/tsconfig)

* tsc --init
* module:ESNext、NodeNext(Node16后根据package的type解析为CJS或ES2020)
* 根下的include:["src"]，等效于`src/**/*`。不是compilerOptions的属性，而是与它同级
* outDir:dist
* noEmitOnError 默认为false，tsc报错时仍生成js文件，因为有的js确实能运行
* 可选开启：noFallthroughCasesInSwitch noImplicitReturns noImplicitOverride noUncheckedIndexedAccess removeComments
* sourceMap
* resolveJsonModule 开启后能import from json文件，仅限Node
* esModuleInterop 模板默认启用，允许从CJS中导入库。实测只在生成CJS时才生效
* 配合babel，仅进行错误检查和生成d.ts：isolatedModules、declaration、emitDeclarationOnly
* 继承：extends
* rootDir 影响输出目录结构，默认为所有include的源代码的最长公共前缀，生成时去掉。若设为.则会保留所有目录结构包括src
* path:["jquery":"node_modules/jquery/dist/jquery.min.js"] 映射导入库的路径
* tsc编译
  * -p 指定tsconfig。不指定时从CWD依次往上找
  * -d 也生成d.ts
  * -w watch
  * --noEmit 单独用可理解为只进行错误检查
* https://github.com/yue1123/ts-config-helper

# VSCode

* 在函数上输入`/**`声明JSDoc，写参数类型后能有intellisense
* 在js中启用ts检查
  * `// @ts-check`在单个js中启用
  * VSC的设置中js/ts.implicitProjectConfig.checkJs全局启用。好像并不会被tsconfig的值覆盖
  * tsconfig的checkJs，隐式allowJs。使用时还必须指定outDir
* 设置
  * javascript和typescript.referencesCodeLens.enabled
  * javascript.inlayHints.variableTypes.enabled
  * typescript.implementationsCodeLens.enabled
  * 不显示从ts生成的js：files.exclude:`{"**/*.js": { "when": "$(basename).ts" }`
  * 在终端里运行时自动附加调试器：debug.javascript.autoAttachFilter:smart
* launch.json
  * skipFiles：添加"${workspaceFolder}/node_modules/**"，模板中默认还跳过了node标准库
  * 对于TS，如果指定了outDir导致转义出的js不在ts旁边，需指定outFiles:["${workspaceFolder}/out/**/*.js"]
* jsconfig.json
  * “继承”于tsconfig，默认启用了allowJs
  * 先ctrl+space创建基本结构，添加module:ESNext和exclude:["node_modules","dist"]或用include
  * 默认会添加package的dependencies的类型包。手动添加在jsconfig中用"typeAcquisition": {"include": ["jquery"]}
  * 无法用tsc -p指定它来编译ts
* 扩展
  * StandardJS 强制性的风格
  * Prettier
  * CSS Peek 在HTML中Peek class来源
  * quokka.js 即时显示表达式的值
* `No inputs were found in config file ...`：没有ts文件可供编译

# 库

## 工具

* date-fns Moment day.js 日期
* typedoc 从ts生成网页文档
* cheerio 服务器端的jQuery选择器，国产
* puppeteer 无头Chrome API
* d3
* scheduler
* chart.js
* dotenv
* lodash lodash-es https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore：函数式编程和工具类
* ramda 函数式编程，与ts兼容性差
* Socket：ws、socket.io
* 命令行：inquirer、commander
* Snap.svg
* deep-equal：比较对象。一般不用，从设计上来说加个id属性
* Modernizr：检测用户浏览器对标准的支持情况，wiki中有Polyfill收集
* js-cookie
* https://github.com/Kikobeats/json-future
* https://polyfill.io/ 能根据自己的需要选择Polyfill哪些功能
* PrismJS/prism 代码块高亮
* localForage Dexie.js 增强版的indexdb
* fx 控制台输出美化的json
* Partytown 慢加载script
* pino json日志库
* 临时HTTP服务器：http-server（最后更新2022年6月）、serve（vercel出的）
* immerjs 不可变状态管理
* 测试框架：mocha sinon jest ava

## 后端

* fastify 比http.Server还快，原生JS，支持TS，内置JSON Schema
* strapi headless CMS，无view，用于设计API和数据库，有可视化的类似于Wordpress的后台。directus TS写的同类的
* Nest 纯TS，与TypeORM结合得好。底层默认Express，可换fastify
* 数据库：Sequelize、TypeORM、Prisma、knex、mikro-orm
* appwrite 构建端到端后端RESTAPI
* feathers 构建实时应用
* https://github.com/typicode/json-server
* https://github.com/honojs/hono ts
* https://github.com/tinyhttp/tinyhttp 类Express，ts，但社区不太行
* https://adonisjs.com/ 全功能框架，ts
* zod：参数验证

## 前端

* alpinejs 最初受vue启发的模板框架，15KB
* petite-vue 使用了与vue相同的模板语法，偏向服务端渲染，6KB。非常不活跃
* htmx 在html里写属性发出ajax请求和控制dom，兼容IE11，7KB
* preact 重新实现的react，4KB
* solidjs 类react，无VDOM
* qwik TS，全栈，类react，首屏加载速度快，体积小。没有1.0
* lit 快速创建WebComponents
* MithrilJS 现代化的SAP，9KB

## 前端UI

* https://github.com/microsoft/fast/ https://github.com/microsoft/fluentui
* material-ui 基于React
* https://github.com/Tencent/weui/blob/master/README_cn.md 微信UI
* https://github.com/yued-fe/lulu

## 静态

* netlify-cms
* https://github.com/slatedocs/slate 创建适用于RESTAPI的文档
* docsify
* Astro：MPA框架，适合构建内容丰富的网站：营销网站、出版网站、文档网站、博客、个人作品集和一些电子商务网站
* Slidev：将md转换为ppt
* docusaurus：用于创建文档站点，FB出的

## node

* nodemon 自动重载
* node-cache
* fs-extra
* make-promises-safe：node15以下时使用
* mvn volta：管理node版本
* jsdom、happy-dom
* 打包独立可执行文件：nexe、vercel/pkg

## 不学的

* meteor 全栈，前端可选三大，后端Mongo。Blitz Redwood也是全栈
* eggjs(2013) 单实例多进程模式，架构复杂，不适合容器化和serverless。约定大于配置，想整理目录都没办法
* Express(2010) koa(2013) 前者不活跃，后者号称是继任者。有个国产daruk基于koa2且是TS，但维护者太少
* midway 阿里，ts，要使用Koa Express eggjs作为基础框架
* restify hapi 优先选择fastify
* Gatsby 优先选择Next.js
* Ember.js 太老
* Ionic 用的Angular，基于Cordova（React Native前一代的技术）
* layui 基于jquery
* ghost：类似于Wordpress。官网一开就占用100%GPU，很多年都没改

# Reference

* https://www.liaoxuefeng.com/wiki/1022910821149312
* https://wangdoc.com/javascript 阮一峰
* https://zh.javascript.info/
* 《从0到1 JavaScript/jQuery快速上手》莫振杰
* https://basarat.gitbook.io/typescript/

## TODO

* https://github.com/stephentian/33-js-concepts
* https://github.com/goldbergyoni/nodebestpractices
* https://www.30secondsofcode.org/
* 《你不知道的 JS》 https://github.com/getify/You-Dont-Know-JS
* https://github.com/wizardforcel/eloquent-js-3e-zh https://eloquentjavascript.net/
* https://www.zhihu.com/question/46943112 有哪些短小却令人惊叹的 JavaScript 代码？
* https://github.com/ascoders/weekly
* https://github.com/ecomfe/spec 编码规范
* https://bonsaiden.github.io/JavaScript-Garden/zh/
* https://github.com/thejsway/thejsway 无汉化
* https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md
* https://www.khanacademy.org/computing/computer-programming 有一些动画教程
* https://github.com/CN-Chrome-DevTools/CN-Chrome-DevTools
* https://zhuanlan.zhihu.com/p/415361629 那些你应该说再见的 npm 祖传老库
* debounce防抖：https://zhuanlan.zhihu.com/p/38313717 一段时间内多次触发，只有最后一次有效。给事件handler闭包一个对象t，如果t不为null就clearTimeout()，再把它赋值为setTimeout()
* 《JavaScript忍者秘籍 第2版》
* https://exploringjs.com/impatient-js/
* https://github.com/soyaine/JavaScript30
* https://www.patterns.dev/

### TSTODO

* https://learn.microsoft.com/zh-cn/training/paths/build-javascript-applications-typescript/
* https://jkchao.github.io/typescript-book-chinese/
* https://basarat.gitbook.io/typescript/recap/number https://rexdainiel.gitbooks.io/typescript/content/docs/classes.html
* https://www.tektutorialshub.com/typescript-tutorial/
* https://zhuanlan.zhihu.com/p/133249506
* https://typescript-exercises.github.io/ https://zhuanlan.zhihu.com/p/260148824
* https://zhuanlan.zhihu.com/c_206498766
* https://www.youtube.com/c/BasaratAli/videos
* https://wangdoc.com/typescript/

### NODETODO

* https://docs.microsoft.com/zh-cn/learn/modules/build-web-api-nodejs-express/
* https://nqdeng.github.io/7-days-nodejs/#3.3
* https://www.nodebeginner.org/index-zh-cn.html
* https://cnodejs.org/ 技术社区
* http://nodejs.cn/learn https://nodejs.dev/learn 官网教程
* http：https://www.liaoxuefeng.com/wiki/1022910821149312/1023025830950720
* crypto：https://www.liaoxuefeng.com/wiki/1022910821149312/1023025778520640
* https://github.com/goldbergyoni/nodebestpractices

### React

* https://beta.reactjs.org/learn
* https://docs.microsoft.com/zh-cn/learn/paths/react/
* https://github.com/jaredpalmer/razzle 零配置服务端渲染
* https://github.com/facebook/create-react-app 不活跃
* https://formik.org/
* https://reactpatterns.cn/
* https://devhints.io/react
* https://react-tutorial.app/
* https://scrimba.com/learn/learnreact
* https://github.com/react-hook-form/react-hook-form
* Next.js

### Electron

* https://github.com/electron-userland/electron-forge
* https://github.com/tauri-apps/tauri

### 其它

* 自动化测试工具：https://katalon.com/ https://www.cypress.io/ appium
* 有一些功能的JSON Viewer：https://jsonhero.io
* quickjs-ng：支持到ES2022，但原版的quickjs也在更新
* https://gitee.com/weolar_admin/mininodejs20 使用quickjs替换v8后的精简版node
* bun：baseline版用于不支持avx的cpu，profile版带有debug信息

---

https://wangdoc.com/javascript/dom/text.html
https://wangdoc.com/es6/function.html#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E4%BD%8D%E7%BD%AE
https://zh.javascript.info/array-methods#tasks
https://zhuanlan.zhihu.com/p/24150808 ES6，看到7. 参数
https://segmentfault.com/a/1190000002640298#articleHeader4
https://zhuanlan.zhihu.com/p/87699079 看到Set
https://tobiasahlin.com/blog/move-from-jquery-to-vanilla-javascript/
https://scrimba.com/learn/introtoes6
https://pouchdb.com/


事件：
https://zhuanlan.zhihu.com/p/26536815
https://zhuanlan.zhihu.com/p/24136312

https://developer.mozilla.org/zh-CN/docs/Web/XPath/Introduction_to_using_XPath_in_JavaScript 一般用UNORDERED_NODE_SNAPSHOT_TYPE？

DOMNodeInserted
visibilitychange

createEvent() createAttribute()


https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central/jsshell-win64.zip

https://www.zhangxinxu.com/wordpress/2021/02/html-string-dom/

TS：
https://zhuanlan.zhihu.com/p/147765838 看12.4 泛型工具类型
http://www.semlinker.com/master-ts-generic/
https://lucifer.ren/blog/2020/06/16/ts-generics/
http://www.semlinker.com/ts-comprehensive-tutorial/#3-2-%E9%9D%9E%E7%A9%BA%E6%96%AD%E8%A8%80
http://www.semlinker.com/effective-ts-tips/
http://www.semlinker.com/categories/typescript/

https://github.com/LiangJunrong/document-library
