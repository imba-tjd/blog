---
title: 算法导论
---

算法基础
--------

### 循环不变式

1. 初始化：循环的第一次迭代前为真
2. 保持：如果循环的某次迭代前为真，那么下次迭代前仍为真
3. 终止

### 渐进记号

* O表示渐进上界，Ω表示渐进下界，Θ表示渐进确界
* 求解递归式：代入法、递归树法、主方法

代入法

* 失败时可以考虑**减去**一个低阶项
* T(n)=2T(n/2)+n -> T(n)=O(nlgn)
* T(n)=2T(n/2)+c -> T(n)=O(n)
* T(n)=2T(sqrt(n))+lgn -> 令m=lgn, T(n)=O(mlgm)
* T(n)=9T(n/3)+n -> T(n)=O(n^2)
* T(n)=T(2n/3)+c -> T(n)=O(lgn)
* T(n)=8T(n/2)+n^2 -> T(n)=O(n^3)

### 在线雇佣

类似于选苹果的故事。在n个人中只雇佣一次，希望最大化质量，则做法为：选取一个正整数k\<n，拒绝前面k个，雇佣其后面第一个比前面所有分数都高的人。k应取n/e，雇到最好的应聘者的概率至少为1/e。

### 模拟指针和对象的实现

* 多数组表示：每个属性都用一个数组表示，则相同属性储存在一起，每个数组用相同索引访问就是同一个对象的属性；此时模拟单向链表只需要一个next数组指示下一个结点的索引和一个全局的头索引
* 分配与释放：用一个全局的free值指示下一个空闲的索引位置，所有空闲的索引用next数组联系起来；分配时返回free当前指向的索引，并把free改成指向的指向的索引，释放时类似
* 单数组表示：把一个对象的所有属性储存在一起，这样允许不同长度的对象储存于同一数组中，但是管理更困难，访问属性需要用对象的位置再手动偏移

### 产生不重复随机数

* 1-m中取n个数，m较小时用洗牌算法；较大时用哈希表，重复了再抽一次
* 分布式可以用GUID
* 假随机可以在1到m-1中生成一个质数，每次取加自己模m的数，因为这是个循环群

分治法
------

1. 分解 (Divide) ：原问题分解为若干子问题，子问题是原问题的规模较小的实例
2. 解决 (Conquer) ：递归地求解子问题
3. 合并 (Combine) ：合并子问题

### 例子

* 大整数乘法
* 二分查找
* 矩阵乘法
* 归并排序
* x的n次幂：分奇偶，n是偶数就是f(n/2)相乘，是奇数就再乘以x

### 最大子数组问题

例如：[13, -3, --25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]，18到12之和即为最大子数组。此问题中部分元素必须小于0否则无意义；或者如果全是正的而要算变化值最大的，可以用后一个减去前一个，就会出负的

* 分治算法：取中点，任何一个子数列只有{完全位于左边、完全位于右边、跨过中间}三种情况，取三者最大值。前两者是原问题的较小规模，递归求解。第三个问题不是原问题，但容易求解，就是从中间往两边延伸，记录最大值
* dp：与常规化的不同。定义dp[i]为以nums[i]结尾的数组的最大子数组值，dp[i]=max{dp[i], dp[i-1]+dp[i]}，最后遍历一遍dp取最大值（不是返回dp[最后一个]）
* 在线处理：只需遍历一遍即可完成。从头开始加，记录下最大的时候；如果加到了小于0就之间把前面的部分全部舍弃，因为当前评估的值会抵消掉之前所有的和，直接不要了（最大的还是要记录着）

### 计数排序、基数排序

* 基数排序(radix sort)：对十进制数字来说，从低有效位到高有效位进行排序；排序算法必须稳定，故可选计数排序
* 计数排序：见下

```
CountingSort(int A[], int B[], int k){ // A为原数组，B为排序后的数组，k至少为A中的最大值+1
    int* C = calloc(k, sizeof(int));
    for(int i=0;i<A.Length;i++)
        C[A[i]]++; // 设t=A[i]，则C[t]是A里值等于t的元素的个数
    for(int i=1;i<k;i++)
        C[i]+=C[i-1]; // C[t]是A里值小于等于t的元素的个数，且C[k-1]==A.Length
    for(int i=A.Length-1;i>=0;i++) // 将原数组从后往前复制能保证稳定
        B[C[A[i]]--]=A[i]; // C[t]即为排序后的元素的索引，复制一个以后减一获得下一个同值元素的新索引
}
```

动态规划
--------

### 原理

* https://www.zhihu.com/question/23995189/answer/613096905
* 最优子结构：一个问题的最优解包含其子问题的最优解。计算出子问题的最优解后通过状态转移方程计算原问题的最优解
* 重叠子问题：反复求解相同的子问题；同时也是与分治的区别
* 无后效性：后续决策不受历史决策过程影响，只依赖状态，不依赖到达此状态的步骤。如最长路径不具有最优子结构的性质。要求出过程不行，只求结果可以

#### 步骤

1. 刻画一个最优解的结构特征。
2. 递归定义最优解的值。
3. 计算最优解的值，通常采用自底向上的方法。
4. 利用计算出的信息构造一个最优解。

另一种自底向上的思路：先根据已知条件把显而易见的算出来，再按一种方向把剩余的填充。

### 例子

* 常规化的定义：dp[i]表示对于nums[i]满足条件的结果，假如已知dp[i-1]，分类讨论如何算出dp[i]，最后返回它即可
* 钢条切割、矩阵链乘：自底向上，f(x)=max/min{g(分割点i)}
* 0-1背包问题：价值 arr[重量]，arr[x]=max{arr[x-w(i)]+v(i)}；找钱问题：RMB可用贪心，但如面额只有11、5、1，找15时只能用DP，数量 arr[金额]
* 最长公共子序列（LCS）：对于两个序列X和Y来说，如果最后一个元素相等，则LCS去掉最后一个元素形成的序列Z-1是X-1和Y-1的LCS；如果不等，则X和Y的LCS=max{(X-1,Y), (X,Y-1)}，它有重叠子问题(X-1,Y-1)。一直到(X,0)和(0,Y)=空
* 最长递增子序列（LIS）：dp[x]表示**以第 x 元素为结尾的LIS**的长度，则=max{dp[i]+1, if arr[x]\>arr[i]}，这样复杂度为O(n^2)，还有[nlogn的做法](https://blog.csdn.net/joylnwang/article/details/6766317)；可以建树但想不清复杂度是多少

贪心算法
--------

* 无状态，不会重新选择
* 局部最优解就是全局最优解：每次选择分支的时候，只要选择一个分支，这个分支的解就一定比其他选择更优

## 最短路径

```
Relax(u,v,w){ // 松弛
    if(v.d>u.d+w(u,v)){ // w为直接距离
        v.d=u.d+w(u,v); // 最短距离
        v.p=u; // 前一个结点
    }
}

BellmanFord(G,w,s){
    InitializeSingleSource(G,s); // 所有结点v.d=无穷，v.p=null
    for(int i=1;i<=G.V-1;i++) // 循环点的数量-1次
        foreach edge(u,v) from G.E // 每次松弛所有的边
            Relax(u,v,w);
    foreach edge(u,v) from G.E
        if(v.d>u.d+w(u,v)) // 存在权重为负的环路
            return false;
    return true;
}
// 动态规划的BF算法：dx(y)=min{cx(v1)+dv1(y), ...}，v为x的相邻结点

Dijkstra(G,w,s){
    InitializeSingleSource(G,s);
    S=空集;
    Q=G.V;
    whlie(Q!=空集){
        u=ExtractMin(Q);
        S=S.Add(u);
        foreach v from G.Adj[u] // 所有指出u的结点
            Relax(u,v,w);
    }
}

InitializeSingleSource(G,s){
    foreach v in G.V{
        v.d=无穷;
        v.p=null;
    }
    s.d=0;
}
```

尾递归
------

* 把尾递归改成递推：https://zhuanlan.zhihu.com/p/36587160
