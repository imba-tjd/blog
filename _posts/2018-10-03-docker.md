---
title: Docker
---

## 安装

```bash
sudo apt update; sudo apt install apt-transport-https ca-certificates curl gnupg2 software-properties-common
curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable" # https://mirrors.aliyun.com/docker-ce/linux/debian
sudo apt update; sudo apt install docker-ce docker-ce-cli containerd.io
sudo docker run --rm hello-world

# --or--
curl -fsSL https://get.docker.com | sudo sh -s -- --mirror Aliyun
# https://get.daocloud.io/docker/

# 只安装CLI
curl -fsSL https://download.docker.com/linux/static/stable/x86_64/docker-19.03.7.tgz | tar zxvf - --strip 1 -C /usr/bin docker/docker

# 卸载：
sudo apt-get purge docker-ce
sudo rm -rf /var/lib/docker
```

### 非root运行docker

```bash
sudo groupadd docker
sudo usermod -aG docker $USER
newgrp docker
# 如果在运行上面命令之前运行过sudo docker，则还需要运行：
sudo chown "$USER":"$USER" /home/"$USER"/.docker -R
sudo chmod g+rwx "$HOME/.docker" -R
```

## /etc/docker/daemon.json

* systemctl daemon-reload && systemctl restart docker

```json
{
  "registry-mirrors": ["..."],
  "exec-opts": ["native.cgroupdriver=systemd"], // 默认的是cgroupfs，但Kubernetes推荐使用systemd
  "experimental": true, // 或在运行dockerd时用--experimental；现在只有四个实验性功能
  "features":{ "buildkit": true },
  "ipv6": true,
  "fixed-cidr-v6": "xxx", // 必须要加这个否则dockerd拒绝启动，但即使加了也ping6不通

  "tls": true,
  "tlscert": "/var/docker/server.pem",
  "tlskey": "/var/docker/serverkey.pem",
  "hosts": [
    "unix:///var/run/docker.sock",
    "tcp://0.0.0.0:2375"
  ],

  "live-restore": true, // 重启dockerd的时候容器不会停止，但版本升级后可能无法恢复对容器的控制
  "data-root": "/mnt/docker-data", // 存储目录，默认是/var/lib/docker；也可以用软链接
  "log-driver": "json-file", //【默】
  "log-opts": { "max-size": "10m", "max-file": "3" },
  "default-ulimits": {
    "nofile": { "Name": "nofile", "Hard": 64000, "Soft": 64000 }
  },
}
```

### registry-mirror列表

* https://docker.mirrors.ustc.edu.cn
* https://hub-mirror.c.163.com
* http://aad0405c.m.daocloud.io http://f1361db2.m.daocloud.io
* https://docker.mirrors.ustc.edu.cn
* https://dockerhub.azk8s.cn
* https://cr.console.aliyun.com/#/accelerator
* 自动添加：curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s 加速器地址

## docker CLI命令

### 安装/管理image

* docker search：搜索image
* docker pull author/image_name:tag：tag默认为latest
* docker image ls / docker images
* docker image rm [-f]：不加-f则必须删除所有对应容器才能删除image，加了-f，如果没有正在运行的容器则能成功删除image，否则无法完全删除，而容器无论是否正在运行都不会被删；删除所有image：`docker rmi $(docker images -q)`
* docker image prune：删除不用的，直接使用会删除虚悬镜像，即仓库名和标签均为none且没有对应容器正在运行的

### 运行

* docker run -it image_name *程序* *参数*：创建并运行新容器，基本相当于docker create加上docker start；如果image不存在会自动下载；i表示打开并保持stdout，t表示分配一个tty终端；--name指定容器名，-w指定工作目录
* 如果使用exit退出，则容器的状态处于Exit，而不是后台运行。如果想一直运行，可以使用 ctrl+p ctrl+q 退出，此时容器的状态为Up
* docker run -d image_name -p 宿主机端口:容器公开的端口：d为后台运行，不会有输出，要用docker logs才能查看stdout；p进行端口映射
* -h指定hostname，-m设置容器能使用的内存最大值；--restart always/on-failure/exitcode[:maxcount]可以自动重启；--rm可以在退出时自动删除容器；--sig-proxy=false使Ctrl + C不停止容器中的进程
* 但run有其不可替代性：一是设置端口只能使用它；二是run -it用create -t; docker start -ai替代，后者要么无法输入，要么就是看不到输出

### 管理container

* docker ps [-a]：查看容器。不加a只显示正运行的；-q只显示ID，$(docker ps -q)可列出所有正在运行的容器，方便提供给其他命令操作；-l显示最后运行的无论是否停止；-f status=running/exit可指定状态
* docker kill、docker rm、docker start、docker stop、docker restart、docker rename、docker top显示容器内的进程、docker inspect查看详细信息
* docker stats：不断刷新地显示正运行的容器的状态，类似于tail -f
* docker logs container_name [-f] [--tail n] [-t]：-f类似于tail -f，--tail n显示最后n条记录，-t为每条日志加上时间。默认的日志驱动是json-file，如果改成syslog，该命令就不会输出内容，或用none就不会有任何日志
* docker create [options] image_name [command] [arg]：创建容器。只是创建一层文件系统，不运行。但是是在此时设定默认命令等参数，注意options的位置。重启或停止再启动还是会保持创建时的参数
* docker container prune：删除所有处于停止状态的容器
* docker start默认是detach的，用-ai可自动附加进去；或启动后attach进去。如果创建时没有-t，则start后可能直接结束。但测试后即使有-t，也输入不了
* docker exec执行完命令自动退出且不停止容器。执行单个命令，如果只有命令行参数，就什么参数都不用，如果需要stdin输入就用-i。如果想获取终端，用-it bash。也支持-d。但它只支持Up状态的容器
* docker container update [options] container_name：添加一些参数，比如自动重启，但已知不能修改端口映射

### 转换

* image和文件之间的转换：`docker save alpine|xz -9e>alpine.xz`、`docker load -i alpine.xz`或`unzip -p alpine.xz.zip|unxz -c|docker load`
* 容器转换为image：docker commit *容器名* *author/new_image_name:tag* [-m message] [-a author]
* 另一种容器转image： docker export container_name | docker import - image_name；会丢失所有的层；保存到文件用重定向，读取用cat

### Volume

* 可以在容器之间共享和重用；修改会立马生效；会一直存在，即使容器被删除，反过来对于普通的容器，即使是停止而不是删除，里面的东西也会丢
* 一般有两种方式，一是数据卷 Volumes，二是挂载主机目录 Bind mounts。Volumes方式下，容器内的数据被存放到宿主机一个特定的目录下(/var/lib/docker/volumes/)，这个目录只有Docker可以管理
* docker volume create my-vol [-o type=tmpfs -o device=tmpfs -o o=size=2m,uid=1000] [-o type=nfs -o addr=192.168.1.1,rw -o device=:/path/to/dir]
* docker volume ls、docker volume rm、docker volume prune、docker volume inspect
* docker run -v my-vol:/webapp或--mount source=my-vol,target=/webapp 命名可省略，注意这是容器中的路径
* docker run -v /src/webapp:/opt/webapp或--mount type=bind,source=/src/webapp,target=/opt/webapp 不能为相对路径否则就变成上一条了，想用当前路径可用$PWD
* docker run --volumes-from 加另一个容器的名字，可直接共享指定容器的volume
* 默认权限为读写，:ro或,readonly可设为只读；另外还有个z和Z的选项，前者表示该卷会在容器中共享，后者表示是私有的，但好像只有用selinux才需设
* 使用-v时，如果宿主机上没有这个文件，会自动创建，而--mount会报错找不到这个文件并创建失败
* 还有一种类型是tmpfs，可以做mount的type，不用写source；也可以直接用run的--tmpfs加目录。可指定tmpfs-size
* 本地文件在`/var/lib/docker/volumes/<volume_name>/_data`中

### 通过TCP访问dockerd

```bash
docker -H tcp://0.0.0.0:2375 ps
docker -H ssh://me@example.com:22 ps

export DOCKER_HOST="tcp://0.0.0.0:2375"
docker ps
```

### 其他

* name只能含有`[a-zA-Z0-9_.-]`且至少要两个字母
* 许多时候可以用-f/--format来选定要看的东西
* 容器是否会长久运行与-d无关。可以想象成开了另一个窗口，但Linux只能看到当前窗口；-t相当于先运行终端再运行程序，而不是bash -c？只用-i运行bash时看不到提示符但仍可输入输出，用不了上下左右，仅仅是把stdin重定向到容器里了
* 如要运行一个bash的守护容器，只能用run -dit（如果没有t它会自动退出），之后用exec -i name cmd执行命令，用exec -it name bash附加进去且退出时不会导致容器停止。最后一条必须要i但前两条没有i也能成功，不懂。目前暂时只有入口点是bash等shell以及之后要用nano才需要dit
* docker history、docker port、docker cp src container:/dest、docker logs、docker secret
* docker system df：显示容器和镜像占用的磁盘空间
* docker buildx install：使用buildx替代build命令；但即使我开了experimental也提示找不到该命令

## [网络](https://docs.docker.com/network/)

* docker network create -d bridge/overlay --subnet=168.18.0.0/24 mynet
* docker network ls
* docker run --net="bridge/host/none/container"指定容器的网络连接类型，--add-host添加host和ip的映射
* EXPOSE是容器之间互相访问的端口，且在--icc=true的时候即使不EXPOSE也能互相访问。PUBLISH是-p、-P和compose的ports，是容器与宿主之间的访问，且会隐式EXPOSE。可以有EXPOSE了但不PUBLISH的端口
* -p 宿主IP:宿主端口:容器端口[/udp]，端口可以写范围如8001-8010，宿主端口可省略，则会随机；-P是自动映射所有EXPOSE了的端口到宿主机的随机端口
* IP指定*或0.0.0.0或::或不指定效果都是监听所有IP且是双栈；127.0.0.1或::1就只是本地单栈
* 一般情况是不需要指定容器 IP 地址的。其地址是供容器间通讯的，容器间则不用 IP 直接通讯，而使用容器名、服务名、网络别名
* --link过时了
* 在Docker运行的系统上不应该运行任何防火墙，因为docker自己会用iptables规则来进行网络数据流的控制，而firewalld或ufw也会用，就会发生冲突。可以使用云服务器的边界防火墙
* Docker对宿主机网络环境的影响：https://zhuanlan.zhihu.com/p/59538531
* 修改`/var/lib/docker/containers/[hash]/hostconfig.json`可以修改端口映射，但必须先关掉dockerd；另一种方法是把容器提交成image再重新run
* 如果容器不支持https，反代时要显式设置http协议，否则会报502 bad gateway
* https://github.com/docker/docker-ce/blob/master/components/cli/experimental/vlan-networks.md

## Dockerfile

* docker build --rm -t *image_name* *path*（一般是.），或docker image build。最后那个点是上下文路径，对应COPY的第一个参数的点，一般但不一定是Dockerfile所在路径，后者可用-f指定。如果不加-t，就会用from的映像名
* 每个指令都会创建一个新的镜像层，镜像层将被缓存和复用。当Dockerfile的指令修改了、复制的文件变化了，或者构建镜像时指定的变量不同了，对应的镜像层缓存就会失效。某一层的镜像缓存失效之后，它之后的镜像层缓存都会失效。因此要把不变的和经常变的要分开，变化少的放在前面
* 但像apt update这样命令没变实际会变的也会被缓存，可以在前面设置一个日期ARG/LABEL，改变以后就会重新构建
* 镜像层是不可变的，如果我们再某一层中添加一个文件，然后在下一层中删除它，则镜像中依然会包含该文件，只是这个文件在Docker容器中不可见了
* 运行命令的shell形式在底层会用 /bin/sh -c，能解析环境变量；exec形式如果想解析变量就要自己用sh和-c和真实命令作为三个参数了
* build --squash会把镜像所有基础层信息去掉，只在最顶层添加一个merge层，需要开experimental；但感觉效果不大，除非dockerfile写得太差
* build --no-cache
* docker builder prune：清理build缓存

```dockerfile
# 以哪个镜像为基础。一般用debian就好，虽然有一百M但那只是第一次下载，要不就用stable-slim，小一半。如果用alpine且装完了依赖最终大小也差不多，那分发应用时却要每次都下载，就还不如debian；不过已知debian没有ps；Google还出了一个distroless，但没有alpine小
FROM debian

# 如果不指定，用的就是root
# RUN groupadd -g 999 USER && useradd -r -u 999 -g USER USER
# RUN addgroup www && adduser -u 1001 -S -H -s /sbin/nologin -g 'nginx' -G www www
# USER NOBODY:NOBODY

# 会显示在metadata里；key可省略引号，value如果不含空格应该也可以省
LABEL key=value maintainer=xxx

# build --build-arg key=value。与ENV相比只在dockerfile构建阶段生效；且在FROM前使用该指令就只能用于FROM；不要传secrets因为可以被docker history看到；已经默认定义了HTTP_PROXY等几个代理有关的ARG和TARGETPLATFORM和BUILDOS等ARG；会导致缓存失效
ARG Version[=1.0]

# 运行RUN/CMD/ENTRYPOINT的地方，不用自己mkdir建；不是COPY的相对dest
WORKDIR ./app

# 在build这个镜像时执行的操作；一般要像这样把多个命令串联为一个RUN，并在最后清理
RUN set -x && \
    apt update && \
    apt-get install -y --no-install-recommends git && \
    rm -rf /var/lib/apt/lists/* && \ # 由update生成的
    apt-get purge -y --auto-remove ...

# 拷贝本地文件到镜像中，不能对构建目录之外的文件进行操作，如果目录不存在会自动创建；src可以有多个；如果src是目录，只会复制里面的文件
COPY . /usr/share/gitdir
# ADD 也是复制但功能更多，1.允许src是url，2.如果src是可识别的压缩文件且第二个参数以斜杠结尾是目录，会解压后复制进去。所以在不主动需要这俩功能时最好用copy。不过好像不允许自动解压来自于url的压缩文件

# RUN npm install xxx # 前一个RUN安装环境（当然如果有已经构建好的镜像就最好），然后添加项目代码，此时再还原项目依赖。不要写到一个RUN里去
# RUN chmod +x /entrypoint.sh

# 在bash中定义export key2=value2
# 命令行传入：docker run -e "key1=value1" -e key2，从指定文件读入：-env-file=[]。相比于ARG，在运行后的环境里也有效，且构建时在有些指令中也有效，在RUN等里无效
ENV NAME=World

# 自动周期性地执行该命令，能防止容器的确在运行但程序死循环了的现象
HEALTHCHECK [--interval=5s] [--timeout=3s] CMD curl --fail http://localhost:$APP_PORT || exit 1

# 如果没有ENTRYPOINT，此指令就是要运行的程序和参数，且能被docker run指定的内容覆盖；如果不存在此指令，会继承
CMD git --version # shell模式 ；CMD ["git", "--version"]就直接以git作为启动对象
# 在有ENTRYPOINT的情况下，CMD的内容会作为ENTRYPOINT的参数，仍能被run覆盖，见下一条

# ENTRYPOINT可在run时用--entrypoint指定；如果ENTRYPOINT没带参数且用的是exec形式，就会把CMD指令的内容作为参数；例如：
# CMD ["p in cmd"]
# ENTRYPOINT ["echo"] # 若用shell形式 ENTRYPOINT echo，则无法传入参数，CMD仍忽略
# docker run xxx # p in cmd
# docker run xxx p in run # p in run
```

### **多阶段构建**

```dockerfile
FROM <sdk> AS build
WORKDIR /src
COPY . .
RUN ... # 输出到/app

FROM <runtime>
WORKDIR /app
COPY --from=build /app .
ENTRYPOINT ...
```

### 其它指令

* STOPSIGNAL：容器停止时发送什么系统调用信号给容器
* ONBUILD：当该映像被其它映像FROM后会自动紧接着调用，后面可跟其它的指令（除了FROM和ONBUILD本身）。只能会继承一次
* EXPOSE：见网络
* VOLUME：只能是挂载内部目录，使得重启后不丢失。注意在Dockerfile后面的指令修改了指定的目录是不会生效的，CMD除外

### .dockerignore

```
# 与.gitignore的语法一样
.git/
node_modules/
```

### BuildKit

* 临时使用：`DOCKER_BUILDKIT=1 docker build .`，永久使用可在daemon.json里设置或用export；无需experimental
* 支持并行的多阶段构建、更好的缓存管理、更已读的日志；支持secret mount，无需root权限
* https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md#experimental-syntaxes

```
# syntax = docker/dockerfile:experimental

# 使用secret：build --secret id=mysecret,src=mysecret.txt
RUN --mount=type=secret,id=mysecret cat /run/secrets/mysecret # 默认secret位置
RUN --mount=type=secret,id=mysecret,dst=/foobar cat /foobar # 自定义secret位置

# clone私有仓库：build --ssh default
RUN apk add --no-cache openssh-client git
RUN mkdir -p -m 0600 ~/.ssh && ssh-keyscan github.com >> ~/.ssh/known_hosts
RUN --mount=type=ssh git clone git@github.com:myorg/myproject.git myproject
```

## 发布

1. export docker_account=account-name
2. docker login
3. docker tag python-dockerfile $docker_account/python-dockerfile
4. docker push username/repository:tag

### registry

* https://hub.daocloud.io/
* https://c.163.com/hub#/m/home/
* https://quay.io：公开仓库是免费的

## docker compose

* pip install docker-compose；命令补全：`curl -L https://raw.githubusercontent.com/docker/compose/$(docker-compose version --short)/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose`
* docker-compose up -d，-f指定文件，默认是`docker-compose.yml`，可一次指定多个，会合并添加到一起处理，若字段相同则后指定的覆盖前面的；-p指定项目名，默认是文件夹名；如果已经存在会停止容器重新创建，-d --no-deps SERVICE_NAME可只重新创建指定的
* logs、ps、port、build、pull、start、restart、stop、pause、unpause；down移除容器和网络，-v也移除volumes；scale web=3 db=2设置指定服务运行的容器个数（service=num）；run ubuntu ping docker.com在指定服务上执行一个命令；config验证文件格式是否正确

```yaml
# https://docs.docker.com/compose/compose-file/
version: '3.7'

services:
  web: # 可自己命名的服务名，也会作为其它服务连接过来的主机名
    image: nginx
    container_name: mynginx
    command: 相当于CMD
    ports:
      - 443:443
    networks:
      - frontend
    volumes: # volumes_from略
      - conf:/etc/nginx # bind模式可用./xxx，不知.是否可以，是与yml相对的路径
    restart: always
    environment:
      HOST: example.com
      PASSWORD: /run/secrets/my_secret
    secrets:
      - my_secret

  worker:
    build: # 或直接build: .
      context: ./dir
      dockerfile: Dockerfile-alternate
      args:
        buildno: 1
    image: myworker:tag
    depends_on:
      - web

volumes: # 新建volume
    conf: # 冒号后什么也不用加
    db-data:

networks:
  default:
    external:
      name: nginx-proxy # 此处的nginx-proxy为之前创建的docker network
  my-bridge:
    driver: bridge

secrets:
  my_secret:
    file: ./my_secret.txt

sysctls:
  net.core.somaxconn: 1024
  net.ipv4.tcp_syncookies: 0
```

## UI

* lazydocker：终端的UI
* portainer：docker run -d -p ::1:9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer；官方还加了-p 8000:8000不知道有什么用，强行指定admin密码用--admin-password；直接初始化使用本地的用-H unix:///var/run/docker.sock
* https://github.com/google/cadvisor ：分析容器的资源使用情况
* https://prometheus.io/ ：自动报警系统

## K8s管理平台

* rancher，有中文文档，资源消耗较高
* kubesphere：国产的，才出不久，相对简单
* k3s：https://blog.ilemonrain.com/docker/rancher-with-k3s.html

## 参考资料

* 官方文档：https://docs.docker.com/
* https://zhuanlan.zhihu.com/p/23599229
* https://blog.csdn.net/u010900754/article/details/78526443
* https://zhuanlan.zhihu.com/c_1029363331018084352

### 未看的

* Protect the Docker daemon socket：https://docs.docker.com/engine/security/https/
* 在线练习（需要登录）：https://training.play-with-docker.com/ https://training.play-with-kubernetes.com/
* Docker 问答录（100 问）：https://blog.lab99.org/post/docker-2016-07-14-faq.html#vethxxxx-zhe-chong-xu-ni-wang-qia-he-rong-qi-de-dui-ying-guan-xi-cong-na-li-kan
* gosu与sudo
* 每天5分钟玩转 Docker 容器技术：https://www.jianshu.com/p/0c6e330d559b
* DaoCloud的文档：https://guide.daocloud.io/dcs/daocloud-services-9152664.html
* docker从入门到实践：https://vuepress.mirror.docker-practice.com/ https://yeasy.gitbooks.io/docker_practice/
* 书：Learn Docker in a Month of Lunches、 The Kubernetes Book、 Docker in Action

#### IPV6

* https://blog.csdn.net/bleatingsheep/article/details/80534153
* https://blog.csdn.net/taiyangdao/article/details/83066009
* https://docs.docker.com/v17.09/engine/userguide/networking/default_network/ipv6/
* https://www.v2ex.com/t/553814
* https://github.com/docker/for-linux/issues/829
* https://docs.opnfv.org/en/stable-fraser/submodules/ipv6/docs/release/userguide/ipv6-in-container-networking.html
