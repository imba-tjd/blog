---
title: GoLang
---

## 安装

* apt install golang-go; go version
* gccgo：使用起来与其它gcc一样，编译结果小很多
* docker映像：默认是debian的，没有slim版；精简版golang:alpine。之后可用`-v $PWD:/v -w /v`挂载当前目录进去
* SDK不支持x86
* go env -w GOPROXY=https://goproxy.cn,direct，还有goproxy.io，mirrors.aliyun.com/goproxy，goproxy.bj.bcebos.com
* https://mybinder.org/v2/gh/gopherdata/mybinder-go/HEAD

## 命令

* go run .
* go doc module func：显示文档
* go fix：从老版本的语法迁移到新版本
* go vet：检查语法错误
* go clean
* 编译安装全局命令行工具：go install xxx@latest
* 减少编译后的体积：go build -ldflags "-s -w"
* 静态编译：https://github.com/golang/go/issues/26492
* 交叉编译，默认就是静态的：CGO_ENABLED=0 GOOS=windows GOARCH=386 go build
* Win下隐藏命令行窗口：-ldflags "-H windowsgui"

## 变量和类型

* `var i, j int = 1, 2`
  * 类型写在变量名后面
  * 连续多个参数类型相同，可只写最后一个
  * 如果初始化了，可以省略类型
  * 函数内的简化声明：i := 1
  * 同时声明多个不同类型的：var(a=1 换行 b=2)
  * 声明了但未使用的变量会报error，可用_=v解决
* bool int int32 uint uintptr byte float32 float64 string rune代表Unicode码点
* 3 / 2结果为1，3. / 2结果为1.5
* 类型定义：type status bool，两者是不同的类型；类型别名：type Text = string，两者是同一个类型，编译后会去掉
* 类型转换：T(v)
* 常量：const Pi = 3.14
  * iota：一个在const块中每使用一行自动+1的量，如const (a = iota; b; c)则a为0，b为1，c为2
  * 没赋值的会自动用上一条的表达式，如a = 1 << iota; b; c，则b为2，c为4
* 指针：*T、new(T)、nil，无法进行加减运算
* 结构体
  * 声明类型：type Point struct { ... }
  * 创建实例：Point{1,2}、Point{Y:2}、&Point{}
  * 访问结构体指针的字段也可以用点
* 数组
  * var arr [3]int自动初始化为零值、var arr = [3]int{1,2,3}、arr := [3]int{1,2,3}
  * 可以直接输出
  * 大小固定，用[...]时根据字面量自动设定长度
  * 是值语义，传参时会整个复制
* 切片
  * 数组转切片：var s []int = arr[1:4]、s := arr[1:4]。arr必须是左值，无法把一个返回数组的函数直接[:]，必须先声明数组接收
  * 只是描述一段，不会复制。可以往大了切但不能超过底层的最大大小
  * len(s)表示它拥有的元素个数，cap(s)表示从它第一个元素开始数到原数组末尾的个数
  * 只声明不赋值时它==nil，但len(它)是0，Println(它)是[]，也支持append
  * 切片字面量：a := []int{1,2,3} 不用写长度，实际是底层创建临时数组再取切片
  * 创建空切片：a := make([]int, 4) 长度为4，值都为0；make([]int, 0, 5) len为0，cap为5，表面上无元素，实际底层数组有
  * 添加数据：a = append(a,4,5)/append(a,[]int{4,5}...) 如果底层cap够用，就修改底层添加新元素，否则会创建新底层
  * 复制：copy(a,b) 把b对应位置赋给a，超出部分不做处理
* 映射
  * m := make(map[string]int) 必须初始化，用var声明的是nil
  * m := map[string]int {"a":1, ...}
  * m["a"] = 1 可直接对不存在的key赋值
  * elem, ok := m[key] 取值当key不存在时ok为false，elem是对应类型的零值
  * delete(m, key)
* 运算符优先级：暂时不学

### 字符串和格式化

* 控制台输出：fmt.Print(对象)、fmt.Println(对象)、fmt.Printf("模式", 对象)
* 文件输出：fmt.FPrint(io.Writer)、...
* 格式化为字符串：var s string = fmt.Sprintf("模式", 对象)
* 格式化模式
  * %v  默认格式。结构体会调用fmt.Stringer接口中的String()函数，接口会使用实际类型
  * %+v 对于结构体，还输出字段名
  * %#v 相当于Py的__repl__
  * %T  类型
  * %%  转义一个百分号
  * %b  二进制
  * %[]v 指定某个索引，从1开始
* 原始字符串：反引号
* TODO: strconv
* 正则：var r = regexp.MustCompile("[0-9]+"); r.Find(s); r.MatchString(s)

## 分支和循环

```go
if a := 1; a > 2 { }
for i := 0; i < 10; i++ { sum += i }
for sum < 1000 { } // 相当于while
for { } // 无限循环
for i,v := range arr // i是下标，v是值的副本，遍历map时是k和v；可用_忽略下标，可不写,v忽略值
switch i := 1; i+1 { // 无条件的switch和switch true一样，case可用条件表达式，代替一长串ifelse
  case 1+1: ... // 无需break，顺序执行指明fallthrough；case后的可以是表达式，同时满足多个用逗号
}
```

## 函数

* defer语句将函数的调用推迟到外层函数返回后执行，若有多个则按FILO调用
* 返回值可以命名，相当于在一开始声明了变量，最后用无参return
* 不定长参数：`params ...int`，使用时可用切片`slice.../arr[:]...`
* 不支持默认参数，不支持重载

```go
func add(x int, y int) int { return x + y }
func swap(x, y string) (string, string) { return y, x } // 多值返回，调用者不需要的用_丢弃
// 具有值语义，可以作为参数和返回值，可以赋给变量，支持闭包；以下也可以直接return func...
func compute(fn func(int, int) int) func(int) int { f := func(n int) int { return fn(1,n) }; return f }
// 泛型，comparable预定义表示支持==和!=，这样才能作为map的key；type Number interface{int|float32}限定v的类型，也可直接写里面
func SumNumbers[K comparable/any, V Number](m map[K]V) V { }
```

## 方法和接口

* 在func和函数名之间加”接收者“就定义了方法，同名函数可以有不同类型的接收者
* 接收者类型用*T传递对象的引用
* 为了方便，T与*T类型的对象能自动转换，调用对方类型的接收者的方法；但接口是严格的
* 接口表示函数无需func关键字，还可以表示字段，无需var

```go
func (p *Point) F() { print(p.X) }; p := {}; p.F() // 方法必须和Point的定义在同一个文件中
type P interface { F() }; var pp P = &p; p.F() // 其中Point对F的实现在另一个文件中
var pp P = nil; pp.F() // 运行时错误
var p *Point = nil; pp := p; pp.F() // 能进到F()中，且pp != nil，但F()中的p == nil
var a any = 1; b,ok := a.(int) // 类型断言a保存了int
switch b := a.(type) {case int: ...} // 诡异的语法
```

## 错误处理

* panic("信息")：调用后终止当前流程，开始执行defer了的函数，如果没有recover就再往上执行
* recover：必须先声明一个defer func，用if err := recover(); err != nil {}捕获之后可能发生的错误，再调用会panic的函数。类似于goto的错误处理
* error：一般用函数的多返回值，return errors.New("信息")，调用者用if err != nil表示发生了错误
* 自定义错误：MyError结构体实现error接口的Error()，函数返回error时返回&MyError{}
* https://go.dev/blog/error-handling-and-go https://opencredo.com/blogs/why-i-dont-like-error-handling-in-go/

## 模块

* 一般工作区根目录的main.go用package main再定义func main()作为入口点，命令行参数用os.Args获得，0号是程序自己
* go mod init example.com/hello，之后build出的就是hello.exe
* go mod tidy：自动把import了包写入go.mod，还会清除未使用的
* go get：下载mod中列出的包。-u：更新全部包
* go mod vendor
* 大写的函数是导出名，小写的是未导出的
* import的是模块名/目录或分支，使用时是包名.函数名，与文件名无关；一般包名和基本目录名相同避免迷惑，一个目录只能有一个包名
* 用`p "..."`创建包名的别名，用`"./"`指定相对路径，用`_ "..."`避免自动删除未使用的包

## 文件和IO

```go
// TODO: https://www.cnblogs.com/wangqianlove/p/12579994.html
ioutil：建议优先使用os和io模块
file, err := os.Create("data.txt")
file.Write()
fmt.Fprint(file, "内容")
file.Close()
os.WriteFile(filename, "...", 0600)
```

* io.Reader接口，具有Read([]byte)方法
* io.Copy(os.Stdout, &r)

## 网络

TODO

## 并发

* go run -race检测竞态，需要启用cgo，资源消耗大
* goroutine：在调用函数前加go
* channel
  * c := make(chan int)，用`<-chan int`类型表示只读通道
  * 第二个参数指定缓冲大小，默认为1，满了发送方会阻塞，空了接收方会阻塞。有一定检测死锁的能力
  * ch <- v 将v发送给ch。close(ch)关闭，只有发送方能关闭，一般情况下无需关闭
  * v := <-ch 从ch取出值，第二个返回值ok为false时表示信道已关闭
  * for v:= range c {}能不断从ch获取值，直到它关闭
* select
  * 位置上和无条件switch一样，分支用case v:=<-ch
  * 阻塞直到任意一个分支可以执行，如果有多个可执行就任意一个，如果都没准备好就执行default（如果有）
* 互斥：sync.Mutex、Lock、Unlock、WaitGroup。保证只执行一次：sync.Once
* 对基元类型原子操作：sync/atomic

## [标准库](https://pkg.go.dev/std)

### math/rand

* rand.Seed(time.Now().Unix())
* rand.Intn(10) 在[0,10)
* rand.Uint32()、rand.Float32()

### time

* time.Now()
* time.Sleep(100*time.Millisecond)

### encoding/json

* https://zhuanlan.zhihu.com/p/121037840

### log

* 没必要用Println()，因为各条都是分开的，默认就会换行
* log.SetPrefix("greetings: ")
* log.SetFlags(0)：默认会输出日期和时间，此调用会禁用
* log.Fatal(err)：相当于log.Print()再os.Exit(1)

### os

* os.Stdout
* os.Exit()

### crypto

* crypto/md5：sum:=md5.Sum([]byte("内容")); hex.EncodeToString(sum[:])

## 测试

* 文件以_test.go结尾
* 测试函数以Test为前缀，接受(t *testing.T)参数
* 如果调用了t.Error、t.Fail等，则认为失败
* go test命令

## TODO

* https://go-zh.org/doc/faq 看到“为什么我的nil错误值不等于nil？”
* httpclient md5 sort reflect
* https://golang.google.cn/doc/articles/wiki/
* https://golangr.com/
* https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/04.4.md 较老
* https://go-zh.org/doc/ 代码漫步 实效 Go 编程（对照新版看） https://blog.go-zh.org/laws-of-reflection

* https://golang.google.cn/doc/
* https://gfw.go101.org/article/constants-and-variables.html 原生中文，内容较多
* https://github.com/golang/go/wiki
* https://leanpub.com/GoNotebook/read
* https://www.golang-book.com/books/intro
* https://gifm.dev/screencasts/
* https://gobyexample.com/ https://gobyexample-cn.github.io/
* https://yourbasic.org/golang/
* https://www.programming-books.io/essential/go/
* https://programming.guide/go/
* https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md 原生中文
* https://gowebexamples.com/

### 库

* https://github.com/gin-gonic/gin https://gin-gonic.com/zh-cn/docs/ https://golang.google.cn/doc/tutorial/web-service-gin
* https://github.com/go-gorm/gorm
* https://github.com/spf13/cobra CLI
* https://github.com/thoas/go-funk 函数式
* https://github.com/PuerkitoBio/goquery
* https://github.com/fyne-io/fyne GUI，短期内不考虑学
