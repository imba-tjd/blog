---
title: GoLang
---

## 安装

* apt install golang-go; go version
* gccgo：使用起来与其它gcc一样，编译结果小很多
* docker映像：默认是debian的，没有slim版；精简版golang:alpine。之后可用`-v $PWD:/v -w /v`挂载当前目录进去
* SDK不支持x86
* go env -w GOPROXY=https://goproxy.cn,direct，还有goproxy.io，mirrors.aliyun.com/goproxy，goproxy.bj.bcebos.com
* https://github.com/x-motemen/gore REPL环境
* golangci-lint：用于CI，提供GitHub Actions
* VSC
  * 不自动删除未使用的包：`"[go]":{"editor.codeActionsOnSave":{"source.organizeImports":false}}`
  * F1 Go:Install/Update Tools，impl用于创建接口对应的方法，gopls是语言服务器，dlv调试需要用

## 命令

* go run .
* go doc module func：显示文档
* go fix：从老版本的语法迁移到新版本
* go vet：检查语法错误
* go clean
* 编译安装全局命令行工具：go install xxx@latest，会装到$GOPATH/bin中
* 减少编译后的体积：go build -ldflags "-s -w"
* 静态编译：https://github.com/golang/go/issues/26492
* 交叉编译，默认就是静态的：CGO_ENABLED=0 GOOS=windows GOARCH=386 go build
* Win下隐藏命令行窗口：-ldflags "-H windowsgui"

## 变量和类型

* `var i, j int = 1, 2`
  * 类型写在变量名后面
  * 连续多个参数类型相同，可只写最后一个
  * 如果初始化了，可以省略类型
  * 函数内的简化声明：i := 1
  * 同时声明多个不同类型的：var(a=1 换行 b=2)
  * 声明了但未使用的变量会报error，可用_=v解决
* bool int int32 uint uintptr byte float32 float64 string rune代表Unicode码点
* 3 / 2结果为1，3. / 2结果为1.5
* 类型定义：type status bool，两者是不同的类型；类型别名：type Text = string，两者是同一个类型，编译后会去掉
* 类型转换：T(v)
* 常量：const Pi = 3.14
  * iota：一个在const块中每使用一行自动+1的量，如const (a = iota; b; c)则a为0，b为1，c为2
  * 没赋值的会自动用上一条的表达式，如a = 1 << iota; b; c，则b为2，c为4
* 指针：*T、new(T)、nil，无法进行加减运算，T可以是数组
* 结构体
  * 声明类型：type Point struct { ... }
  * 创建实例：Point{1,2}、Point{Y:2}、&Point{}
  * 访问结构体指针的字段也可以用点
  * 组合：type B struct {*A; ...}，A可不写名字则自动命名为A，b可以直接使用A的字段和方法
* 数组
  * var arr [3]int自动初始化为零值、var arr = [3]int{1,2,3}、arr := [3]int{1,2,3}
  * 可以直接输出
  * 大小固定，用[...]时根据字面量自动设定长度
  * 是值语义，传参时会整个复制
* 切片
  * 数组转切片：var s []int = arr[1:4]、s := arr[1:4]。arr必须是左值，无法把一个返回数组的函数直接[:]，必须先声明数组接收
  * 只是描述一段，不会复制。可以往大了切但不能超过底层的最大大小
  * len(s)表示它拥有的元素个数，cap(s)表示从它第一个元素开始数到原数组末尾的个数
  * 只声明不赋值时它==nil，但len(它)是0，Println(它)是[]，也支持append
  * 切片字面量：a := []int{1,2,3} 不用写长度，实际是底层创建临时数组再取切片
  * 创建空切片：a := make([]int, 4) 长度为4，值都为0；make([]int, 0, 5) len为0，cap为5，表面上无元素，实际底层数组有
  * 添加数据：a = append(a,4,5)/append(a,[]int{4,5}...) 如果底层cap够用，就修改底层添加新元素，否则会创建新底层
  * 复制：copy(a,b) 把b对应位置赋给a，超出部分不做处理
  * 删除：a = append(a[:i], a[i+1:]...)
  * 插入：a = append(a[:i], append([]T{x}, a[i:]...)...)
  * 常见错误：for的v在循环时地址不变，如果循环append它的&或[:]，添加的是重复的对象，或调用接收者为*T的方法时也要注意
* 映射
  * m := make(map[string]int) 必须初始化，用var声明的是nil
  * m := map[string]int {"a":1, ...}
  * m["a"] = 1 可直接对不存在的key赋值
  * elem, ok := m[key] 取值当key不存在时ok为false，elem是对应类型的零值
  * delete(m, key)
* 运算符优先级：暂时不学

### 字符串和格式化

* 零值是""而非nil
* 控制台输出：fmt.Print(对象)、fmt.Println(对象)、fmt.Printf("模式", 对象)
* 控制台输入：fmt.Scan(&a, &b) 按空格分隔读取内容、fmt.Scanf("模式", &对象) 类似于C语言的模式
* 格式化为字符串：var s string = fmt.Sprintf("模式", 对象)。从字符串提取内容：fmt.Sscanf("字符串", "模式", &对象)
* 格式化模式
  * %v  默认格式。结构体会调用fmt.Stringer接口中的String()函数，接口会使用实际类型
  * %+v 对于结构体，还输出字段名
  * %#v 相当于Py的repr()
  * %T  类型
  * %%  转义一个百分号
  * %b  二进制
  * %[]v 指定某个索引，从1开始
* 字符串函数
  * Contains、ContainsAny
  * Fields：相当于Split空格再去掉空的。Cut：把字符串去掉sep分成两部分
  * Join([], sep)
  * ReplaceAll
  * Trim、TrimSpace
* var b strings.Builder; fmt.Fprint(&b, ...); b.WriteString(); b.String()
* 原始字符串：反引号
* strconv转换
  * Atoi("42")
  * Itoa(42)
  * ParseFloat("3.1415", 64)
  * FormatInt(7, 2)
  * Quote("\n")：相当于Py的repr()
* 正则：var r = regexp.MustCompile("[0-9]+"); r.Find(s); r.MatchString(s)

## 分支和循环

* break和continue支持类似java的标签

```go
if a := 1; a > 2 { }
for i := 0; i < 10; i++ { sum += i }
for sum < 1000 { } // 相当于while
for { } // 无限循环
for i,v := range arr // i是下标，v是值的副本，遍历map时是k和v；可用_忽略下标，可不写,v忽略值
switch i := 1; i+1 { // 无条件的switch和switch true一样，case可用条件表达式，代替一长串ifelse
  case 1+1: ... // 无需break但也支持，顺序执行指明fallthrough；case后的可以是表达式；并列的case用逗号
}
```

## 函数

* defer语句将函数的调用推迟到外层函数返回后执行，若有多个则按FILO调用，参数的求值按声明而非执行时决定，若闭包了返回值变量能修改它
* 返回值可以命名，相当于在一开始声明了变量，最后用无参return
* 不定长参数：`params ...int`，使用时支持展开切片`slice.../arr[:]...`
* 不支持默认参数，不支持重载

```go
func add(x int, y int) int { return x + y }
func swap(x, y string) (string, string) { return y, x } // 多值返回，调用者不需要的用_丢弃
// 具有值语义，可以作为参数和返回值，可以赋给变量，支持闭包；以下也可以直接return func...
func compute(fn func(int, int) int) func(int) int { f := func(n int) int { return fn(1,n) }; return f }
// 泛型，comparable预定义表示支持==和!=，这样才能作为map的key；type Number interface{int|float32}限定v的类型，也可直接写里面，用~int表示底层是int的都行；不支持泛型方法
func SumNumbers[K comparable/any, V Number](m map[K]V) V { }
```

## 方法和接口

* 在func和函数名之间加”接收者“就定义了方法，同名函数可以有不同类型的接收者
* 接收者类型用*T传递对象的引用
* 为了方便，T与*T类型的对象能自动转换，调用对方类型的接收者的方法；但接口和map中的元素是严格的
* 接口表示函数无需func关键字，还可以表示字段，无需var

```go
func (p *Point) X() int { return p.X }; p := Point{1,2}; p.X() // 方法必须和Point的定义在同一个文件中
type P interface { X() int }; var pp P = &p; pp.F() // 其中Point对F的实现在另一个文件中
var pp P = nil; pp.F() // 运行时错误
var p *Point = nil; pp := p; pp.F() // 能进到F()中，且pp != nil，但F()中的p == nil
var a any = 1; b,ok := a.(int) // 类型断言a保存了int
switch b := a.(type) {case int: ...} // 诡异的语法
```

## 错误处理

* panic("信息")：调用后终止当前流程，开始执行defer了的函数，如果没有recover就再往上执行
* recover：必须先声明一个defer func，用if err := recover(); err != nil {}捕获之后可能发生的错误，再调用会panic的函数。类似于goto的错误处理
* error：一般用函数的多返回值，return errors.New("信息")或fmt.ErrorF()，调用者用if err != nil表示发生了错误。其中ErrorF()是返回一个error而非输出到stderr
* 自定义错误：MyError结构体实现error接口的Error()，函数返回error时返回&MyError{}

## 模块

* 大写的函数是导出名，小写的是未导出的
* import的是模块名/目录或分支，使用时是包名.函数名，与文件名无关；一般包名和基本目录名相同避免迷惑，一个目录只能有一个包名
* 用`p "..."`创建包名的别名，用`"./"`指定相对路径，用`_ "..."`避免自动删除未使用的包
* 每个源文件都能且只能有一个init()函数，自动执行，优先级很高
* go mod init example.com/hello，之后build出的就是hello.exe
* go mod tidy：自动把import了包写入go.mod，还会清除未使用的
* go get：下载mod中列出的包。-u：更新全部包
* go mod vendor
* 没有办法删除，没有办法列出已安装的
* 注释推荐写在函数上一行，以函数名开头，一个完整的句子带有句号；一个包的注释写在package xxx的前面几行且就以它开头；注释中的缩进会被当作预格式化块

## 文件和IO

* 以下省略err和defer f.Close()
* ioutil：不应使用

```go
// 只读
f := os.Open("文件名")
bytes := io.ReadAll(f) // 全部读
scanner := bufio.NewScanner(f/os.Stdin); for scanner.Scan() {line:=scanner.Text()}; if err:=scanner.Err();err!=nil // 按行读，错误处理不在循环中

// 写
f := os.Create("文件名") // 如已存在会清空
os.OpenFile("access.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644) // 追加
w = bufio.NewWriter(f) // 启用缓冲
w.WriteString("内容")/Write(bytes)
fmt.Fprintf/Fprintln(w, "内容")
w.Flush() // 必须使用

// 直接全部读和写
bytes := os.ReadFile("文件名")
os.WriteFile("文件名", []byte("内容"), 0666)
```

## 并发

* go run -race检测竞态，需要启用cgo，资源消耗大
* goroutine：在调用函数前加go
* channel
  * c := make(chan int)，用`<-chan int`类型表示只读通道
  * 第二个参数指定缓冲大小，默认为1，满了发送方会阻塞，空了接收方会阻塞。有一定检测死锁的能力
  * ch <- v 将v发送给ch。close(ch)关闭，只有发送方能关闭，一般情况下无需关闭
  * v := <-ch 从ch取出值，第二个返回值ok为false时表示信道已关闭
  * for v:= range c {}能不断从ch获取值，直到它关闭
* select
  * 位置上和无条件switch一样，分支用case v:=<-ch
  * 阻塞直到任意一个分支可以执行，如果有多个可执行就任意一个，如果都没准备好就执行default（如果有）
* 互斥：sync.Mutex、Lock、Unlock、WaitGroup、RWMutex、Once
* 对基元类型原子操作：sync/atomic

## 命令行

* 一般工作区根目录的main.go用package main再定义func main()作为入口点
* 命令行参数用os.Args获得，0号是程序自己
* b := flag.Bool("参数名", 默认值, 帮助信息); flag.Parse(); if *b:...
* https://github.com/spf13/cobra

## [标准库](https://pkg.go.dev/std)

### math/rand

* rand.Seed(time.Now().Unix())
* rand.Intn(10) 在[0,10)
* rand.Uint32()、rand.Float32()

### time

* time.Now()
* time.Date(年,月,日,时,分,秒,纳秒,time.UTC); d.Date()、d.Clock()
* d.Format("模板格式如2000/01/01")，与之相反的是time.Parse("模板", "实际时间")
* time.Sleep(100*time.Millisecond)
* time.After()：可用在select中作为超时
* time.Tick()：每隔一段时间就往通道中放东西，大概相当于循环的After
  * 限制每秒执行10次：throttle:=time.Tick(time.Second/10); <-throttle。或for range time.Tick()

### encoding/json

* bytes,err := json.Marshal(对象)，只编码导出成员。MarshalIndent(data, "", "\t") 缩进
* var m Message; err := json.Unmarshal(bytes, &m)。如果不知道结构可以设为map[string]any
* 自定义JSON键名：使用struct的Tag，在字段后加反引号json:"自定义名"反引号，如果用"-"则忽略

### log

* 没必要用Println()，因为各条都是分开的，默认就会换行
* log.SetPrefix("greetings: ")
* log.SetFlags(0)：默认会输出日期和时间，此调用会禁用
* log.Fatal(err)：相当于log.Print()再os.Exit(1)

### os

* os.Stdout
* os.Exit()
* os.Getenv()
* os/exec：cmd:=exec.Command("命令名", 参数1, 参数2); cmd.CombinedOutput()

### crypto

* crypto/md5：sum:=md5.Sum([]byte("内容")); hex.EncodeToString(sum[:])
* crypto/rand 安全的随机数：buf:=make([]byte, 16); rand.Read(buf)
* base64.StdEncoding.EncodeToString(bytes)

### path/filepath

* filepath.Dir()

### net

* net/netip 1.18新增
* net/http
  * resp, err := http.Get(url); defer resp.Body.Close(); body, err := io.ReadAll(resp.Body)
* TODO: 发json、gzip、cookie

## 测试

* 文件以_test.go结尾
* 测试函数以Test为前缀，接受(t *testing.T)参数
* 如果调用了t.Error、t.Fail等，则认为失败
* go test命令

## 错误记录

* `expected 'IDENT', found xxx`：看是不是标识符和类型写反了

## TODO

* https://go.dev/blog/go1.13-errors
* https://github.com/jincheng9/golang-cheat-sheet-cn#%E6%8E%A5%E5%8F%A3
* https://github.com/golang/go/wiki/InterfaceSlice
* https://github.com/golang/go/wiki/CodeReviewComments#error-strings
* https://go-zh.org/doc/faq 看到“为什么我的nil错误值不等于nil？”
* https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/04.5.md
* https://go-zh.org/doc/ 实效 Go 编程（对照新版看）
* https://github.com/jincheng9/go-tutorial
* https://golang.google.cn/doc/

* https://github.com/golang/go/wiki/Articles
* https://github.com/golang/go/wiki/LearnConcurrency
* https://github.com/golang/go/wiki/GoForCPPProgrammers
* reflect https://blog.go-zh.org/laws-of-reflection
* https://gfw.go101.org/article/constants-and-variables.html 原生中文，内容较多
* https://github.com/golang/go/wiki/Learn
* https://leanpub.com/GoNotebook/read
* https://www.golang-book.com/books/intro
* https://gifm.dev/screencasts/
* https://gobyexample.com/ https://gobyexample-cn.github.io/
* https://yourbasic.org/golang/
* https://www.programming-books.io/essential/go/
* https://programming.guide/go/
* https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md 原生中文
* https://gowebexamples.com/

### 库

* https://github.com/gin-gonic/gin https://gin-gonic.com/zh-cn/docs/ https://golang.google.cn/doc/tutorial/web-service-gin
* https://github.com/PuerkitoBio/goquery 解析HTML
* https://github.com/thoas/go-funk 函数式
* https://github.com/traefik/yaegi eval和repl

### sql

* https://github.com/golang/go/wiki/SQLInterface
* http://go-database-sql.org/
* https://github.com/golang/go/wiki/SQLDrivers
* https://github.com/go-gorm/gorm
