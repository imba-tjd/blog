---
title: GoLang
---

## 安装

* apt install golang-go; go version。但apt的版本低，也可用go install golang.org/dl/go1.18@latest; go1.18 download; go1.18 version
* gccgo：使用起来与其它gcc一样，编译结果小很多，但不够新
* docker映像：默认是debian的，没有slim版；精简版golang:alpine。之后可用`-v $PWD:/v -w /v`挂载当前目录进去
* 国内镜像：go env -w GOPROXY=https://goproxy.cn,direct，还有goproxy.io，mirrors.aliyun.com/goproxy，goproxy.bj.bcebos.com
* https://github.com/x-motemen/gore REPL环境
* golangci-lint：多个lint的集合，用于CI，提供GitHub Actions
* VSC
  * 不自动删除未使用的import语句，但手动格式化时也无法删除了：`"[go]":{"editor.codeActionsOnSave":{"source.organizeImports":false}}`
  * F1 Go:Install/Update Tools。gopls是LS，dlv用于调试（不支持Win的x86但支持linux的）。可选的：staticcheck用于lint（gopls默认已有一些lint，又有格式化，所以不装它也没事），impl用于创建接口对应的方法。不要装outline、golint、dlv-dap
  * `"gopls":{"ui.semanticTokens":true}`

## 命令

* go run .
* go doc module func：显示文档
* go fix：从老版本的语法迁移到新版本
* go vet：检查语法错误
* go clean
* 编译安装全局命令行工具：go install xxx@latest
* 减少编译后的体积：go build -ldflags "-s -w" -trimpath
* 静态编译：https://github.com/golang/go/issues/26492
* 交叉编译，默认就是静态的：CGO_ENABLED=0 GOOS=windows GOARCH=386 go build
* Win下隐藏命令行窗口：-ldflags "-H windowsgui"

## 变量和类型

* bool int int32 uint uintptr byte float32 float64 string rune代表Unicode码点
* `var i, j int = 1, 2`
  * 类型写在变量名后面
  * 连续多个参数类型相同，可只写最后一个
  * 如果初始化了，可以省略类型
  * 函数内的简化声明：i := 1。当本作用域内i存在时相当于i=1，但当x,y:=...且有一个本作用域内不存在时就会shadow全部变量
  * 同时声明多个不同类型的：var(a=1 换行 b=2)
  * 声明了但未使用的变量会报error，可用_=v解决
* 运算符
  * 3 / 2结果为1，3. / 2结果为1.5
  * ++仅为后缀且不是表达式
  * 位运算符：&^位清除、一元^按位补足
  * 运算符优先级：暂时不学
* 作用域：universal（true false nil所在）、package（同一包的全局变量和函数属于同一此作用域）、file（import的只在本文件中有效）、其他(嵌套)作用域
* 类型定义：type status bool，两者是不同的类型，可以在status上定义方法；类型别名：type Text = string，两者是同一个类型，编译后会去掉
  * 从已有类型定义新类型不是继承：它们具有相同的底层类型。新类型与原类型之间无法隐式转换（但允许与原类型字面量之间运算和被赋值），两者的方法也不共享（不同的方法集），类型断言也不兼容
* 类型转换：T(v)。不同类型对象之间运算前必须显式转换
* 整数字面量：0b二进制，0o八进制，支持下划线分隔。本身是无类型的
* 常量：const Pi = 3.14
  * iota：一个在const块中每使用一行自动+1的量，如const (a = iota; b; c)则a为0，b为1，c为2
  * 没赋值的会自动用上一条的表达式，如a = 1 << iota; b; c，则b为2，c为4
  * 纯编译期，允许未使用，不限定类型的常量对象和字面量同样无类型
* 指针：*T、new(T)、nil。无法进行加减运算，T可以是数组，能返回指向本地变量的指针
* 结构体
  * 声明类型：type Point struct { ... } 字段一行一个无需逗号分号var
  * 创建实例：var p = Point{1,2}、Point{Y:2}、&Point{}
  * 访问结构体指针的字段也可以用点
  * 组合/嵌套另一个结构体
    * type B struct {A; ...}，也可以是*A，可以不命名
    * b可以直接使用A的字段和方法（重名时才用b.A.x），A的方法也能算进B实现的接口，这称作提升
    * 没有dynamic dispatch，被嵌套的结构体不知道外层的事：加入A存在F1和F2，F1会调用F2，B存在F2，则b.F1()时调用的是A上的F2
  * 转换和比较：字段的 名字 类型 顺序 必须相同。匿名结构体可以不强转就赋值
* 数组
  * var arr [3]int自动初始化为零值、var arr = [3]int{1,2,3}、arr := [3]int{1,2,3}；{2:1}->{0,0,1}
  * 可以直接输出
  * 大小固定，用[...]时根据字面量自动设定长度，此处的点是真的三个点
  * 是值语义，传参时会整个复制；可以直接==判断相等，如果长度不等会在编译期报错
  * 解包：在对象后加...，此处的点是真的三个点
* 切片
  * 数组转切片：var s []int = arr[1:4]、s := arr[:]。arr必须是左值，无法把一个返回数组的函数调用后直接[:]变成切片，必须先接收
  * 只是描述一段，不会复制。可以往大了切但不能超过底层的最大大小
  * len(s)表示它拥有的元素个数，cap(s)表示从它第一个元素开始数到原数组末尾的个数
  * 可理解为struct{arrp,len,cap}，取[:]修改len和cap会返回一个新的本体，传参时也是值传递本体
  * 只声明不赋值时它==nil，但len(它)是0，Println(它)是[]，也支持append
  * 切片字面量：a := []int{1,2,3} 不用写长度，实际是底层创建临时数组再取切片
  * 创建空切片：a := make([]int, 4) 长度为4，值都为0；make([]int, 0, 5) len为0，cap为5，表面上无元素，实际底层数组有
  * 添加数据：a = append(a,4,5)/append(a,[]int{4,5}...) 如果底层cap够用，就修改底层添加新元素，否则会创建新底层
  * 复制：copy(a,b) 把b对应位置赋给a，两者的超出部分都不做处理，返回值为处理的数量
  * 删除：a = append(a[:i], a[i+1:]...)
  * 插入：a = append(a[:i], append([]T{x}, a[i:]...)...)
  * 常见错误：for的v在循环时地址不变，如果循环append它的&或[:]，添加的是重复的对象，或调用接收者为*T的方法时也要注意
  * 无法直接把 []T 赋值给 []any，必须复制一遍
  * 升序排序：sort.Slice(a, func(i,j int) bool {return a[i]<a[j]})。因为没有泛型，用了闭包和某些内部魔法
* 映射
  * m := make(map[string]int)，第二个参数为初始大小。必须初始化，否则nil无法读写
  * m := map[string]int {"a":1, ...}
  * m["a"] = 1 可直接对不存在的key赋值，可以++
  * elem, ok := m[key] 取值当key不存在时ok为false，elem是对应类型的零值
  * delete(m, key)
  * 模拟set：推荐用map[T]bool，当不存在时就返回false。另一种选择是map[T]struct{}，加上初始化就再要一个{}，优点是不占空间，缺点是不直观且必须用ok来判断
  * 故意使得每次for range遍历的顺序都不一样

### 字符串和格式化

* 零值是""而非nil
* 内部用U8，切片、取索引、len()都是按byte处理，应先转成[]rune(s)。但for range会自动按rune遍历，且序号会自动跳过码点中间的
* 控制台输出：fmt.Print(对象)、fmt.Println(对象)、fmt.Printf("模式", 对象)
* 控制台输入：fmt.Scan(&a, &b) 按空格分隔读取内容、fmt.Scanf("模式", &对象) 类似于C语言的模式
* 格式化为字符串：var s string = fmt.Sprintf("模式", 对象)。从字符串提取内容：fmt.Sscanf("字符串", "模式", &对象)
* 格式化模式
  * %v  默认格式。结构体会调用fmt.Stringer接口中的String()函数，接口会使用实际类型
  * %+v 对于结构体，还输出字段名
  * %#v 相当于Py的repr()
  * %T  类型
  * %%  转义一个百分号
  * %b  二进制
  * %c  字符，而%v对于字符会输出数字
  * %[]v 指定某个索引，从1开始
* strings
  * Contains、ContainsAny
  * Fields：相当于Split空格再去掉空的。Cut：把字符串去掉sep分成两部分
  * Join([], sep)
  * ReplaceAll
  * Trim、TrimSpace、TrimPrefix
  * (Last)Index 没有“从某一位置继续往后找”的功能
* var b strings.Builder; fmt.Fprint(&b, ...); b.WriteString(); b.String()
* 原始字符串：反引号
* strconv转换
  * Atoi("42")
  * Itoa(42)
  * ParseFloat("3.1415", 64)
  * strconv.formatInt(num, base) 把数字转换成其他进制对应的字符串
  * Quote("\n") -> `"\n"`：相当于Py的repr()
* 正则
  * var r = regexp.MustCompile("[0-9]+") Must表示正则出错时panic而非返回err
  * r.Find(All)?(String)?(Submatch)?(Index)? 不加All则取第一个，不加String则参数为[]byte，加Submatch则单个匹配就返回捕获组字符串slice其中0为整体，加Index则返回开头和结尾的索引位置
  * r.MatchString() 返回bool
  * r.ReplaceAllString() 支持用$n引用捕获组，Literal版本不具有此功能，Func版本传回调函数如strings.ToLower
  * POSIX版：不要用

## 分支和循环

* break和continue支持类似java的标签
* 不支持“truthy”

```go
if a := 1; a > 2 { } // a在else中也可使用，会shadow a
for i := 0; i < 10; i++ { sum += i } // 会shadow i
for sum < 1000 { } // 相当于while
for { } // 无限循环
for i,v := range arr // i是下标，v是值的副本，遍历map时是k和v，遍历channel仅有一个值；可用_忽略下标，可不写,v忽略值
switch i := 1; i+1 { // 无条件的switch和switch true一样，case可用条件表达式，代替一长串ifelse
  case 1+1,3: ... // 无需break但也支持，顺序执行指明fallthrough；case后的可以是表达式；并列的case用逗号
}
```

## 函数

* defer语句将函数的调用推迟到外层函数返回后执行，若有多个则按FILO调用，参数的求值按声明而非执行时决定；若闭包了命名返回值，能修改它
* 返回值可以命名，相当于在一开始声明了变量，最后用无参return
* 变长参数：`params ...int`，使用时支持展开切片`slice.../arr[:]...`
* 不支持默认参数，不支持重载

```go
func add(x int, y int) int { return x + y }
func swap(x, y string) (string, string) { return y, x } // 多值返回，调用者不需要的用_丢弃
// 具有值语义，可以作为参数和返回值，可以赋给变量，支持闭包；以下也可以直接return func...
func compute(fn func(int, int) int) func(int) int { f := func(n int) int { return fn(1,n) }; return f }

// 泛型，comparable预定义表示支持==和!=，这样才能作为map的key；type Number interface{int|float32}限定v的类型，也可直接inline写，用~int表示底层是int的都行；不支持泛型方法；也支持泛型结构体：type S[t any] struct{}
func SumNumbers[K comparable/any, V Number](m map[K]V) V { }
```

## 方法

* 在func和函数名之间加“接收者”，同名函数可以有不同类型的接收者
* 接收者可以为*T，之后调用t.F()时应当把t看作引用类型，即使t不是指针对象。因为为了方便，值对象会自动转换为指针。甚至从C角度看还能解引用改变t本身，但不应这样做。但map[]T取出来的临时值对象却无法直接调用F()，而slice的可以，无法理解。另外如果接口所需函数为指针接收者，无法直接把值对象赋给接口
* 为了方便，指针对象可以直接用.访问值对象的字段和方法，代替C的->
* nil对象能正常调用*T接收者的方法
* 把`对象.方法`赋给函数变量会保留接收者对象，类似于委托

```go
func (p *Point) X() int { return p.X }; // 必须和Point的定义在同一个文件中
p := Point{1,2};
p.X()
```

## 接口

* 定义所包含的函数无需func关键字，也无需接收者
* 赋值给接口的只能是对象，不能是匿名方法
* 指针对象的函数集也包含值对象的，因此永远可赋值给接口；而值对象的函数集只有值接收者的，若一函数的接收者是*T，值对象无法直接赋给接口。或者从另一角度看，如果函数的接收者是T，那对象无论是指针还是值都能赋值给接口
* 在底层可看做`(*类型,*值)`，只有两者都为nil，接口才为nil
  * I i; return i与直接return nil是不同的，前者在使用者看来永远!=nil。但error除外
  * 值为nil的接口调用指针接收者方法，方法内的p==nil
  * 调用完全为nil的接口会运行时panic
* 单方法接口的命名规则：Read方法对应的接口名是Reader
* 可以组合：ReadWriter {Reader; Writer}
* 函数设计上，尽量接受接口（需要避免堆分配时除外），返回具体类型（error或需要返回不同类型实例时除外）
* 接口指针用得极少
* 隐式实现，结构体无需声明自己实现了某接口，但此方法必须在同一个package中。动态语言对象调用函数无法在编译期判断函数是否存在。java如果换一种实现则接口要全改（除非新实现也实现了同样的接口，如日志门面，但第三方包一般做不到）。函数指针又难以组合。Go这种方式方便了调用者更换实现，以及传参给回调函数时自己的结构体不用改动。缺点是单纯看结构体看不出它实现了哪些接口，生成文档应该可以看到本包中定义的，但要用到前面说的优势必须由调用者定义一遍接口
* 若想传函数给接口对象type I interface{F()}，需要先创建一个签名相同的自定义函数类型type Hnd/FAdapter func()，因为函数是一等对象，可以在它上面实现方法func (f Hnd) F(){f()}，此方法必须满足接口，又在方法内直接调用函数本体，使用时用Hnd(func(){...})显式把匿名函数转换成Hnd类型。适用于调用库中单方法接口参数的函数

```go
type I interface { X() int };
i := &p
i.X()

// 类型断言：接口保存了哪种类型，一般用于检测某类型是否具有另一效率更高的接口。如果完全未知，要用反射
var a any = 1; b,ok := a.(int)
switch a := a.(type) {case int: ...; case nil} // 左边一般用同名变量shadow右边的；如果一个case有多项，新变量的类型是any
```

## 错误处理

* error接口：一般用函数的多返回值，return errors.New("信息")或fmt.ErrorF()。后者是返回一个error而非输出到stderr
* 调用者用if err != nil表示发生了错误，err.Error()获得包含的信息
* 错误信息推荐首字母不大写
* 自定义错误：ErrXX结构体实现error接口的`Error() string`，函数返回error时返回&ErrXX{}。不太推荐直接从string创建自定义错误类型
* 哨兵错误：在包中公开的预定义的错误，以便使用者检查if err == pkg.ErrXX，一般用于不可恢复的
* 错误包装：err可以包含另一个err。一般用fmt.ErrorF("新信息: %W", err)创建，其中%W必须在最后。对于自定义错误一般用{msg, err}这样的结构体，并实现Unwrap()方法返回err。errors.Unwrap()返回内部的一般不直接用，errors.Is()和errors.As()能一层层判断，对应==和类型断言，如果存在无法比较的字段如切片要实现Is(target error) bool。一个函数中多次重复相同包装时可用命名返回值加defer修改闭包变量
* panic("信息")：调用后终止当前流程，开始执行defer了的函数，如果没有recover就再往上执行
* recover()：必须先声明一个defer func，用if err := recover(); err != nil {}捕获之后可能发生的错误，再调用会panic的函数。类似于goto的错误处理
* 设计上，不应让panic离开库的公开API，一般要转换成error

## 模块

* import的是模块名，可选/目录名，使用时是包名.函数名，与模块名和文件名无关；一般包名和本层目录名相同，且一个目录只能有一个包名；install产生的可执行文件就是模块名
* 大写的是导出的。internal包名：只有同级下的模块能访问
* 大版本更新：需要手动在模块名后加/v2，不能自动更新；作为开发者，新建一个v2的分支，修改模块名加上/v2
* 用`p "..."`创建包名的别名，用`"./"`指定相对路径但一般不用，用`_ "..."`避免未使用的包报错或导入仅有副作用的包，用`. "..."`把包内对象导入当前作用域
* 每个源文件都能有一个init()函数，自动执行，优先级很高，但最好每个包只有一个
* go mod init example.com/hello，之后build出的就是hello.exe
* go mod tidy：把import了包写入go.mod，还会清除未使用的，再go get不带-u
* go get -u：下载并更新mod中列出的包，包括间接依赖。若不用-u，则仅下载mod中的指定版本，当包已存在时，即使有更新，也没有任何变化，tidy同理。手动删除本mod中的包及其依赖用@none
* go mod vendor
* 使用未发布的本地模块：先普通require，版本号随便写但必须有，再加一条`replace 前面的内容=>本地路径`；1.18后可用workspace。使用fork的：replace，模块名后加/user
* 自动生成文档：注释写在函数上一行，以函数名开头，一个完整的句子带有句号；一个包的注释写在package xxx的前面几行且就以它开头；注释中的缩进会被当作预格式化块
* 现在的GOPATH是%UserProfile%\go，pkg\mod里放下载的依赖缓存，bin里放install了的命令，没有命令清理或列出它们。GOROOT不是环境变量，是%ProgramFiles%\Go即本体。另外会在%LocalAppData%\go-build里放构建缓存
* 模块的发布：上传到GitHub上，就自动发布了，pkg.go.dev会自动检测含有go.mod的仓库。模块名不必以github.com开头，不过还是要避免重名
* 编译期禁止循环引用，若A引用了B，B无法直接或间接引用A。一种解决办法是把两者合进一个包

## 文件和IO

* 以下省略err和defer f.Close()
* ioutil：不应使用
* bytes.Buffer：相当于byte流，初始化为nil但可直接b.Write()，读取用b.String()

```go
// 只读
f := os.Open("文件名")
[]byte := io.ReadAll(f) // 全部读
scanner := bufio.NewScanner(f/os.Stdin); for scanner.Scan() {line:=scanner.Text()}; if err:=scanner.Err();err!=nil // 按行读，错误处理不在循环中。另一种按行读的方式是NewReader().ReadString('\n')

// 写
f := os.Create("文件名") // 如已存在会清空
os.OpenFile("access.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644) // 追加
w = bufio.NewWriter(f) // 启用缓冲
w.WriteString("内容")/Write([]byte)
fmt.Fprintf/Fprintln(w, "内容")
w.Flush() // 必须使用

// 直接全部读和写
[]byte := os.ReadFile("文件名")
os.WriteFile("文件名", []byte("内容"), 0666)

// path/filepath
filepath.Dir()
os.Rename() // 也用于移动，dest必须要写完整，不能用./
```

## 并发

* go run -race检测竞态，需要启用cgo，资源消耗大
* goroutine：在调用函数前加go
* channel
  * c := make(chan int)，用`<-chan int`类型表示只读通道
  * 第二个参数指定缓冲大小，默认为1，满了发送方会阻塞，空了接收方会阻塞。有一定检测死锁的能力
  * ch <- v 将v发送给ch。close(ch)关闭，只有发送方能关闭，一般情况下无需关闭
  * v := <-ch 从ch取出值，第二个返回值ok为false时表示信道已关闭
  * for v:= range c {}能不断从ch获取值，直到它关闭
* select
  * 位置上和无条件switch一样，分支用case v:=<-ch
  * 阻塞直到任意一个分支可以执行，如果有多个可执行就任意一个，如果都没准备好就执行default（如果有）
* 互斥：sync.Mutex（零值可用，m.Lock()/Unlock()）、WaitGroup、RWMutex、Once
* 对基元类型原子操作：sync/atomic

## 命令行

* 一般工作区根目录的main.go用package main再定义func main()作为入口点，二进制名就是模块名。多二进制：cmd目录下多个目录再main.go
* 命令行参数用os.Args获得，0号是程序自己
* b := flag.Bool("参数名", 默认值, 帮助信息); flag.Parse(); if *b:...
* https://github.com/spf13/cobra

## [标准库](https://pkg.go.dev/std)

### math/rand

* rand.Seed(time.Now().Unix())
* rand.Intn(10) 在[0,10)
* rand.Uint32()、rand.Float32()

### time

* time.Now()
* time.Date(年,月,日,时,分,秒,纳秒,time.UTC); d.Date()、d.Clock()
* d.Format("模板格式如2000/01/01")，与之相反的是time.Parse("模板", "实际时间")
* time.Sleep(100*time.Millisecond)
* time.After()：可用在select中作为超时
* time.Tick()：每隔一段时间就往通道中放东西，大概相当于循环的After
  * 限制每秒执行10次：throttle:=time.Tick(time.Second/10); <-throttle。或for range time.Tick()

### encoding/json

* byte[],err := json.Marshal(对象)，只编码导出成员。MarshalIndent(data, "", "\t") 缩进
* var m Message; err := json.Unmarshal(byte[], &m)。如果不知道结构可以设为map[string]any
* 自定义JSON键名：使用struct的Tag，在字段后加`反引号json:"自定义名"反引号`，用"-"表示忽略

### log

* 没必要用Println()，因为各条都是分开的，默认就会换行
* log.SetPrefix("greetings: ")
* log.SetFlags(0)：默认会输出日期和时间，此调用会禁用
* log.Fatal(err)：相当于log.Print()再os.Exit(1)

### os

* os.Stdout
* os.Exit()
* os.Getenv()
* os/exec
  * cmd := exec.Command("命令名", 参数1, 参数2);
  * cmd.CombinedOutput() 运行并等待退出并获得所有输出
  * cmd.Run() 运行并等待退出
  * cmd.Start() 运行但不等待

### crypto

* crypto/md5：sum:=md5.Sum([]byte("内容")); hex.EncodeToString(sum[:])
* crypto/rand 安全的随机数：buf:=make([]byte, 16); rand.Read(buf)
* base64.StdEncoding.EncodeToString([]byte)

### net

* net/netip 1.18新增
* net/http
  * res, err := http.Get(url)
  * body, err := io.ReadAll(res.Body); if res.StatusCode != 200 {...}; string(body)
  * res.Body.Close()
  * 会自动30x重定向
* TODO: 发json、gzip、cookie

### embed

* 编译时嵌入文件内容
* //go:embed static/*
* var content embed.FS
* entries, err := content.ReadDir("static")
* for _, f := range entries {}
* http.FileServer(http.FS(content))

## 测试

* 文件以_test.go结尾
* 测试函数以Test为前缀，接受(t *testing.T)参数
* 如果调用了t.Error、t.Fail等，则认为失败
* go test命令

## CGO

```go
/*
int echo(int n) { return n; }  // 或#include<lib.c>
*/
import "C" // 这一句与上面的不能有空行
C.echo()

/*
#cgo CFLAGS: -I.  // 头文件目录
#cgo LDFLAGS: -Lpkg -llib  // so库所在目录及库名，必须先自己手动编译了
#include <lib.h>
*/
import "C"

import "syscall"
handle := MustLoadDLL("lib.dll")
defer syscall.Release(handle)
proc := syscall.MustFindProc("fun")
proc.Call(可变参数)

handle, err := syscall.LoadLibrary("lib.dll")
defer syscall.FreeLibrary(handle)
proc, err := syscall.GetProcAddress(handle, "fun")
r, _, _ := syscall.SyscallN(proc, 可变参数)
```

## 错误记录

* `expected 'IDENT', found xxx`：看是不是标识符和类型写反了

## [Gin](https://gin-gonic.com/zh-cn/docs/)

* 构建时加-tags=nomsgpack
* 所有graceful重启或停止的库都不维护了
* 内置BasicAuth中间件，还有个gin-contrib组织存放其它中间件包括cache session cors gzip
* 当在中间件或handler中启动新的Goroutine时，不能直接用原来的Context，要c.Copy()一下，且只读
* 路由组/公共前缀：v1 := r.Group("/v1"); v1.GET(...)
* 文档中有处理cookie的方法，略
* c.DataFromReader()：直接从reader读取二进制数据
* 外部重定向：c.Redirect(302, "新url")，内部重定向：修改c.Request.URL.Path后r.HandleContext(c)

```go
import "github.com/gin-gonic/gin"
r := gin.Default() // 默认启用了日志和Recovery中间件
r.GET("/ping", func(c *gin.Context) {
  c.PureJSON(200, gin.H{
    "message": "pong",
  })
})
r.GET("/user/:name", func(c *gin.Context) { // 会匹配/user/abc，不会匹配/user/abc/。还有个星号一般用于可选部分
  user := c.Param("name") // 查询参数：c.Query("k")、c.DefaultQuery("k",默认值)、c.PostForm
  c.String(200, "Hello %s", name)
})
r.POST("/login", func(c *gin.Context) {
  var data Login // 一个struct，必须在对应字段后加上`json:"xxx"或form/header/uri binding:"required"或"-"`，更多验证略
  if err := c.ShouldBindJSON(&data); err != nil { 回复错误信息和return }
  c.BindJSON() BindQuery() BindHeader() BindUri() // 没有Should，失败时自动返回400
  c.Bind() // POST时根据Content-Type自动处理，GET时绑定查询字符串
  ...
})
r.Static("/assets", "./assets")
r.NoRoute(func) // 404页面
r.Run() // 默认监听0.0.0.0:8080，此处可设置
log.Fatal(autotls.Run(r, "example1.com", "example2.com")) // Let's Encrypt，无需上一行的Run()
```

## TODO

* https://golang.google.cn/doc/faq 看到Why is my nil error value not equal to nil?，对照 https://go-zh.org/doc/faq https://www.jianshu.com/p/4b6b8966b314
* https://github.com/golang/go/wiki/CodeReviewComments#in-band-errors
* https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/04.7.md
* https://go-zh.org/doc/effective_go.html 对照 https://golang.google.cn/doc/effective_go
* https://github.com/jincheng9/go-tutorial
* https://www.zhihu.com/column/go-in-action
* https://gowebexamples.com/
* https://zhuanlan.zhihu.com/p/500068696 如何优雅的处理Go的error
* https://zhuanlan.zhihu.com/p/437626980 https://zhuanlan.zhihu.com/p/426368274 https://zhuanlan.zhihu.com/p/403417640 https://zhuanlan.zhihu.com/p/352589023 https://zhuanlan.zhihu.com/p/341945051 https://zhuanlan.zhihu.com/p/450822514 https://zhuanlan.zhihu.com/p/64823525 https://zhuanlan.zhihu.com/p/276052046
* sort.Search
* https://tiancaiamao.gitbooks.io/go-internals/content/zh/02.1.html

* https://www.zhihu.com/column/go-gctt
* https://github.com/golang/go/wiki/Articles
* https://github.com/golang/go/wiki/LearnConcurrency
* https://github.com/golang/go/wiki/GoForCPPProgrammers
* reflect https://blog.go-zh.org/laws-of-reflection reflect.DeepEqual能比较切片
* https://gfw.go101.org/article/constants-and-variables.html 原生中文，内容较多
* https://github.com/golang/go/wiki/Learn
* https://leanpub.com/GoNotebook/read
* https://www.golang-book.com/books/intro
* https://gifm.dev/screencasts/
* https://gobyexample.com/ https://gobyexample-cn.github.io/
* https://yourbasic.org/golang/
* https://www.programming-books.io/essential/go/
* https://programming.guide/go/
* https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md 原生中文
* https://chai2010.cn/advanced-go-programming-book/
* https://github.com/luk4z7/go-concurrency-guide

### 库

* https://github.com/PuerkitoBio/goquery 解析HTML
* https://github.com/traefik/yaegi eval和repl
* 函数式：https://github.com/samber/lo go-funk
* https://github.com/uber-go/zap 日志

### sql

* https://github.com/golang/go/wiki/SQLInterface
* http://go-database-sql.org/
* https://github.com/golang/go/wiki/SQLDrivers
* https://github.com/go-gorm/gorm
* https://golang.google.cn/doc/ 中的 Accessing databases
* sqlc：从SQL语句生成类型安全的interface
* sqlboiler：根据数据库schema自动生成ORM代码

### 程序

* https://github.com/distribworks/dkron 分布式cron，带有web界面
* NSQ、nats.io 消息队列
