---
title: GoLang
---

## 安装

* apt install golang-go; go version
* gccgo：使用起来与其它gcc一样，编译结果小很多
* docker映像：默认是debian的，没有slim版；精简版golang:alpine。之后可用`-v $PWD:/v -w /v`挂载当前目录进去
* SDK不支持x86
* go env -w GOPROXY=https://goproxy.cn,direct，还有goproxy.io，mirrors.aliyun.com/goproxy，goproxy.bj.bcebos.com
* https://mybinder.org/v2/gh/gopherdata/mybinder-go/HEAD

## 命令

* go run .
* go doc module func：显示文档
* go fix：从老版本的语法迁移到新版本
* go vet：检查语法错误
* go clean
* 编译安装全局命令行工具：go install xxx@latest
* 减少编译后的体积：go build -ldflags "-s -w"
* 静态编译：https://github.com/golang/go/issues/26492
* 交叉编译，默认就是静态的：CGO_ENABLED=0 GOOS=windows GOARCH=386 go build
* Win下隐藏命令行窗口：-ldflags "-H windowsgui"

## 语法

```go
package main // main.go
import "fmt"
func main() {
	fmt.Println("Hello world")
}
```

### 字符串和格式化

* s string = fmt.Sprintf("Hi, %v. Welcome!", name)
* %+v 打印包括字段在内的实例的完整信息
* %#v 打印包括字段和限定类型名称在内的实例的完整信息
* %T 打印某个类型的说明，如main函数中的T类型的指针就是*main.T
* 能接受any类型的对象并获得实际的值
* 结构体格式化：实现Stringer接口中的String()函数
* 原始字符串：反引号
* TODO: 字符串格式化 strconv.Itoa

### 变量和类型

* `var i, j int = 1, 2`
  * 类型写在变量名后面
  * 连续多个参数类型相同，可只写最后一个
  * 如果初始化了，可以省略类型
  * 函数内的简化声明：i := 1
  * 同时声明多个不同类型的：var(a=1 换行 b=2)
  * 声明了但未使用的变量会报error，可用_=v解决
* bool int int32 uint uintptr byte float32 float64 string rune代表Unicode码点
* 3 / 2结果为1，3. / 2结果为1.5
* 类型定义：type status bool，两者是不同的类型；类型别名：type Text = string，两者是同一个类型，编译后会去掉
* 类型转换：T(v)
* 常量：const Pi = 3.14。iota：可认为是一个被编译器自动修改的常量，如const (a = iota; b; c)则a为0，b为1，c为2
* 指针：*T、new(T)、nil，无法进行加减运算
* 结构体
  * 声明类型：type Point struct { ... }
  * 创建实例：Point{1,2}、Point{Y:2}、&Point{}
  * 访问结构体指针的字段也可以用点
* 数组
  * var arr [3]int、var arr = [3]int{1,2,3}、arr := [3]int{1,2,3}
  * 可以直接输出
  * 大小固定，用[...]时根据字面量自动设定长度
* 切片
  * var s []int = arr[1:4]、s := arr[1:4]
  * 只是描述一段，不会复制。可以往大了切但不能超过底层的最大大小
  * len(s)表示它拥有的元素个数，cap(s)表示从它第一个元素开始数到原数组末尾的个数
* 动态切片
  * a := []int{1,2,3} 不用写长度，实际是底层创建临时数组再取切片
  * a := make([]int, 4) 长度为4，值都为0；make([]int, 0, 5) len为0，cap为5，表面上无元素，实际底层数组有
  * a = append(a,4,5)/append(a,[]int{4,5}...) 如果底层cap够用，就修改底层添加新元素，否则会创建新底层
  * copy(a,b) 把b对应位置赋给a，超出部分不做处理
* 映射
  * m := make(map[string]int) 必须初始化，用var声明的是nil
  * m := map[string]int {"a":1, ...}
  * m["a"] = 1 可直接对不存在的key赋值
  * elem, ok := m[key] 取值当key不存在时ok为false，elem是对应类型的零值
  * delete(m, key)
* 运算符优先级：暂时不学

### 分支和循环

```go
if a := 1; a > 2 { }
for i := 0; i < 10; i++ { sum += i }
for sum < 1000 { } // 相当于while
for { } // 无限循环
for i,v := range arr // i是下标，v是值的副本，遍历map时是k和v；可用_忽略下标，可不写,v忽略值
switch i := 1; i+1 { // 无条件的switch和switch true一样，case可用条件表达式，代替一长串ifelse
  case 1+1: ... // 无需break，顺序执行指明fallthrough；case后的可以是表达式，同时满足多个用逗号
}
```

### 函数

* defer语句将函数的调用推迟到外层函数返回后执行，若有多个则按FILO调用
* 返回值可以命名，相当于在一开始声明了变量，最后用无参return
* 不定长参数：`params ...int`，使用时可用切片`slice.../arr[:]...`
* 不支持默认参数

```go
func add(x int, y int) int { return x + y }
func swap(x, y string) (string, string) { return y, x } // 多值返回，调用者不需要的用_丢弃
// 具有值语义，可以作为参数和返回值，可以赋给变量，支持闭包；以下也可以直接return func...
func compute(fn func(int, int) int) func(int) int { f := func(n int) int { return fn(1,n) }; return f }
// 泛型，comparable预定义表示支持==和!=，这样才能作为map的key；type Number interface{int|float32}限定v的类型，也可直接写里面
func SumNumbers[K comparable/any, V Number](m map[K]V) V { }
```

### 方法和接口

* 在func和函数名之间加”接收者“就定义了方法，同名函数可以有不同类型的接收者
* 接收者类型用*T传递对象的引用
* 为了方便，T与*T类型的对象能自动转换，调用对方类型的接收者的方法；但接口是严格的
* 接口表示函数无需func关键字，还可以表示字段，无需var

```go
func (p *Point) F() { print(p.X) }; p := {}; p.F() // 方法必须和Point的定义在同一个文件中
type P interface { F() }; var pp P = &p; p.F() // 其中Point对F的实现在另一个文件中
var pp P = nil; pp.F() // 运行时错误
var p *Point = nil; pp := p; pp.F() // 能进到F()中，且pp != nil，但F()中的p == nil
var a any = 1; b,ok := a.(int) // 类型断言a保存了int
switch b := a.(type) {case int: ...} // 诡异的语法
```

### 错误处理

* panic("信息")：调用后终止当前流程，开始执行defer了的函数，如果没有recover就再往上执行
* recover：必须先声明一个defer func，用if err := recover(); err != nil {}捕获之后可能发生的错误，再调用会panic的函数。类似于goto的错误处理
* error：一般用函数的多返回值，return errors.New("信息")，调用者用if err != nil表示发生了错误
* 自定义错误：MyError结构体实现error接口的Error()，函数返回error时返回&MyError{}
* https://go.dev/blog/error-handling-and-go https://opencredo.com/blogs/why-i-dont-like-error-handling-in-go/

### 模块

* go mod init example.com/hello，之后build出的就是hello.exe
* go mod tidy：自动把import了包写入go.mod，还会清除未使用的
* go get：下载mod中列出的包。-u：更新全部包
* go mod vendor
* 大写的函数是导出名，小写的是未导出的
* import的是模块名/目录或分支，使用时是包名.函数名，与文件名无关；一般包名和基本目录名相同避免迷惑，一个目录只能有一个包名
* 用`p "..."`创建包名的别名，用`"./"`指定相对路径，用`_ "..."`避免自动删除未使用的包

### 文件和IO

```go
// TODO: https://www.cnblogs.com/wangqianlove/p/12579994.html
ioutil
file, _ := os.Create("data.txt")
fmt.Fprint(file, "内容")
file.Close()
```

* io.Reader接口，具有Read([]byte)方法
* io.Copy(os.Stdout, &r)

### 网络

TODO

### 并发

* go run -race检测竞态，需要启用cgo，资源消耗大
* 在调用函数前加go
* channel
  * c := make(chan int)，用`<-chan int`类型表示只读通道
  * 第二个参数指定缓冲大小，默认为1，满了发送方会阻塞，空了接收方会阻塞。有一定检测死锁的能力
  * ch <- v 将v发送给ch。close(ch)关闭，只有发送方能关闭，一般情况下无需关闭
  * v := <-ch 从ch取出值，第二个返回值ok为false时表示信道已关闭
  * for v:= range c {}能不断从ch获取值，直到它关闭
* select
  * 位置上和无条件switch一样，分支用case v:=<-ch
  * 阻塞直到任意一个分支可以执行，如果有多个可执行就任意一个，如果都没准备好就执行default（如果有）
* 互斥：sync.Mutex、Lock、Unlock

## [标准库](https://pkg.go.dev/std)

### math/rand

* rand.Seed(time.Now().Unix())
* rand.Intn(10) 在[0,10)
* rand.Uint32()、rand.Float32()

### time

* time.Now()
* time.Sleep(100*time.Millisecond)

### encoding/json

* https://zhuanlan.zhihu.com/p/121037840

## 测试

* 文件以_test.go结尾
* 测试函数以Test为前缀，接受(t *testing.T)参数
* 如果调用了t.Error、t.Fail等，则认为失败
* go test命令

## TODO

* https://golang.google.cn/doc/tutorial/call-module-code https://golang.google.cn/doc/articles/wiki/ https://golang.google.cn/cmd/go/#hdr-Relative_import_paths
* https://appliedgo.net/generics/
* logging httpclient md5
* https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/04.2.md 较老
* https://golangr.com/
* https://blog.go-zh.org/go-slices-usage-and-internals https://go-zh.org/doc/faq https://go-zh.org/ref/mem https://go-zh.org/doc/articles/race_detector.html
* https://go-zh.org/doc/ 代码漫步 实效 Go 编程（对照新版看） https://blog.go-zh.org/laws-of-reflection

* https://golang.google.cn/doc/
* https://gfw.go101.org/article/constants-and-variables.html 原生中文，内容较多
* https://github.com/golang/go/wiki
* https://leanpub.com/GoNotebook/read
* https://www.golang-book.com/books/intro
* https://gifm.dev/screencasts/
* https://gobyexample.com/ https://gobyexample-cn.github.io/
* https://yourbasic.org/golang/
* https://www.programming-books.io/essential/go/
* https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md 原生中文
* https://gowebexamples.com/

### 库

* https://github.com/gin-gonic/gin https://gin-gonic.com/zh-cn/docs/ https://golang.google.cn/doc/tutorial/web-service-gin
* https://github.com/go-gorm/gorm
* https://github.com/spf13/cobra CLI
* https://github.com/thoas/go-funk 函数式
* https://github.com/PuerkitoBio/goquery
* https://github.com/fyne-io/fyne GUI，短期内不考虑学
