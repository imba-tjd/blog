---
title: WinForm
---

## Application

* 默认是多线程单元，因此STAThread不可省
* SetCompatibleTextRenderingDefault：模板默认false，能在支持的时候使用基于GDI的TextRenderer而不是基于GDI+的Graphics，节省内存。虽然感觉没必要，但前者是2.0新增的，且在Forms命名空间下，所以还是留着
* SetDefaultFont()：.NET6新增，全局设置字体
* DoEvents()：处理消息循环
* Restart()

## Control控件的基类

* Name：不是显示的文本，而是对象名；Text才是文本
* Visible、Hide()/Show()
* Enabled
* Font
* ForeColor、BackColor（默认是灰色的比较老气，可设为Window感觉就是白色，但只能影响单个控件）、BackgroundImage
* Tag：用于保存自定义信息，object类型
* Locked：开启后不能在设计器中移动和改变大小
* 对齐：用VS上的工具栏按钮
* 调整控件的Z顺序：BringToFront()、SendToBack()

### Form

* KeyPreview设为true才能接收按键信息。KeyPress主要用于捕获数字字母，不能捕获组合键和F区，无法判断大小写。KeyDown和KeyUp功能更多，如`e.KeyCode==Keys.Escape`
* TopLevel设为false才能指定Parent，自己变成子窗体；如果是单独弹出的窗体，不要设置它，用Owner
* FormBorderStyle：几种都很丑。作为子窗体时用None，Fixed3D有阴影但不让拖大小，ToolWindow系关闭按钮离边框没间隔
* Load事件
* code-behind中的构造函数和继承不能删
* DoubleBuffered：设为false应该有点性能提升
* 子窗体的大小需要在创建时设置为容器的大小

### 布局

* Margin、Padding：后者影响内部控件的文字
* 位置：Location。cs中也可分别设置Left、Top，但不能单独设置Location.X这样的
* 大小：Size。cs中也可分别设置Width、Height。MinimumSize
* Parent：表示本控件的容器控件
* cs中添加控件：this.Controls.Add()
* Dock
  * 可设置为上下左右中“停靠”
  * 可以叠多个控件，因此操作顺序(Z-order)有意义
  * 会自动改变控件大小(AutoSize=true)。例如设为Bottom时左右会充满，且横向拉宽会自动扩大，但高度保持不变；Label除外
  * 与Anchor、Location不兼容；若有重叠，默认设了Anchor的会覆盖在Dock的上面
* Anchor
  * 与那些边的距离保持不变，默认为上和左，从右下角拉大缩小都不会有任何变化，从左上角拉大缩小会跟着移动
  * 当设为左和右时，横向拉宽会自动改变控件的宽度(AutoSize=true)
  * 当左右都不设置时，横向拉宽会自动平均分配多的空间到两边
  * 都不设置时，自动居中
  * 都设置时，控件大小会随着拖拽改变
* Panel
  * 布局容器，里面的空间的Dock以它为准
  * AutoScroll：空间不够时自动显示滚动条
  * 动态添加：p/f.Controls.Add(c); c.BringToFront()。清除：p.Controls.Clear()
* GroupBox：用于逻辑地组合一组控件，如RadioButton和CheckBox
* SplitContainer：带有能调整大小的拆分条（可禁用），也用于划分出两个panel且允许缩放时一个固定大小
* TabControl：选项卡，像右键属性那样的
* TableLayoutPanel：可添加行列，大小可固定、按百分比、用剩下的（最多一个）
* FlowLayoutPanel：一般关注FlowDirection、WrapContents、AutoScroll，内容一般是动态添加的

### Button

* FlatStyle：外观。默认是Standard，改为System后相对更Win7了；Flat一般配合无边框装作列表菜单，默认无背景
* Text：按钮上的文字，设为类似于`&Print`时会添加“访问键快捷方式”，按Alt+P能触发；真的想显示&要写两个。菜单栏按钮也能这样

### TextBox

* 默认只能输入一行，文本换行：Multiline = true
  * 换行符必须要用Environment.NewLine或\r\n，不能只用\n
* SelectAll(); Focus() 一般在验证失败时使用
* MaskedTextBox
  * 输入的内容必须符合掩码，Mask="0000年00月00日"
  * 输入框失去焦点时会发生验证
  * 一般设定AsciiOnly=false
  * e.IsValidInput

### ListBox

* Items.Add(object)/AddRange(object[])，或用DataSource
* 非字符串对象要设置DisplayMember和ValueMember属性，前者是显示给用户看的，后者是SelectedValue属性返回的值；给这俩赋值一般用nameof，指定的必须是公开属性而非字段
* 判断内容是否存在：`listBox1.FindString(xxx) != ListBox.NoMatches;`
* 选中的
  * SelectedItem 对应Items里的对象、SelectedIndex 索引-1代表无选择、SelectedValue 对应ValueMember指定的属性
  * 多选：SelectionMode=SelectionMode.MultiExtended 支持Ctrl Shift来多选，SelectedItems、SelectedIndices，没有SelectedValues

### ListView

* 类似于Explorer，一般设定View属性为Details以及FullRowSelect为true
* 表头：Columns.Add("名称"/new ColumnHeader())，AllowColumnReorder 允许用户拖动表头的列改变列顺序，HeaderStyle 可设为 允许点击 不允许点击 不显示
* 内容：Items.Add(listViewItem)。其中lVI代表一行，设定Text相当于第一列，SubItems.Add()添加其他列，SubItems[0]就是Text
* GridLines：行列之间显示网格线
* 滚动到某一项使它可见：EnsureVisible(ndx)、TopItem
* 查找包含指定文本的项：FindItemWithText()
* 一次性大量更新时暂时挂起：BeginUpdate()
* 没有绑定DataSource的功能
* 不学创建图标
* 选中的
  * 具有ListBox的那些
  * CheckBoxes 在每行开头显示复选框，CheckedItems 选中复选框了的集合
  * 多选：MultiSelect 默认为false
* SelectedIndexChanged：点击同一项也会触发

### DataGridView

* 设置DataSource为对象集合，能自动把公开属性（不含字段）显示出来，且顺序按定义的
* 禁止调整行高：AllowUserToResizeRows=false
* 自动调整列宽：AutoSizeColumnsMode=ColumnHeader/Fill 前者将宽度收缩到列宽，隐含不换行，但可能露出背景；后者列宽均分
* 内容文字居中：RowsDefaultCellStyle.Alignment=DataGridViewContentAlignment.MiddleCenter
* 列头文字居中：除了改ColumnHeadersDefaultCellStyle.Alignment，默认还保留了一个排序功能的位置，导致文字看起来偏左。解决办法是遍历Columns，改SortMode=NotSortable
* 禁止修改：Readonly=true
* 行头列头
  * 默认都有，移动滚动条时会一直显示，点击可以选择本行列，点左上角可以全选
  * 行头默认无值
  * RowHeadersVisible=false 禁用行头

### ComboBox

* 设置选择某一项：SelectedIndex
* 选择的项：SelectedItem
* ComboBoxStyle
  * Simple：文本框允许编辑，并且始终显示选择框
  * DropDown：文本框允许编辑，选择框以下拉框的形式出现
  * DropDownList：文本呈现部分不允许编辑，只能通过下拉箭头打开选择框来选择列表项

### DateTimePicker

* 一个弹出式界面，用户可以选择日期，也可以直接在控件上输入日期时间
* MaxDate和MinDate属性控制允许的日期/时间范围
* Value属性获取值
* Format属性设置格式，预设了Short、Long、Time。自定义略

### OpenFileDialog

* ofd.InitialDirectory
* `ofd.Filter ="jpg或png文件|*.jpg;*.png|所有文件|*.*"`
* if (ofd.ShowDialog() == DialogResult.OK) { using Stream userStream = ofd.OpenFile() }
* ofd.FileName
* FolderBrowserDialog用于选择文件夹

### PictureBox

* Load(path)
* SizeMode：
* Refresh()：原地改变Image而不是重新赋值时需要用
* System.Drawing.Image.FromFile(path)

### Graphic

```c#
pictureBox1.Refresh();
Bitmap bitmap = new Bitmap("path");
bitmap.SetResolution(96,96);

// 双缓冲解决闪烁
Graphics g1 = pictureBox1.CreateGraphics();
BufferedGraphicsContext ctx = BufferedGraphicsManager.Current;
BufferedGraphocs myBuffer = ctx.Allocate(g1, this.DisplayRectangle);
Graphics g = myBuffer.Graphics;
g.DrawImage(bitmap, x, y);
myBuffer.Render();
myBuffer.Dispose();
```

### BackgroundWorker

* 不学Cancel
* IsBusy：是否正在运行
* RunWorkerAsync()：在非UI线程上触发DoWork事件。订阅者可用e.Argument获取参数，设置e.Result作为返回值
* RunWorkerCompleted事件：UI线程。订阅者用e.Result获取值
* ReportProgress()：触发ProgressChanged事件。订阅者检查e.ProgressPercentage。默认不报告进度，需设置WorkerReportsProgress=true

### 数据源和数据绑定

* DataSource
  * 只有ListBox、ComboBox、DataGridView有
  * 能设为arr list IEnumerable DataTable
  * 数据源的值更改后要Refresh()或重新赋值绑定
* BindingSource
  * 用于更改数据源而不更改控件绑定，即一层间接；还支持Type作为设计期支持
  * 先给自身的DataSource赋值，可选设置DataMember=nameof(xxx)，再赋值给控件的DataSource即可
* BindingList
  * 可赋值给DataSource，当控件中的数据值更改后自动同步到集合里，但反过来不一定行
  * 若T实现了INotifyPropertyChanged则能自动更新
  * 不能自动更新，需用ResetItem(ndx)或ResetBindings(false)
* DataBindings
  * 许多控件都有，能对本控件的非集合属性设定一层间接
  * 如textBox1.DataBindings.Add("Text", stu, "Name")，也可以绑定到另一个控件的属性上，如("Text", tb2, "Text")
  * 默认就是双向绑定，数据源更新会立即响应，修改控件的值也会影响数据源，但要丢失焦点时才会更新

### 杂项控件

* ToolStripMenuItem：菜单栏项，ShortcutKeys可设置快捷键
* RichTextBox：用的是rtf，不学
* TaskDialog：.NET5，类似于MessageBox但功能更多
* 所有控件的使用介绍，以及弃用了的：https://docs.microsoft.com/zh-cn/dotnet/desktop/winforms/controls/windows-forms-controls-by-function

## 高DPI

* 不研究太深
* 设计期的VS的DPI会对运行期有影响，但会自动缩放
* AutoScaleMode是2.0引入的，默认的Font选项包含了Dpi。当出现OnFontChanged事件时会自动调用PerformAutoScale()
* 如果控件出问题了可以试试在容器上调用PerformAutoScale()，但我还没试出过问题，动态创建也没问题
* 4.7内置支持高DPI到PM2，添加manifest，取消注释Win10兼容性和dpiAware的部分即可。不考虑使用app.config的方法
* Core3支持Application.SetHighDpiMode(HighDpiMode.SystemAware)，但最好不用这种方式，因为理想上要在程序启动前就改。.NET6的模板默认启用了此项
* 1703的manifest添加了一项gdiScaling，不知道是什么效果

```c#
// 老的方式，设置了这个就不需要manifest了。Main中调用，等于设置系统级别的感知，不支持XP
[System.Runtime.InteropServices.DllImport("user32.dll")]
static extern bool SetProcessDPIAware();
SetProcessDPIAware();

using (var g = CreateGraphics())
    dpiratio = Math.Max(g.DpiX, g.DpiY) / 96;

int btnWidth = (int)(btn.Size.Width * dpiratio); // Height略
btn.Size = new Size(newbtnWidth, newbtnHeight); // 不能改变btn.Size.Width，必须重新创建Size，要不就改btn.Width

// 4.7
dpiratio = this.DeviceDpi / 96;
this.LogicalToDeviceUnits(Size or int) // 相当于 * dpiratio
this.ScaleBitmapLogicalToDevice(Bitmap)
```

## 在按钮或菜单上绘制UAC盾牌的图标

```c#
[DllImport("user32")]
static extern int SendMessage(IntPtr hWnd, uint Msg, int wParam, IntPtr lParam);
const uint BCM_SETSHIELD = 0x160C;
SendMessage(btn1.Handle, BCM_SETSHIELD, 0, (IntPtr)1);
```

## 杂项

* UI线程上未处理的异常会触发Application.ThreadException事件
* 获取屏幕分辨率
  * System.Drawing.Rectangle rect = Screen.PrimaryScreen.Bounds; rect.Height、Width
  * System.Drawing.Size mSize = SystemInformation.WorkingArea.Size 工作区大小，不包括任务栏等
* 跨线程调用控件
  * 控件的Invoke/BeginInvoke：基本上就是当想修改控件c时单独写一个函数f `if(c.InvokeRequired) c.Invoke(f) else c.Text=xxx`。https://www.cnblogs.com/marshal-m/p/3201051.html#invoke 中还提到要处理IsHandleCreated为false的情况，此时控件尚未创建完成，需要自旋等待；官方文档没这样做，太麻烦了不记录。与委托的Invoke同名但其实不同
  * SynchronizationContext.Send/Post
  * BackgroundWorker
  * Control.CheckForIllegalCrossThreadCalls=false 静态属性，对所有控件生效，所以一般不用
* 不用标题栏拖动窗体
  * 从user32导入ReleaseCapture和SendMessage
  * 在想要拖动的控件的Mouse_Down事件中先调用前者，再调用后者传入(this.Handle, 0x112, 0xf012, 0)
  * 窗体的this.Text=""; this.ControlBox=false; MaximizedBounds=SystemInformation.WorkingArea
* 资源
  * 在Properties/Resources.resx中添加后，Properties/Resources.Designer.cs能看到强类型的属性
  * cs中用 Properties.Resources.属性名 或 .ResourceManager.GetObject/GetString/GetStream 获取
  * 支持添加多种资源如文件和图片，左上角选种类，添加后自动放到Resources目录中，二进制流在resx中base64编码；构建后嵌入exe（不明白是如何做到的，csproj中为None Include节点）
  * 窗体的resx在自己的Designer中有使用
  * Properties/Settings.settings里存东西实际会存到app.config的userSettings中，且可以在运行时修改和保存，支持许多C#类型：Properties.Settings.Default.属性名，Default.Save()
  * System.Configuration.ConfigurationManager含有ConnectionStrings和AppSettings两个类，运行时不可修改，类似于Dict，仅能存放string
* 在设计器中将现有控件重新分配给不同的父控件：工具箱中单击想用的Panel，将鼠标指针移至靠近想要添加的控件，就会附上，再画Panel轮廓
* .Net6使用System.Drawing需要System.Drawing.Common包，命名空间名称不变，仅支持Win

## UI库

* 这些库都不能作为样式应用在原有的程序上，而是必须从头用它们的控件；有的可能需要手动添加到工具箱中
* https://gitee.com/kwwwvagaa/net_winform_custom_control 博客里有创造过程，无主窗体，测试项目跑不起来，大小12MB，最后更新时间2021年6月
* https://gitee.com/yhuse/SunnyUI GPL，文档不错
* https://github.com/Taiizor/ReaLTaiizor 活着，但网站挂了，维护者只有一个土耳其的大学生。没啥文档
* https://github.com/dennismagno/metroframework-modern-ui Win8风格，2017年后只合并了PR；大小1MB
* https://github.com/N-a-r-w-i-n/MetroSet-UI 最后维护时间是2020年10月，500KB。高DPI有问题，要把AutoScaleMode调成DPI运行时才会与设计时一样大。关闭按钮用MetroSetControlBox
* https://github.com/IgnaceMaes/MaterialSkin 最后维护时间差不多是15、16年，提交数也不多
* https://github.com/ComponentFactory/Krypton https://github.com/Krypton-Suite/Standard-Toolkit 后者是活着的Fork不过改了许多，偏功能但也有一点美化，文档太差
* https://www.nevron.com/products-open-vision-winforms-ui-controls-overview.aspx 偏功能，有免费社区版
* https://gitee.com/linxuanchen/NanUI 基于CEF，都用前端技术了不如用WPF+WebView2啊，不考虑

## SharpDevelop

* 下SharpDevelop_5.1.0.5216_Xcopyable.zip，16MB
* Tools->Options调成中文，调整字体
* 会在%Appdata%\ICSharpCode中产生数据
* 最高支持4.5.2，但不需要装SDK也能用，不知道是不是自动用了4.7.2的
* 支持C#5，支持简单的自动属性、async、var，不支持字符串内插、?.、nameof
* 修改config为4.8

## TODO

* https://docs.microsoft.com/zh-cn/dotnet/desktop/winforms/controls/controls-to-use-on-windows-forms
* https://docs.microsoft.com/zh-cn/dotnet/desktop/winforms/controls/walkthrough-authoring-a-composite-control-with-visual-csharp
